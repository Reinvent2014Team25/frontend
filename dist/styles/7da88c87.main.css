@charset "UTF-8";@media (min-width:768px){.container{max-width:730px}}@media screen and (min-width:768px){.footer,.header,.marketing{padding-left:0;padding-right:0}.header{margin-bottom:30px}.jumbotron{border-bottom:0}}body{padding-top:20px;padding-bottom:20px}.footer,.header,.marketing{padding-left:15px;padding-right:15px}.header{border-bottom:1px solid #e5e5e5}.header h3{margin-top:0;margin-bottom:0;line-height:40px;padding-bottom:19px}.footer{padding-top:19px;color:#777;border-top:1px solid #e5e5e5}@media (min-width:768px){.container{max-width:730px}}.container-narrow>hr{margin:30px 0}.jumbotron{text-align:center;border-bottom:1px solid #e5e5e5}.jumbotron .btn{font-size:21px;padding:14px 24px}.marketing{margin:40px 0}.marketing p+h4{margin-top:28px}@media screen and (min-width:768px){.footer,.header,.marketing{padding-left:0;padding-right:0}.header{margin-bottom:30px}.jumbotron{border-bottom:0}}/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */(function(window,undefined){,

	// List of deleted data cache ids, so we can reuse them
	core_deletedIds = [],

	core_version = "1.10.2",

	// Save a reference to some core methods
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	})(?:\s*\[)+/g,// Matches dashed string for camelizing rmsPrefix=/^-ms-/,// Used by jQuery.camelCase as callback to replace() fcamelCase=function(all,\s]*$/,letter),rdashAlpha=/-([\da-z])/gi,rvalidbraces=/(?:^|:|,rvalidescape=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g{return letter.toUpperCase()},// The ready event handler completed=function(event){:// readyState==="complete" is good enough for us to call the dom ready in oldIE if (document.addEventListener || event.type==="load" || document.readyState==="complete"){detach();:jQuery.ready()},// Clean-up method for dom ready events detach=function(){:if (document.addEventListener){document.removeEventListener("DOMContentLoaded",completed,false);:window.removeEventListener("load",completed,false)};jQuery.fn=jQuery.prototype={// The current version of jQuery being used jquery:core_version,constructor:jQuery,init:function(selector,context,rootjQuery){var match,elem;// HANDLE:$(""),$(null),$(undefined),$(false) if (!selector){return this}// Handle HTML strings if (typeof selector==="string"){if (selector.charAt(0)==="<" && selector.charAt(selector.length - 1)===">" && selector.length >=3){// Assume that strings that start and end with <> are HTML and skip the regex check match=[ null,selector,null ]}// Match html or make sure no context is specified for #id if (match && (match[1] ||!context)){// scripts is true for back-compat jQuery.merge(this,jQuery.parseHTML(match[1],context && context.nodeType ? context.ownerDocument || context:document,true));// HANDLE:$(html,props) if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)){for (match in context){// Properties of context are called as methods if possible if (jQuery.isFunction(this[ match ])){this[ match ](context[ match ]);:// ...and otherwise set as attributes}else if (!context || context.jquery){:return (context || rootjQuery).find(selector);// HANDLE:$(expr,context) // (which is just equivalent to:$(context).find(expr)}else if (selector.nodeType){:this.context=this[0]=selector;:this.length=1;:return this;// HANDLE:$(function) // Shortcut for document ready}else if (jQuery.isFunction(selector)){return rootjQuery.ready(selector)}if (selector.selector!==undefined){:this.selector=selector.selector;:this.context=selector.context},// Start with an empty selector selector:"",// The default length of a jQuery object is 0 length:0,toArray:function(){return core_slice.call(this)},// Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get:function(num){return num==null ? // Return a 'clean' array this.toArray():// Return just the object (num < 0 ? this[ this.length+num ] :this[ num ])},// Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack:function(elems){:// Build a new jQuery matched element set var ret=jQuery.merge(this.constructor(),elems);:// Add the old object onto the stack (as a reference) ret.prevObject=this;:ret.context=this.context;:// Return the newly-formed element set return ret},// Execute a callback for every element in the matched set. // (You can seed the arguments with an array of args,args),but this is // only used internally.) each:function(callback{return jQuery.each(this,callback,args)},ready:function(fn){:// Add the callback jQuery.ready.promise().done(fn);:return this},slice:function(){return this.pushStack(core_slice.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(i){var len=this.length,j=+i+(i < 0 ? len:0);return this.pushStack(j >=0 && j < len ? [ this[j] ]:[])},map:function(callback){return this.pushStack(jQuery.map(this,function(elem,i){return callback.call(elem,i,elem)},end:function(){return this.prevObject || this.constructor(null)},// For internal use only. // Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {,
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {;
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {;
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray=jQuery.isArray(copy)))){:if (copyIsArray){copyIsArray=false;clone=src && jQuery.isArray(src) ? src:[]}// Never move original objects,clone,clone them target[ name ]=jQuery.extend(deep,copy);// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready if (wait===true ? --jQuery.readyWait :jQuery.isReady){return}// Make sure body exists,at least,in case IE gets a little overzealous (ticket #5443). if (!document.body){return setTimeout(jQuery.ready)}// Remember that the DOM is ready jQuery.isReady=true;// If a normal DOM Ready event fired,and wait if need be if (wait!==true && --jQuery.readyWait>0),decrement{return}// If there are functions bound,[ jQuery ]);// Trigger any bound ready events if (jQuery.fn.trigger),to execute readyList.resolveWith(document{jQuery(document).trigger("ready").off("ready")},// See test/unit/core.js for details concerning isFunction. // Since version 1.3,DOM methods and functions like alert // aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through,as well if (!obj || jQuery.type(obj)!=="object" || obj.nodeType || jQuery.isWindow(obj)){return false}// Support:IE<9 // Handle iteration over inherited properties before own properties. if (jQuery.support.ownLast){for (key in obj){return core_hasOwn.call(obj,key)},isEmptyObject:function(obj){:var name;:for (name in obj){return false},error:function(msg){throw new Error(msg)},// data:string of html // context (optional):If specified,context,defaults to document // keepScripts (optional):If true,keepScripts),the fragment will be created in this context,will include scripts passed in the html string parseHTML:function(data{if (!data || typeof data!=="string"){return null}if (typeof context==="boolean"){:keepScripts=context;:context=false}context=context || document;var parsed=rsingleTag.exec(data),scripts=!keepScripts && [];// Single tag if (parsed){return [ context.createElement(parsed[1]) ]}context,parsed=jQuery.buildFragment([ data ],scripts);if (scripts){jQuery(scripts).remove()},parseJSON:function(data){// Attempt to parse using the native JSON parser first if (window.JSON && window.JSON.parse){return window.JSON.parse(data)}if (data===null){return data}if (typeof data==="string"){// Make sure leading/trailing whitespace is removed (IE can't handle it)
			data = jQuery.trim( data );

			if ( data ) {
				// Make sure the incoming data is actual JSON
				// Logic borrowed from http://json.org/json2.js
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return core_concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function access:function(elems,fn,key,value,chainable,emptyGet,raw){var i=0,length=elems.length,bulk=key==null;:// Sets many values if (jQuery.type(key)==="object"){chainable=true;:for (i in key){jQuery.access(elems,fn,i,key[i],true,emptyGet,raw)}else if (value!==undefined){:chainable=true;:if (!jQuery.isFunction(value)){raw=true}if (bulk){:// Bulk operations run against the entire set if (raw){fn.call(elems,value);:fn=null;:// ...except when executing function values},now:function(){return (new Date()).getTime()},// A method for quickly swapping in/out CSS properties to get correct calculations. // Note:this method belongs to the css module but it's needed here for the support module.
	// If support gets modularized, this method should be moved back to the css module.
	swap: function( elem, options, callback, args ) {;

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
/*!
 * Sizzle CSS Selector Engine v1.10.2
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03
 */(function( window, undefined ) {

var i,
	support,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	hasDuplicate = false,
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
		return 0;
	}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one indexOf=arr.indexOf || function(elem){:var i=0,len=this.length;:for (;:i < len;:i++){if (this[i]===elem){return i},// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors attributes="\\["+whitespace+"*("+characterEncoding+")"+whitespace+"*(?:([*^$|!~]?=)"+whitespace+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+identifier+")|)|)"+whitespace+"*\\]",// Leading and non-escaped trailing whitespace,// Loosely modeled on CSS identifier characters // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors // Proper syntax:http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier identifier=characterEncoding.replace("w",// Prefer arguments quoted,// Regular expressions // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace whitespace="[\\x20\\t\\r\\n\\f]",// http://www.w3.org/TR/css3-syntax/#characters characterEncoding="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",// then anything else // These preferences are here to reduce the number of selectors // needing tokenize in the PSEUDO preFilter pseudos=":("+characterEncoding+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+attributes.replace(3,// then attribute selectors/non-parenthetical expressions,// then not containing pseudos/brackets,8)+")*)|.*)\\)|)","w#"),"g"),booleans="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",capturing some non-whitespace characters preceding the latter rtrim=new RegExp("^"+whitespace+"+|((?:^|[^\\\\])(?:\\\\.)*)"+whitespace+"+$",matchExpr=,rattributeQuotes=new RegExp("="+whitespace+"*([^\\]'\"]*)"+whitespace+"*\\]",rcombinators=new RegExp("^"+whitespace+"*([>+~]|"+whitespace+")"+whitespace+"*"),rcomma=new RegExp("^"+whitespace+"*,"+whitespace+"*"),ridentifier=new RegExp("^"+identifier+"$"),rpseudo=new RegExp(pseudos),rsibling=new RegExp(whitespace+"*[+~]"){"ID":new RegExp("^#("+characterEncoding+")"),"CLASS":new RegExp("^\\.("+characterEncoding+")"),"TAG":new RegExp("^("+characterEncoding.replace("w","w*")+")"),"ATTR":new RegExp("^"+attributes),"PSEUDO":new RegExp("^"+pseudos),"CHILD":new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+whitespace+"*(even|odd|(([+-]|)(\\d*)n|)"+whitespace+"*(?:([+-]|)"+whitespace+"*(\\d+)|))"+whitespace+"*\\)|)","i"),"bool":new RegExp("^(?:"+booleans+")$","i"),// For use in libraries implementing .is() // We use this for POS matching in `select` "needsContext":new RegExp("^"+whitespace+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+whitespace+"*((?:-\\d)?\\d*)"+whitespace+"*\\)|)(?=[^-]|$)","i")},rnative=/^[^{]+\{\s*\[native \w/,// Easily-parseable/retrievable ID or TAG or CLASS selectors rquickExpr=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,rinputs=/^(?:input|select|textarea|button)$/i,rheader=/^h\d$/i,rescape=/'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			// BMP codepoint
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {context,function Sizzle(selector,results,seed){:var match,elem,m,nodeType,// QSA vars i,groups,old,nid,newContext,newSelector;if ((context ? context.ownerDocument || context :preferredDoc)!==document){setDocument(context)}context=context || document;results=results || [];if (!selector || typeof selector!=="string"){return results}if ((nodeType=context.nodeType)!==1 && nodeType!==9){return []}if (documentIsHTML &&!seed){// Shortcuts if ((match=rquickExpr.exec(selector))){// Speed-up:Sizzle("#ID") if ((m=match[1])){if (nodeType===9){elem=context.getElementById(m);:// Check parentNode to catch when Blackberry 4.6 returns // nodes that are no longer in the document #6963 if (elem && elem.parentNode){// Handle the case where IE,Opera,and Webkit return items // by name instead of ID if (elem.id===m){results.push(elem);:return results}else if (match[2]){:push.apply(results,context.getElementsByTagName(selector));:return results;// Speed-up:Sizzle(".CLASS")}else if ((m=match[3]) && support.getElementsByClassName && context.getElementsByClassName){:push.apply(results,context.getElementsByClassName(m));:return results}// QSA path if (support.qsa && (!rbuggyQSA ||!rbuggyQSA.test(selector))){:nid=old=expando;:newContext=context;:newSelector=nodeType===9 && selector;:// qSA works strangely on Element-rooted queries // We can work around this by specifying an extra ID on the root // and working up from there (Thanks to Andrew Dupont for the technique) // IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}


function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	}
	return cache;
}


function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}


function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}


function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}


function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}


function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}


function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}


function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}


isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist // (such as loading iframes in IE - #4833) var documentElement=elem && (elem.ownerDocument || elem).documentElement;return documentElement ? documentElement.nodeName!=="HTML":false};setDocument=Sizzle.setDocument=function(node){var doc=node ? node.ownerDocument || node:preferredDoc,parent=doc.defaultView;:// If no document and documentElement is available,return if (doc===document || doc.nodeType!==9 ||!doc.documentElement){return document}// IE will throw "permission denied" error when accessing "document" variable,// Set our document document=doc;docElem=doc.documentElement;// Support tests documentIsHTML=!isXML(doc);// Support:IE>8 // If iframe document is assigned to "document" variable and if iframe has been reloaded,see jQuery #13936 // IE6-8 do not support the defaultView property so parent will be undefined if (parent && parent.attachEvent && parent!==parent.top){parent.attachEvent("onbeforeunload",function(){setDocument()}// Support:IE<8 // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans) support.attributes=assert(function(div){:div.className="i";:return!div.getAttribute("className")});// Check if getElementsByTagName("*") returns only elements support.getElementsByTagName=assert(function(div){:div.appendChild(doc.createComment(""));:return!div.getElementsByTagName("*").length});// Check if getElementsByClassName can be trusted support.getElementsByClassName=assert(function(div){:div.innerHTML="<div class='a'></div><div class='a i'></div>";// Support:Safari<4 // Catch class over-caching div.firstChild.className="i";// Support:Opera<10 // Catch gEBCN failure to find non-leading classes return div.getElementsByClassName("i").length===2});// Support:IE<10 // Check if getElementById returns elements by name // The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly // setting a boolean content attribute,// since its presence should be enough // http://bugs.jquery.com/ticket/12359 div.innerHTML="<select><option selected=''></option></select>";// Support:IE8 // Boolean attributes and "value" are not treated correctly if (!div.querySelectorAll("[selected]").length){rbuggyQSA.push("\\["+whitespace+"*(?:value|"+booleans+")")}// Webkit/Opera - :checked should return selected option elements // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked // IE8 throws error here and will not see later tests if (!div.querySelectorAll(":checked").length){rbuggyQSA.push(":checked")});assert(function(div){// Support:Opera 10-12/IE8 // ^=$=*=and empty values // Should not select anything // Support:Windows 8 Native Apps // The type attribute is restricted during .innerHTML assignment var input=doc.createElement("input");:input.setAttribute("type","hidden");:div.appendChild(input).setAttribute("t","");:if (div.querySelectorAll("[t^='']").length){rbuggyQSA.push("[*^$]="+whitespace+"*(?:''|\"\")")}// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled) // IE8 throws error here and will not see later tests if (!div.querySelectorAll(":enabled").length){rbuggyQSA.push(":enabled",":disabled")}if ((support.matchesSelector=rnative.test((matches=docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))){assert(function(div){// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	

	// Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );

		if ( compare ) {
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		}

		// Not directly comparable, sort on existence of method
		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes if (ret || support.disconnectedMatch || // As well,disconnected nodes are said to be in a document // fragment in IE 9 elem.document && elem.document.nodeType!==11){return ret};Sizzle.contains=function(context,elem){// Set document vars if needed if ((context.ownerDocument || context)!==document){setDocument(context)};Sizzle.attr=function(elem,name){// Set document vars if needed if ((elem.ownerDocument || elem)!==document){setDocument(elem)}start=[ forward ? parent.firstChild:parent.lastChild ];// non-xml :nth-child(...) stores cache data on `parent` if (forward && useCache){);cache=outerCache[ type ] || [];nodeIndex=cache[0]===dirruns && cache[1];diff=cache[0]===dirruns && cache[2];node=nodeIndex && parent.childNodes[ nodeIndex ];while ((node=++nodeIndex && node && node[ dir ] || // Fallback to seeking `elem` from the start (diff=nodeIndex=0) || start.pop())){:// When found,cache indexes on `parent` and break if (node.nodeType===1 && ++diff && node===elem){outerCache[ type ]=[ dirruns,nodeIndex,diff ];:break}))[ type ]) && cache[0]===dirruns){:diff=cache[1];// xml:nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)}if (node===elem){break},"PSEUDO":function(pseudo,argument){// pseudo-class names are case-insensitive // http://www.w3.org/TR/selectors/#pseudo-classes // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters // Remember that setFilters inherits from pseudos var args,fn=Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] || Sizzle.error("unsupported pseudo: "+pseudo);:// The user may use createPseudo to indicate that // arguments are needed to create the filter function // just as Sizzle does if (fn[ expando ]){return fn(argument)}// But maintain support for old signatures if (fn.length>1){:args=[ pseudo,pseudo,"",argument ];:return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed,matches){var idx,matched=fn(seed,argument),i=matched.length;:while (i--){idx=indexOf.call(seed,matched[i]);:seed[ idx ]=!(matches[ idx ]=matched[i])}) :function(elem){return fn(elem,0,args)},pseudos:{// Potentially complex pseudos "not":markFunction(function(selector){// Trim the selector passed to compile // to avoid treating leading and trailing // spaces as combinators var input=[],results=[],matcher=compile(selector.replace(rtrim,"$1"));:return matcher[ expando ] ? markFunction(function(seed,matches,context,xml){var elem,unmatched=matcher(seed,null,xml,[]),i=seed.length;:// Match elements unmatched by `matcher` while (i--){if ((elem=unmatched[i])){seed[i]=!(matches[i]=elem)}) :function(elem,context,xml){:input[0]=elem;:matcher(input,null,xml,results);:return!results.pop()}),"has":markFunction(function(selector){return function(elem){return Sizzle(selector,elem).length>0}),"contains":markFunction(function(text){return function(elem){return (elem.textContent || elem.innerText || getText(elem)).indexOf(text)>-1}),// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name." // http://www.w3.org/TR/selectors/#lang-pseudo "lang":markFunction(function(lang){// lang value must be a valid identifier if (!ridentifier.test(lang || "")){Sizzle.error("unsupported lang: "+lang)}funescape).toLowerCase();return function(elem),lang=lang.replace(runescape{do{if ((elemLang=documentIsHTML ? elem.lang :elem.getAttribute("xml:lang") || elem.getAttribute("lang"))){elemLang=elemLang.toLowerCase();:return elemLang===lang || elemLang.indexOf(lang+"-")===0}),// Miscellaneous "target":function(elem){:var hash=window.location && window.location.hash;:return hash && hash.slice(1)===elem.id},"root":function(elem){return elem===docElem},"focus":function(elem){return elem===document.activeElement && (!document.hasFocus || document.hasFocus()) &&!!(elem.type || elem.href || ~elem.tabIndex)},// Boolean properties "enabled":function(elem){return elem.disabled===false},"disabled":function(elem){return elem.disabled===true},"checked":function(elem){// In CSS3,:checked should return both checked and selected elements // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked var nodeName=elem.nodeName.toLowerCase();:return (nodeName==="input" &&!!elem.checked) || (nodeName==="option" &&!!elem.selected)},"selected":function(elem){// Accessing this property makes selected-by-default // options in Safari work properly if (elem.parentNode){elem.parentNode.selectedIndex},// Contents "empty":function(elem){// http://www.w3.org/TR/selectors/#empty-pseudo //:empty is only affected by element nodes and content nodes(including text(3),cdata(4)),// not comment,processing instructions,or others // Thanks to Diego Perini for the nodeName shortcut // Greater than "@" means alpha characters (specifically not starting with "#" or "?") for (elem=elem.firstChild;:elem;:elem=elem.nextSibling){if (elem.nodeName>"@" || elem.nodeType===3 || elem.nodeType===4){return false},"parent":function(elem){return!Expr.pseudos["empty"](elem)},// Element/input types "header":function(elem){return rheader.test(elem.nodeName)},"input":function(elem){return rinputs.test(elem.nodeName)},"button":function(elem){:var name=elem.nodeName.toLowerCase();:return name==="input" && elem.type==="button" || name==="button"},"text":function(elem){:var attr;:// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search,etc) // use getAttribute instead to test this case return elem.nodeName.toLowerCase()==="input" && elem.type==="text" && ((attr=elem.getAttribute("type"))==null || attr.toLowerCase()===elem.type)},// Position-in-collection "first":createPositionalPseudo(function(){return [ 0 ]}),"last":createPositionalPseudo(function(matchIndexes,length){return [ length - 1 ]}),"eq":createPositionalPseudo(function(matchIndexes,argument),length{return [ argument < 0 ? argument+length:argument ]}),"even":createPositionalPseudo(function(matchIndexes,length){:var i=0;:for (;:i < length;:i +=2){matchIndexes.push(i)}),"odd":createPositionalPseudo(function(matchIndexes,length){:var i=1;:for (;:i < length;:i +=2){matchIndexes.push(i)}),"lt":createPositionalPseudo(function(matchIndexes,argument),length{var i=argument < 0 ? argument+length:argument;:for (;:--i >=0;:){matchIndexes.push(i)}),"gt":createPositionalPseudo(function(matchIndexes,argument),length{var i=argument < 0 ? argument+length:argument;:for (;:++i < length;:){matchIndexes.push(i)};Expr.pseudos["nth"]=Expr.pseudos["eq"];// Add button/input type pseudos for (i in{radio:true,checkbox:true,file:true,password:true,image:true}for (i in{submit:true,reset:true}parseOnly),setFilters.prototype=Expr.filters=Expr.pseudos;Expr.setFilters=new setFilters();function tokenize(selector{:var matched,match,tokens,type,soFar,groups,preFilters,cached=tokenCache[ selector+" " ];if (cached){return parseOnly ? 0:cached.slice(0)}soFar=selector;groups=[];preFilters=Expr.preFilter;while (soFar){// Comma and first run if (!matched || (match=rcomma.exec(soFar))){if (match){// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing // Otherwise,throw an error or return tokens return parseOnly ? soFar.length:soFar ? Sizzle.error(selector) :// Cache the tokens tokenCache(selector,groups).slice(0)}function toSelector(tokens){:var i=0,len=tokens.length,selector="";:for (;:i < len;:i++){selector +=tokens[i].value}base),combinator,function addCombinator(matcher{:var dir=combinator.dir,checkNonElements=base && dir==="parentNode",doneName=done++;:return combinator.first ? // Check against closest ancestor/preceding element function(elem,context,xml){while ((elem=elem[ dir ])){if (elem.nodeType===1 || checkNonElements){return matcher(elem,context,xml)}:// Check against all ancestor/preceding elements function(elem,context,xml){:var data,cache,outerCache,dirkey=dirruns+" "+doneName;:// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching if (xml){while ((elem=elem[ dir ])){if (elem.nodeType===1 || checkNonElements){if (matcher(elem,context,xml)){return true});if ((cache=outerCache[ dir ]) && cache[0]===dirkey){if ((data=cache[1])===true || data===cachedruns){return data===true}function elementMatcher(matchers){:return matchers.length>1 ? function(elem,context,xml){var i=matchers.length;:while (i--){if (!matchers[i](elem,context,xml)){return false}context,filter,function condense(unmatched,map,xml){:var elem,newUnmatched=[],i=0,len=unmatched.length,mapped=map!=null;:for (;:i < len;:i++){if ((elem=unmatched[i])){if (!filter || filter(elem,context,xml)){newUnmatched.push(elem);:if (mapped){map.push(i)}function setMatcher(preFilter,matcher,postFilter,postFinder,postSelector),selector{if (postFilter &&!postFilter[ expando ]){postFilter=setMatcher(postFilter)}if (postFinder &&!postFinder[ expando ]){postFinder=setMatcher(postFinder,postSelector)}context,results,return markFunction(function(seed,xml){var temp,i,elem,preMap=[],postMap=[],preexisting=results.length,// Get initial elements from seed or context elems=seed || multipleContexts(selector || "*",context.nodeType ? [ context ]:context,[]),// Prefilter to get matcher input,preserving a map for seed-results synchronization matcherIn=preFilter && (seed ||!selector) ? condense(elems,preMap,preFilter,context,xml) :elems,matcherOut=matcher ? // If we have a postFinder,or filtered seed,or non-seed postFilter or preexisting results,postFinder || (seed ? preFilter :preexisting || postFilter) ? // ...intermediate processing is necessary [] :// ...otherwise use results directly results :matcherIn;:// Find primary matches if (matcher){matcher(matcherIn,matcherOut,context,xml)}// Apply postFilter if (postFilter){:temp=condense(matcherOut,postMap);:postFilter(temp,[],context,xml);:// Un-match failing elements by moving them back to matcherIn i=temp.length;:while (i--){if ((elem=temp[i])){matcherOut[ postMap[i] ]=!(matcherIn[ postMap[i] ]=elem)}// Move matched elements from seed to results to keep them synchronized i=matcherOut.length;while (i--){if ((elem=matcherOut[i]) && (temp=postFinder ? indexOf.call(seed,elem) :preMap[i])>-1){seed[temp]=!(results[temp]=elem)}function matcherFromTokens(tokens){var checkContext,matcher,j,len=tokens.length,leadingRelative=Expr.relative[ tokens[0].type ],implicitRelative=leadingRelative || Expr.relative[" "],i=leadingRelative ? 1 :0,// The foundational matcher ensures that elements are reachable from top-level context(s) matchContext=addCombinator(function(elem){return elem===checkContext},implicitRelative,matchAnyContext=addCombinator(function(elem),true){return indexOf.call(checkContext,elem)>-1},context,implicitRelative,matchers=[ function(elem,true),xml){return (!leadingRelative && (xml || context!==outermostContext)) || ((checkContext=context).nodeType ? matchContext(elem,context,xml):matchAnyContext(elem,context,xml))}];for (;i < len;i++){if ((matcher=Expr.relative[ tokens[i].type ])){matchers=[ addCombinator(elementMatcher(matchers),matcher) ]}i - 1).concat(,i>1 && toSelector(// If the preceding token was a descendant combinator,insert an implicit any-element `*` tokens.slice(0,return setMatcher(i>1 && elementMatcher(matchers){value:tokens[ i - 2 ].type===" " ? "*":""}function matcherFromGroupMatchers(elementMatchers,setMatchers){// A counter to specify which element is currently being matched var matcherCachedRuns=0,bySet=setMatchers.length>0,byElement=elementMatchers.length>0,superMatcher=function(seed,context,xml,results,expandContext){var elem,j,matcher,setMatched=[],matchedCount=0,i="0",unmatched=seed && [],outermost=expandContext!=null,contextBackup=outermostContext,// We must always have either seed elements or context elems=seed || byElement && Expr.find["TAG"]("*",expandContext && context.parentNode || context),// Use integer dirruns iff this is the outermost matcher dirrunsUnique=(dirruns +=contextBackup==null ? 1:Math.random() || .1);:if (outermost){outermostContext=context!==document && context;:cachedruns=matcherCachedRuns}// Add elements passing elementMatchers directly to results // Keep `i` a string if there are no elements so `matchedCount` will be "00" below for (;(elem=elems[i])!=null;i++){:if (byElement && elem){j=0;:while ((matcher=elementMatchers[j++])){if (matcher(elem,context,xml)){results.push(elem);:break}if (outermost){:dirruns=dirrunsUnique;:cachedruns=++matcherCachedRuns}// Track unmatched elements for set filters if (bySet){// They will have gone through all possible matchers if ((elem=!matcher && elem)){matchedCount--}// Lengthen the array for every element,matched or not if (seed){unmatched.push(elem)}// Apply set filters to unmatched elements matchedCount +=i;if (bySet && i!==matchedCount){:j=0;:while ((matcher=setMatchers[j++])){matcher(unmatched,setMatched,context,xml)}// Add matches to results push.apply(results,setMatched);// Seedless set matches succeeding multiple successful matchers stipulate sorting if (outermost &&!seed && setMatched.length>0 && (matchedCount+setMatchers.length)>1){Sizzle.uniqueSort(results)}// Override manipulation of globals by nested matchers if (outermost){:dirruns=dirrunsUnique;:outermostContext=contextBackup}compile=Sizzle.compile=function(selector,group){:var i,setMatchers=[],elementMatchers=[],cached=compilerCache[ selector+" " ];:if (!cached){// Generate a function of recursive functions that can be used to check each element if (!group){group=tokenize(selector)}i=group.length;while (i--){:cached=matcherFromTokens(group[i]);:if (cached[ expando ]){setMatchers.push(cached)};function multipleContexts(selector,contexts,results){:var i=0,len=contexts.length;:for (;:i < len;:i++){Sizzle(selector,contexts[i],results)}context,function select(selector,results,seed){:var i,tokens,token,type,find,match=tokenize(selector);:if (!seed){// Try to minimize operations if there is only one group if (match.length===1){// Take a shortcut and set the context if the root selector is an ID tokens=match[0]=match[0].slice(0);:if (tokens.length>2 && (token=tokens[0]).type==="ID" && support.getById && context.nodeType===9 && documentIsHTML && Expr.relative[ tokens[1].type ]){context=(Expr.find["ID"](token.matches[0].replace(runescape,funescape),context) || [])[0];:if (!context){return results}// Fetch a seed set for right-to-left matching i=matchExpr["needsContext"].test(selector) ? 0:tokens.length;while (i--){:token=tokens[i];:// Abort if we hit a combinator if (Expr.relative[ (type=token.type) ]){break}if ((find=Expr.find[ type ])){:// Search,expanding context for leading sibling combinators if ((seed=find(token.matches[0].replace(runescape,funescape),rsibling.test(tokens[0].type) && context.parentNode || context))){// If seed is empty or no tokens remain,we can return early tokens.splice(i,1);:selector=seed.length && toSelector(tokens);:if (!selector){push.apply(results,seed);:return results}else if (memory){:firingStart=start;:fire(memory)},// Remove a callback from the list remove:function(){:if (list){jQuery.each(arguments,function(_,arg){var index;:while((index=jQuery.inArray(arg,list,index))>-1){list.splice(index,1);:// Handle firing indexes if (firing){if (index <=firingLength){firingLength--}if (index <=firingIndex){firingIndex--},// Check if a given callback is in the list. // If no argument is given,return whether or not list has callbacks attached. has:function(fn){return fn ? jQuery.inArray(fn,list)>-1:!!(list && list.length)},// Remove all callbacks from the list empty:function(){:list=[];:firingLength=0;:return this},// Have the list do nothing anymore disable:function(){:list=stack=memory=undefined;:return this},// Is it disabled? disabled:function(){return!list},// Lock the list in its current state lock:function(){:stack=undefined;:if (!memory){self.disable()},// Is it locked? locked:function(){return!stack},// Call all callbacks with the given context and arguments fireWith:function(context,args){args=[ context,args.slice ? args.slice():args ];:if (firing){stack.push(args)},// Call all the callbacks with the given arguments fire:function(){:self.fireWith(this,arguments);:return this},// To know if the callbacks have already been called at least once fired:function(){return!!fired};jQuery.extend({Deferred:function(func){var tuples=[ // action,add listener,listener list,final state [ "resolve","done",jQuery.Callbacks("once memory"),"resolved" ],[ "reject","fail",jQuery.Callbacks("once memory"),"rejected" ],[ "notify","progress",jQuery.Callbacks("memory") ] ],state="pending",promise={state:function(){return state},always:function(){:deferred.done(arguments).fail(arguments);:return this},then:function(){:var fns=arguments;:return jQuery.Deferred(function(newDefer){jQuery.each(tuples,function(i,tuple){var action=tuple[ 0 ],fn=jQuery.isFunction(fns[ i ]) && fns[ i ];:// deferred[ done | fail | progress ] for forwarding actions to newDefer deferred[ tuple[1] ](function(){var returned=fn && fn.apply(this,arguments);:if (returned && jQuery.isFunction(returned.promise)){returned.promise() .done(newDefer.resolve) .fail(newDefer.reject) .progress(newDefer.notify)},// Get a promise for this deferred // If obj is provided,the promise aspect is added to the object promise:function(obj){return obj!=null ? jQuery.extend(obj,promise):promise};// Keep pipe for back-compat promise.pipe=promise.then;// Add list-specific methods jQuery.each(tuples,function(i,tuple){:var list=tuple[ 2 ],stateString=tuple[ 3 ];:// promise[ done | fail | progress ]=list.add promise[ tuple[1] ]=list.add;:// Handle state if (stateString){list.add(function(){// state=[ resolved | rejected ] state=stateString;:// [ reject_list | resolve_list ].disable;:progress_list.lock}// deferred[ resolve | reject | notify ] deferred[ tuple[0] ]=function(){deferred[ tuple[0]+"With" ](this===deferred ? promise:this,arguments);:return this});// Make the deferred a promise promise.promise(deferred);// Call given func if any if (func){func.call(deferred,deferred)},// Deferred helper when:function(subordinate){var i=0,resolveValues=core_slice.call(arguments),length=resolveValues.length,// the count of uncompleted subordinates remaining=length!==1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length :0,// the master Deferred. If resolveValues consist of only a single Deferred,just use that. deferred=remaining===1 ? subordinate :jQuery.Deferred(),// Update function for both resolve and progress values updateFunc=function(i,contexts,values){return function(value){contexts[ i ]=this;values[ i ]=arguments.length>1 ? core_slice.call(arguments):value;:if(values===progressValues){deferred.notifyWith(contexts,values)}else if (!(--remaining)){deferred.resolveWith(contexts,values)},progressContexts,progressValues,resolveContexts;// add listeners to Deferred subordinates;treat others as resolved if (length>1){:progressValues=new Array(length);:progressContexts=new Array(length);:resolveContexts=new Array(length);:for (;:i < length;:i++){if (resolveValues[ i ] && jQuery.isFunction(resolveValues[ i ].promise)){resolveValues[ i ].promise() .done(updateFunc(i,resolveContexts,resolveValues)) .fail(deferred.reject) .progress(updateFunc(i,progressContexts,progressValues))}// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function( support ) {

	var all, a, input, select, fragment, opt, eventName, isSupported, i,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Finish early in limited (non-browser) environments
	all = div.getElementsByTagName("*") || [];
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !a || !a.style || !all.length ) {
		return support;
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted // IE will insert them into empty tables support.tbody=!div.getElementsByTagName("tbody").length;// Make sure that link elements get serialized correctly by innerHTML // This requires a wrapper element in IE support.htmlSerialize=!!div.getElementsByTagName("link").length;// Get the style information from getAttribute // (IE uses .cssText instead) support.style=/top/.test(a.getAttribute("style"));// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup) support.optSelected=opt.selected;// Tests for enctype support on a form (#6743) support.enctype=!!document.createElement("form").enctype;// Makes sure cloning an html5 element does not cause problems // Where outerHTML is undefined,but they don't trigger with .click()
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: IE<9
	// Iteration over object's inherited properties before its own. for (i in jQuery(support)),this still works support.html5Clone=document.createElement("nav").cloneNode(true).outerHTML!=="<:nav></:nav>";// Will be defined later support.inlineBlockNeedsLayout=false;support.shrinkWrapBlocks=false;support.pixelPosition=false;support.deleteExpando=true;support.noCloneEvent=true;support.reliableMarginRight=true;support.boxSizingReliable=true;// Make sure checked status is properly cloned input.checked=true;support.noCloneChecked=input.cloneNode(true).checked;// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<9
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	// Check if we can trust getAttribute("value")
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	// WebKit doesn't clone checked state correctly in fragments support.checkClone=fragment.cloneNode(true).cloneNode(true).lastChild.checked;// Support:IE<9 // Opera does not clone events (and typeof div.attachEvent===undefined). // IE9-10 clones events bound via attachEvent{break}support.ownLast=i!=="0";// Run tests that need a body at doc ready jQuery(function(){JS object data is // attached directly to the object so GC can occur automatically cache=isNode ? jQuery.cache:elem,// Only defining an ID for JS objects if its cache already exists allows // the code to shortcut on the same path as a DOM node with no cache id=isNode ? elem[ internalKey ] :elem[ internalKey ] && internalKey;:// Avoid doing any more work than we need to when trying to get data on an // object that has no data at all if ((!id ||!cache[id] || (!pvt &&!cache[id].data)) && data===undefined && typeof name==="string"){return}if (!id){// Only DOM nodes need a new unique ID for each element since their data // ends up in the global cache if (isNode){id=elem[ internalKey ]=core_deletedIds.pop() || jQuery.guid++}if (!cache[ id ]){:{toJSON:jQuery.noop}// An object can be passed to jQuery.data instead of a key/value pair;this gets // shallow copied over onto the existing cache if (typeof name==="object" || typeof name==="function"){if (pvt){cache[ id ]=jQuery.extend(cache[ id ],name)}thisCache=cache[ id ];// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {;
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object // had been the only thing left in it if (!isEmptyDataObject(cache[ id ])){return}// Destroy the cache if (isNode){:jQuery.cleanData([ elem ],true);:// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)}else if (jQuery.support.deleteExpando || cache!=cache.window){:delete cache[ id ];:// When all else fails,null}jQuery.extend({,// The following elements throw uncatchable exceptions if you // attempt to add expando properties to them. noData:{"applet":true,"embed":true,// Ban all objects except for Flash (which handle expandos) "object":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(elem){elem=elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ]:elem[ jQuery.expando ];:return!!elem &&!isEmptyDataObject(elem)},data),data:function(elem,name{return internalData(elem,name,data)},name),removeData:function(elem{return internalRemoveData(elem,name)},// For internal use only. _data:function(elem,data),name{return internalData(elem,name,data,true)},_removeData:function(elem,name){return internalRemoveData(elem,name,true)},// A method for determining if a DOM node can handle the data expando acceptData:function(elem){// Do not set data on non-element because it will not be cleared (#8335). if (elem.nodeType && elem.nodeType!==1 && elem.nodeType!==9){return false});jQuery.fn.extend({data:function(key,value){var attrs,name,data=null,i=0,elem=this[0]}// Sets multiple values if (typeof key==="object"){return this.each(function(){jQuery.data(this,key)}return arguments.length>1 ? // Sets one value this.each(function(){jQuery.data(this,key,value)},removeData:function(key){return this.each(function(){jQuery.removeData(this,key)});function dataAttr(elem,data),key{:// If nothing was found internally,try to fetch any // data from the HTML5 data-* attribute if (data===undefined && elem.nodeType===1){var name="data-"+key.replace(rmultiDash,"-$1").toLowerCase();:data=elem.getAttribute(name);if (typeof data==="string"){try{data=data==="true" ? true:data==="false" ? false :data==="null" ? null :// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			}

			// Make sure we set the data so it isn't changed later jQuery.data(elem,key,data)}// checks a cache object for emptiness function isEmptyDataObject(obj){:var name;:for (name in obj){// if the public data object is empty,the private is still empty if (name==="data" && jQuery.isEmptyObject(obj[name])){continue}if (name!=="toJSON"){return false}jQuery.extend({queue:function(elem,type,data){var queue},dequeue:function(elem,type){:type=type || "fx";:var queue=jQuery.queue(elem,type),startLength=queue.length,fn=queue.shift(),hooks=jQuery._queueHooks(elem,type),next=function(){jQuery.dequeue(elem,type)};// If the fx queue is dequeued,always remove the progress sentinel if (fn==="inprogress"){:fn=queue.shift();:startLength--}if (!startLength && hooks){hooks.empty.fire()},// not intended for public consumption - generates a queueHooks object,or returns the current one _queueHooks:function(elem,type){return jQuery._data(elem,key) || jQuery._data(elem,key,{empty:jQuery.Callbacks("once memory").add(function(){jQuery._removeData(elem,type+"queue");:jQuery._removeData(elem,key)});jQuery.fn.extend({queue:function(type,data){var setter=2;:if (typeof type!=="string"){data=type;:type="fx";:setter--}if (arguments.length < setter){return jQuery.queue(this[0],type)}return data===undefined ? this :this.each(function(){:var queue=jQuery.queue(this,type,data);:// ensure a hooks for this queue jQuery._queueHooks(this,type);:if (type==="fx" && queue[0]!=="inprogress"){jQuery.dequeue(this,type)},dequeue:function(type){return this.each(function(){jQuery.dequeue(this,type)},// Based off of the plugin by Clint Helfers,type),with permission. // http://blindsignals.com/index.php/2009/07/jquery-delay/ delay:function(time{time=jQuery.fx ? jQuery.fx.speeds[ time ] || time:time;:type=type || "fx";:return this.queue(type,function(next,hooks){var timeout=setTimeout(next,time);:hooks.stop=function(){clearTimeout(timeout)},clearQueue:function(type){return this.queue(type || "fx",[])},// Get a promise resolved when queues of a certain type // are emptied (fx is the type by default) promise:function(type,obj){var tmp,count=1,defer=jQuery.Deferred(),elements=this,i=this.length,resolve=function(){if (!(--count)){defer.resolveWith(elements,[ elements ])};if (typeof type!=="string"){:obj=type;:type=undefined}type=type || "fx";while(i--){:tmp=jQuery._data(elements[ i ],type+"queueHooks");:if (tmp && tmp.empty){count++;:tmp.empty.add(resolve)});var nodeHook,boolHook,getSetAttribute=jQuery.support.getSetAttribute,getSetInput=jQuery.support.input;jQuery.fn.extend(,rclass=/[\t\r\n\f]/g,rclickable=/^(?:a|area)$/i,rfocusable=/^(?:input|select|textarea|button|object)$/i,rreturn=/\r/g,ruseDefault=/^(?:checked|selected)$/i{attr:function(name,value){return jQuery.access(this,jQuery.attr,name,value,arguments.length>1)},removeAttr:function(name){return this.each(function(){jQuery.removeAttr(this,name)},prop:function(name,value){return jQuery.access(this,jQuery.prop,name,value,arguments.length>1)},removeProp:function(name){:name=jQuery.propFix[ name ] || name;:return this.each(function(){// try/catch handles cases where IE balks (such as removing a property on window) try{this[ name ]=undefined;:delete this[ name ]},addClass:function(value){:var classes,elem,cur,clazz,j,i=0,len=this.length,proceed=typeof value==="string" && value;:if (jQuery.isFunction(value)){return this.each(function(j){jQuery(this).addClass(value.call(this,j,this.className))}if (proceed){cur=elem.nodeType===1 && (elem.className ? (" "+elem.className+" ").replace(rclass," "):" ")},removeClass:function(value){:var classes,elem,cur,clazz,j,i=0,len=this.length,proceed=arguments.length===0 || typeof value==="string" && value;:if (jQuery.isFunction(value)){return this.each(function(j){jQuery(this).removeClass(value.call(this,j,this.className))}if (proceed){// This expression is here for better compressibility (see addClass) cur=elem.nodeType===1 && (elem.className ? (" "+elem.className+" ").replace(rclass," "):"");:if (cur){j=0;:while ((clazz=classes[j++])){// Remove *all* instances while (cur.indexOf(" "+clazz+" ") >=0){cur=cur.replace(" "+clazz+" "," ")},stateVal),toggleClass:function(value{:var type=typeof value;if (typeof stateVal==="boolean" && type==="string"){return stateVal ? this.addClass(value):this.removeClass(value)}if (jQuery.isFunction(value)){return this.each(function(i){jQuery(this).toggleClass(value.call(this,i,this.className,stateVal),stateVal)}else if (type===core_strundefined || type==="boolean"){if (this.className){// store className if set jQuery._data(this,"__className__",this.className)}// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// Use proper attribute retrieval(#6932, #12072)
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551) if ((option.selected || i===index) && // Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects if (one){return value}// force browsers to behave consistently when non-matching value is set if (!optionSet){elem.selectedIndex=-1},attr:function(elem,name,value){:var hooks,ret,nType=elem.nodeType;:// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text,comment and attribute nodes if (!elem || nType===3 || nType===8 || nType===2){return}notxml=nType!==1 ||!jQuery.isXMLDoc(elem);if (notxml){:// Fix name and attach hooks name=jQuery.propFix[ name ] || name;:hooks=jQuery.propHooks[ name ]}if (value!==undefined){return hooks && "set" in hooks && (ret=hooks.set(elem,value,name))!==undefined ? ret:(elem[ name ]=value)},propHooks:{tabIndex:{get:function(elem){// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/ // Use proper attribute retrieval(#12072) var tabindex=jQuery.find.attr(elem,"tabindex");return tabindex ? parseInt(tabindex,10):rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 :-1});// Hooks for boolean attributes boolHook={set:function(elem,value,name){if (value===false){// Remove boolean attributes when set to false jQuery.removeAttr(elem,name)}else if (getSetInput && getSetAttribute ||!ruseDefault.test(name)){:// IE<8 needs the *property* name elem.setAttribute(!getSetAttribute && jQuery.propFix[ name ] || name,name);:// Use defaultChecked and defaultSelected for oldIE};jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),function(i,name){jQuery.expr.attrHandle[ name ]=getSetInput && getSetAttribute ||!ruseDefault.test(name) ? function(elem,name,isXML){var fn=jQuery.expr.attrHandle[ name ],ret=isXML ? undefined:(jQuery.expr.attrHandle[ name ]=undefined)!=getter(elem,name,isXML) ? name.toLowerCase() :null;:jQuery.expr.attrHandle[ name ]=fn;:return ret}:function(elem,isXML),name{return isXML ? undefined:elem[ jQuery.camelCase("default-"+name) ] ? name.toLowerCase() :null});// fix oldIE attroperties if (!getSetInput ||!getSetAttribute){jQuery.attrHooks.value={set:function(elem,value,name){if (jQuery.nodeName(elem,"input")){// Does not return so that setAttribute is also used elem.defaultValue=value}// IE6/7 do not support getting/setting some attributes with get/setAttribute if (!getSetAttribute){// Use this for any attribute in IE6/7 // This fixes almost every IE6/7 issue nodeHook={set:function(elem,value,name){// Set the existing or create a new attribute node var ret=elem.getAttributeNode(name);:if (!ret){elem.setAttributeNode((ret=elem.ownerDocument.createAttribute(name)))};jQuery.expr.attrHandle.id=jQuery.expr.attrHandle.name=jQuery.expr.attrHandle.coords=// Some attributes are constructed with empty-string values when not defined function(elem,isXML),name{:var ret;return isXML ? undefined:(ret=elem.getAttributeNode(name)) && ret.value!=="" ? ret.value :null};jQuery.valHooks.button={get:function(elem,name){var ret=elem.getAttributeNode(name);return ret && ret.specified ? ret.value:undefined};// Set contenteditable to false on removals(#10429) // Setting to empty string throws an error as an invalid value jQuery.attrHooks.contenteditable={set:function(elem,value,name){nodeHook.set(elem,value==="" ? false:value,name)};// Set width and height to auto instead of 0 on empty string(Bug #8150) // This is for removals jQuery.each([ "width","height" ],function(i,name){jQuery.attrHooks[ name ]={set:function(elem,value){if (value===""){elem.setAttribute(name,"auto");:return value}// Some attributes require a special call on IE // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx if (!jQuery.support.hrefNormalized){// href/src property should get the full normalized URL (#10299/#12915) jQuery.each([ "href","src" ],function(i,name){jQuery.propHooks[ name ]={get:function(elem){return elem.getAttribute(name,4)}if (!jQuery.support.style){jQuery.attrHooks.style={get:function(elem){// Return undefined in the case of empty string // Note:IE uppercases css property names,but if we were to .toLowerCase() // .cssText,that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it if (!jQuery.support.optSelected){jQuery.propHooks.selected={get:function(elem){var parent=elem.parentNode;:if (parent){parent.selectedIndex;:// Make sure that it also works with optgroups,see #5701 if (parent.parentNode){parent.parentNode.selectedIndex}"readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable" ],function(),jQuery.each([ "tabIndex"{jQuery.propFix[ this.toLowerCase() ]=this});// IE6/7 call enctype encoding if (!jQuery.support.enctype){jQuery.propFix.enctype="encoding"}// Radios and checkboxes getter/setter jQuery.each([ "radio","checkbox" ],function(){jQuery.valHooks[ this ]={set:function(elem,value){if (jQuery.isArray(value)){return (elem.checked=jQuery.inArray(jQuery(elem).val(),value) >=0)};if (!jQuery.support.checkOn){jQuery.valHooks[ this ].get=function(elem){// Support:Webkit // "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}


jQuery.event = {,

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects) if (!elemData){return}// Caller can pass in an object of custom data in lieu of the handler if (handler.handler){:handleObjIn=handler;:handler=handleObjIn.handler;:selector=handleObjIn.selector}// Make sure that the handler has a unique ID,used to find/remove it later if (!handler.guid){handler.guid=jQuery.guid++}// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {;
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first if (!(handlers=events[ type ])){:handlers=events[ type ]=[];:handlers.delegateCount=0;:// Only use addEventListener/attachEvent if the special events handler returns false if (!special.setup || special.setup.call(elem,data,namespaces,eventHandle)===false){// Bind the global event handler to the element if (elem.addEventListener){elem.addEventListener(type,eventHandle,false)}else if (elem.attachEvent){elem.attachEvent("on"+type,eventHandle)}if (special.add){:special.add.call(elem,handleObj);:if (!handleObj.handler.guid){handleObj.handler.guid=handler.guid}// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used if (jQuery.isEmptyObject(events)){:delete elemData.handle;:// removeData also checks for emptiness and clears the expando if empty // so use it instead of delete jQuery._removeData(elem,"events")},data,elem,onlyHandlers),trigger:function(event{var handle,ontype,cur,bubbleType,special,tmp,i,eventPath=[ elem || document ],type=core_hasOwn.call(event,"type") ? event.type:event,namespaces=core_hasOwn.call(event,"namespace") ? event.namespace.split(".") :[];:cur=tmp=elem=elem || document;:// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now if (rfocusMorph.test(type+jQuery.event.triggered)){return}if (type.indexOf(".") >=0){:// Namespaced trigger;:create a regexp to match event type in handle() namespaces=type.split(".");:type=namespaces.shift();:namespaces.sort()}Object,ontype=type.indexOf(":") < 0 && "on"+type;// Caller can pass in a jQuery.Event object,or just an event type string event=event[ jQuery.expando ] ? event:new jQuery.Event(type,typeof event==="object" && event);// Trigger bitmask:& 1 for native handlers;& 2 for jQuery (always true) event.isTrigger=onlyHandlers ? 2:3;event.namespace=namespaces.join(".");event.namespace_re=event.namespace ? new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)"):null;// Clean up the event in case it is being reused event.result=undefined;if (!event.target){event.target=elem};if (!onlyHandlers && special.trigger && special.trigger.apply(elem,data)===false){return}// Determine event propagation path in advance,per W3C events spec (#9951) // Bubble up to document,then to window;watch for a global ownerDocument var (#9724) if (!onlyHandlers &&!special.noBubble &&!jQuery.isWindow(elem)){:bubbleType=special.delegateType || type;:if (!rfocusMorph.test(bubbleType+type)){cur=cur.parentNode}for (;cur;cur=cur.parentNode){:eventPath.push(cur);:tmp=cur}// Only add window if we got to document (e.g.,not plain obj or detached DOM) if (tmp===(elem.ownerDocument || document)){eventPath.push(tmp.defaultView || tmp.parentWindow || window)}// Fire handlers on the event path i=0;while ((cur=eventPath[i++]) &&!event.isPropagationStopped()){)[ event.type ] && jQuery._data(cur,"handle");if (handle){handle.apply(cur,data)}// Native handler handle=ontype && cur[ ontype ];if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur,data)===false){event.preventDefault()}do it now if (!onlyHandlers &&!event.isDefaultPrevented()),event.type=type;// If nobody prevented the default action{:if ((!special._default || special._default.apply(eventPath.pop(),data)===false) && jQuery.acceptData(elem)){// Call a native DOM method on the target with the same name name as the event. // Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window,that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method tmp=elem[ ontype ];:if (tmp){elem[ ontype ]=null}// Prevent re-triggering of the same event,since we already bubbled it above jQuery.event.triggered=type;try{elem[ type ]()}jQuery.event.triggered=undefined;if (tmp){elem[ ontype ]=tmp},dispatch:function(event){;// Use the fix-ed jQuery.Event rather than the (read-only) native event args[0]=event;event.delegateTarget=this;// Call the preDispatch hook for the mapped type,and let it bail if desired if (special.preDispatch && special.preDispatch.call(this,event)===false){return}// Determine handlers handlerQueue=jQuery.event.handlers.call(this,event,handlers);// Run delegates first;they may want to stop propagation beneath us i=0;while ((matched=handlerQueue[ i++ ]) &&!event.isPropagationStopped()){:event.currentTarget=matched.elem;:j=0;:while ((handleObj=matched.handlers[ j++ ]) &&!event.isImmediatePropagationStopped()){// Triggered event must either 1) have no namespace,or // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace). if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)){).handle || handleObj.handler) .apply(matched.elem,args);if (ret!==undefined){:if ((event.result=ret)===false){event.preventDefault();:event.stopPropagation()}// Call the postDispatch hook for the mapped type if (special.postDispatch){special.postDispatch.call(this,event)},handlers),handlers:function(event{:var sel,handleObj,matches,i,handlerQueue=[],delegateCount=handlers.delegateCount,cur=event.target;:// Find delegate handlers // Black-hole SVG <use> instance trees (#13180) // Avoid non-left-click bubbling in Firefox (#3861) if (delegateCount && cur.nodeType && (!event.button || event.type!=="click")){for (;:cur!=this;:cur=cur.parentNode || this){// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911,#8165,#11382,#11764) if (cur.nodeType===1 && (cur.disabled!==true || event.type!=="click")){matches=[];:for (i=0;:i < delegateCount;:i++){handleObj=handlers[ i ];:// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {;
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368,#11328) event.metaKey=!!event.metaKey;return fixHook.filter ? fixHook.filter(event,originalEvent):event},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(event,original){// Add which for key events if (event.which==null){event.which=original.charCode!=null ? original.charCode:original.keyCode},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(event,original){var body,eventDoc,doc,button=original.button,fromElement=original.fromElement;:// Calculate pageX/Y if missing and clientX/Y available if (event.pageX==null && original.clientX!=null){eventDoc=event.target.ownerDocument || document;:doc=eventDoc.documentElement;:body=eventDoc.body;:event.pageX=original.clientX+(doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);:event.pageY=original.clientY+(doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)}// Add relatedTarget,if necessary if (!event.relatedTarget && fromElement){event.relatedTarget=fromElement===event.target ? original.toElement:fromElement}// Add which for click:1===left;2===middle;3===right // Note:button is not normalized,so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links _default:function(event){return jQuery.nodeName(event.target,"a")},beforeunload:{postDispatch:function(event){// Even when returnValue equals to undefined Firefox will still show alert if (event.result!==undefined){event.originalEvent.returnValue=event.result},bubble),elem,event,simulate:function(type{:// Piggyback on a donor event to simulate a different one. // Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one this.timeStamp=src && src.timeStamp || jQuery.now();:// Mark it as fixed this[ jQuery.expando ]=true};// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html jQuery.Event.prototype={isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,preventDefault:function(){var e=this.originalEvent;:this.isDefaultPrevented=returnTrue;:if (!e){return}// If preventDefault exists,run it on the original event if (e.preventDefault){:e.preventDefault();// Support:IE // Otherwise set the returnValue property of the original event to false},stopPropagation:function(){:var e=this.originalEvent;:this.isPropagationStopped=returnTrue;:if (!e){return}// If stopPropagation exists,run it on the original event if (e.stopPropagation){e.stopPropagation()},stopImmediatePropagation:function(){:this.isImmediatePropagationStopped=returnTrue;:this.stopPropagation()};// Create mouseenter/leave events using mouseover/out and event-time checks jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout"});// IE submit delegation if (!jQuery.support.submitBubbles){jQuery.event.special.submit={setup:function(){// Only need this for delegated form submit events if (jQuery.nodeName(this,"form")){return false}// Lazy-add a submit handler when a descendant form may potentially be submitted jQuery.event.add(this,"click._submit keypress._submit",function(e){// Node name check avoids a VML-related crash in IE (#9807) var elem=e.target,form=jQuery.nodeName(elem,"input") || jQuery.nodeName(elem,"button") ? elem.form:undefined;:if (form &&!jQuery._data(form,"submitBubbles")){jQuery.event.add(form,"submit._submit",function(event){event._submit_bubble=true});// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur;trigger it on click // after a propertychange. Eat the blur-change in special.change.handle. // This still fires onchange a second time for check/radio after blur. if (this.type==="checkbox" || this.type==="radio"){jQuery.event.add(this,"propertychange._change",function(event){if (event.originalEvent.propertyName==="checked"){this._just_changed=true});jQuery.event.add(this,"click._change",function(event){if (this._just_changed &&!event.isTrigger){this._just_changed=false}// Delegated event;lazy-add a change handler on descendant inputs jQuery.event.add(this,"beforeactivate._change",function(e){:var elem=e.target;:if (rformElems.test(elem.nodeName) &&!jQuery._data(elem,"changeBubbles")){jQuery.event.add(elem,"change._change",function(event){if (this.parentNode &&!event.isSimulated &&!event.isTrigger){jQuery.event.simulate("change",this.parentNode,event,true)},handle:function(event){:var elem=event.target;:// Swallow native change events from checkbox/radio,we already triggered them above if (this!==elem || event.isSimulated || event.isTrigger || (elem.type!=="radio" && elem.type!=="checkbox")){return event.handleObj.handler.apply(this,arguments)}// Create "bubbling" focus and blur events if (!jQuery.support.focusinBubbles){jQuery.each({focus:"focusin",blur:"focusout"};jQuery.event.special[ fix ]={setup:function(){if (attaches++===0){document.addEventListener(orig,handler,true)}jQuery.fn.extend({on:function(types,selector,data,fn,one){var type,origFn;:// Types can be a map of types/handlers if (typeof types==="object"){// (types-Object,selector,data) if (typeof selector!=="string"){// (types-Object,data) data=data || selector;:selector=undefined}for (type in types){this.on(type,selector,data,types[ type ],one)}if (data==null && fn==null){:// (types,fn) fn=selector;:data=selector=undefined}else if (fn==null){:if (typeof selector==="string"){// (types,selector,fn) fn=data;:data=undefined}else if (!fn){return this}if (one===1){:origFn=fn;:fn=function(event){// Can use an empty set,since event contains the info jQuery().off(event);:return origFn.apply(this,arguments)},data,fn),one:function(types,selector{return this.on(types,selector,data,fn,1)},fn),off:function(types,selector{jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType+"."+handleObj.namespace:handleObj.origType,handleObj.selector,handleObj.handler);:return this}if (typeof types==="object"){// (types-object [,selector]) for (type in types){this.off(type,selector,types[ type ])}if (selector===false || typeof selector==="function"){:// (types [,fn]) fn=selector;:selector=undefined}if (fn===false){fn=returnFalse},data),trigger:function(type{return this.each(function(){jQuery.event.trigger(type,data,this)},data),triggerHandler:function(type{:var elem=this[0];:if (elem){return jQuery.event.trigger(type,data,elem,true)});var isSimple=/^.[^:#\[\.,// methods guaranteed to produce a unique set when starting from a unique set guaranteedUnique=,]*$/,rneedsContext=jQuery.expr.match.needsContext,rparentsprev=/^(?:parents|prev(?:Until|All))/{children:true,contents:true,next:true,prev:true};jQuery.fn.extend({find:function(selector){var i,ret=[],self=this,len=self.length;:if (typeof selector!=="string"){return this.pushStack(jQuery(selector).filter(function(){for (i=0;:i < len;:i++){if (jQuery.contains(self[ i ],this)){return true}for (i=0;i < len;i++){jQuery.find(selector,self[ i ],ret)},has:function(target){:var i,targets=jQuery(target,this),len=targets.length;:return this.filter(function(){for (i=0;:i < len;:i++){if (jQuery.contains(this,targets[i])){return true},not:function(selector){return this.pushStack(winnow(this,selector || [],true))},filter:function(selector){return this.pushStack(winnow(this,selector || [],false))},is:function(selector){:return!!winnow(this,// If this is a positional/relative selector,check membership in the returned set // so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle cur.nodeType===1 && jQuery.find.matchesSelector(cur,selectors))){cur=ret.push(cur);:break},// Determine the position of an element within // the matched set of elements index:function(elem){// No argument,return index in parent if (!elem){return (this[0] && this[0].parentNode) ? this.first().prevAll().length:-1}// index in selector if (typeof elem==="string"){return jQuery.inArray(this[0],jQuery(elem))},add:function(selector,context){var set=typeof selector==="string" ? jQuery(selector,context):jQuery.makeArray(selector && selector.nodeType ? [ selector ] :selector),all=jQuery.merge(this.get(),set);:return this.pushStack(jQuery.unique(all))},addBack:function(selector){return this.add(selector==null ? this.prevObject:this.prevObject.filter(selector))});function sibling(cur,dir){do{cur=cur[ dir ]}jQuery.each({parent:function(elem){var parent=elem.parentNode;return parent && parent.nodeType!==11 ? parent:null},parents:function(elem){return jQuery.dir(elem,"parentNode")},i,parentsUntil:function(elem,until){return jQuery.dir(elem,"parentNode",until)},next:function(elem){return sibling(elem,"nextSibling")},prev:function(elem){return sibling(elem,"previousSibling")},nextAll:function(elem){return jQuery.dir(elem,"nextSibling")},prevAll:function(elem){return jQuery.dir(elem,"previousSibling")},i,nextUntil:function(elem,until){return jQuery.dir(elem,"nextSibling",until)},i,prevUntil:function(elem,until){return jQuery.dir(elem,"previousSibling",until)},siblings:function(elem){,children:function(elem){return jQuery.sibling(elem.firstChild)},contents:function(elem){return jQuery.nodeName(elem,"iframe") ? elem.contentDocument || elem.contentWindow.document:jQuery.merge([],elem.childNodes)}if (selector && typeof selector==="string"){ret=jQuery.filter(selector,ret)}if (this.length>1){// Remove duplicates if (!guaranteedUnique[ name ]){ret=jQuery.unique(ret)}// Reverse order for parents* and prev-derivatives if (rparentsprev.test(name)){ret=ret.reverse()});jQuery.extend({filter:function(expr,elems,not){var elem=elems[ 0 ];:if (not){expr=":not("+expr+")"}expr) ? [ elem ] :[] :jQuery.find.matches(expr,function(elem),jQuery.grep(elems,return elems.length===1 && elem.nodeType===1 ? jQuery.find.matchesSelector(elem{return elem.nodeType===1},dir,dir:function(elem,until){:var matched=[],cur=elem[ dir ];:while (cur && cur.nodeType!==9 && (until===undefined || cur.nodeType!==1 ||!jQuery(cur).is(until))){if (cur.nodeType===1){matched.push(cur)},elem),sibling:function(n{:var r=[];:for (;:n;:n=n.nextSibling){if (n.nodeType===1 && n!==elem){r.push(n)});// Implement the identical functionality for filter and not function winnow(elements,not),qualifier{if (jQuery.isFunction(qualifier)){return jQuery.grep(elements,function(elem,i){return!!qualifier.call(elem,i,elem)!==not}if (qualifier.nodeType){return jQuery.grep(elements,function(elem){return (elem===qualifier)!==not}if (typeof qualifier==="string"){if (isSimple.test(qualifier)){return jQuery.filter(qualifier,elements,not)}function(elem),return jQuery.grep(elements{return (jQuery.inArray(elem,qualifier) >=0)!==not}function createSafeFragment(document){:var list=nodeNames.split("|"),safeFrag=document.createDocumentFragment();:if (safeFrag.createElement){while (list.length){safeFrag.createElement(list.pop())}// We have to close these tags to support XHTML (#13200) wrapMap=,// checked="checked" or checked rchecked=/checked\s*(?:[^=]|=\s.checked.)/i,"i"),manipulation_rcheckableType=/^(?:checkbox|radio)$/i,rcleanScript=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,rhtml=/<|&#?\w+;/,rinlinejQuery=/ jQuery\d+="(?:null|\d+)"/g,rleadingWhitespace=/^\s+/,rnoInnerhtml=/<(?:script|style|link)/i,rnoshimcache=new RegExp("<(?:"+nodeNames+")[\\s/>]",rscriptType=/^$|\/(?:java|ecma)script/i,rscriptTypeMasked=/^true\/(.*)/,rtagName=/<([\w:]+)/,rtbody=/<tbody/i,rxhtmlTag=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,var nodeNames="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|"+"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video"{option:[ 1,"<select multiple='multiple'>","</select>" ],legend:[ 1,"<fieldset>","</fieldset>" ],area:[ 1,"<map>","</map>" ],param:[ 1,"<object>","</object>" ],thead:[ 1,"<table>","</table>" ],tr:[ 2,"<table><tbody>","</tbody></table>" ],col:[ 2,"<table><tbody></tbody><colgroup>","</colgroup></table>" ],td:[ 3,"<table><tbody><tr>","</tr></tbody></table>" ],// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {,
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {;
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var
			// Snapshot the DOM in case .domManip sweeps something relevant into its fragment
			args = jQuery.map( this, function( elem ) {
				return [ elem.nextSibling, elem.parentNode ];
			}),
			i = 0;

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			var next = args[ i++ ],
				parent = args[ i++ ];

			if ( parent ) {
				// Don't use the snapshot next if it has moved (#13810) if (next && next.parentNode!==parent){next=this.nextSibling},detach:function(selector){return this.remove(selector,true)},allowIntersection),callback,domManip:function(args{:// Flatten any nested arrays args=core_concat.apply([],args);:var first,node,hasScripts,scripts,doc,fragment,i=0,l=this.length,set=this,iNoClone=l - 1,value=args[0],isFunction=jQuery.isFunction(value);:// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback, allowIntersection );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Hope ajax is available...
								jQuery._evalUrl( node.src );
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {;

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set dest.defaultChecked=dest.checked=src.checked;:// IE6-7 get confused and end up setting the value of a cloned // checkbox/radio button to an empty string instead of "on" if (dest.value!==src.value){dest.value=src.value}else if (nodeName==="option"){:dest.defaultSelected=dest.selected=src.defaultSelected;:// IE6-8 fails to set the defaultValue to the correct value when // cloning other types of input fields}else if (nodeName==="input" || nodeName==="textarea"){dest.defaultValue=src.defaultValue}jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(name,original){i++){elems=i===last ? this:this.clone(true);:jQuery(insert[i])[ original ](elems);:// Modern browsers can apply jQuery collections as arrays,but oldIE needs a .get() core_push.apply(ret,elems.get())});function getAll(context,tag){var elems,elem,i=0,found=typeof context.getElementsByTagName!==core_strundefined ? context.getElementsByTagName(tag || "*"):typeof context.querySelectorAll!==core_strundefined ? context.querySelectorAll(tag || "*") :undefined;:if (!found){for (found=[],elems=context.childNodes || context;:(elem=elems[i])!=null;:i++){if (!tag || jQuery.nodeName(elem,tag)){found.push(elem)}// Used in buildFragment,fixes the defaultChecked property function fixDefaultChecked(elem){if (manipulation_rcheckableType.test(elem.type)){elem.defaultChecked=elem.checked}jQuery.extend({clone:function(elem,dataAndEvents,deepDataAndEvents){var destElements,node,clone,i,srcElements,inPage=jQuery.contains(elem.ownerDocument,elem);:if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) ||!rnoshimcache.test("<"+elem.nodeName+">")){clone=elem.cloneNode(true);:// IE<=8 does not properly clone detached,unknown element nodes}if ((!jQuery.support.noCloneEvent ||!jQuery.support.noCloneChecked) && (elem.nodeType===1 || elem.nodeType===11) &&!jQuery.isXMLDoc(elem)){// We eschew Sizzle here for performance reasons:http://jsperf.com/getall-vs-sizzle/2 destElements=getAll(clone);:srcElements=getAll(elem);:// Fix all IE cloning issues for (i=0;:(node=srcElements[i])!=null;:++i){// Ensure that the destination node is not null;:Fixes #9587 if (destElements[i]){fixCloneNodeIssues(node,destElements[i])}// Copy the events from the original to the clone if (dataAndEvents){:if (deepDataAndEvents){srcElements=srcElements || getAll(elem);:destElements=destElements || getAll(clone);:for (i=0;:(node=srcElements[i])!=null;:i++){cloneCopyEvent(node,destElements[i])}// Preserve script evaluation history destElements=getAll(clone,"script");if (destElements.length>0){setGlobalEval(destElements,!inPage && getAll(elem,"script"))},buildFragment:function(elems,context,scripts,selection){if (elem || elem===0){// Add nodes directly if (jQuery.type(elem)==="object"){jQuery.merge(nodes,elem.nodeType ? [ elem ]:elem);:// Convert non-html into a text node}else if (!rhtml.test(elem)){:nodes.push(context.createTextNode(elem));:// Convert html into DOM nodes}// Manually add leading whitespace removed by IE if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)){nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]))}// Remove cache only if it was not already removed by jQuery.event.remove if (cache[ id ]){:delete cache[ id ];:// IE does not allow us to delete expando properties from nodes,// nor does it have a removeAttribute function on Document nodes;:// we must handle all of these cases if (deleteExpando){delete elem[ internalKey ]}else if (typeof elem.removeAttribute!==core_strundefined){elem.removeAttribute(internalKey)},_evalUrl:function(url){return jQuery.ajax({url:url,type:"GET",dataType:"script",async:false,global:false,"throws":true});jQuery.fn.extend({wrapAll:function(html){if (jQuery.isFunction(html)){return this.each(function(i){jQuery(this).wrapAll(html.call(this,i))}if (this[0]){:// The elements to wrap the target around var wrap=jQuery(html,this[0].ownerDocument).eq(0).clone(true);:if (this[0].parentNode){wrap.insertBefore(this[0])}wrap.map(function(){:var elem=this;:while (elem.firstChild && elem.firstChild.nodeType===1){elem=elem.firstChild},wrapInner:function(html){if (jQuery.isFunction(html)){return this.each(function(i){jQuery(this).wrapInner(html.call(this,i))},wrap:function(html){:var isFunction=jQuery.isFunction(html);return this.each(function(i){jQuery(this).wrapAll(isFunction ? html.call(this,i):html)},unwrap:function(){return this.parent().each(function(){if (!jQuery.nodeName(this,"body")){jQuery(this).replaceWith(this.childNodes)});var iframe,// swappable if display is none or starts with table except "table","table-cell","i"),curCSS,elemdisplay=,getStyles,or "table-caption" // see here for display values:https://developer.mozilla.org/en-US/docs/CSS/display rdisplayswap=/^(none|table(?!-c[ea]).+)/,ralpha=/alpha\([^)]*\)/i,rmargin=/^margin/,rnumnonpx=new RegExp("^("+core_pnum+")(?!px)[a-z%]+$",rnumsplit=new RegExp("^("+core_pnum+")(.*)$",ropacity=/opacity\s*=\s*([^)]*)/,rposition=/^(top|right|bottom|left)$/,rrelNum=new RegExp("^([+-])=("+core_pnum+")"{BODY:"block"},cssShow={position:"absolute",visibility:"hidden",display:"block"},cssNormalTransform={letterSpacing:0,fontWeight:400},"Right","Bottom","Left" ],"O","Moz","ms" ];// return a css property mapped to a potentially vendor prefixed property function vendorPropName(style,cssExpand=[ "Top",cssPrefixes=[ "Webkit",name){// shortcut for names that are not vendor prefixed if (name in style){return name}// check for vendor prefixed names var capName=name.charAt(0).toUpperCase()+name.slice(1),i=cssPrefixes.length;while (i--),origName=name{:name=cssPrefixes[ i ]+capName;:if (name in style){return name}el),function isHidden(elem{:// isHidden might be called from jQuery#filter function;:// in that case,element will be second argument elem=el || elem;:return jQuery.css(elem,"display")==="none" ||!jQuery.contains(elem.ownerDocument,elem)}function showHide(elements,show){:var display,elem,hidden,values=[],index=0,length=elements.length;:for (;:index < length;:index++){elem=elements[ index ];:if (!elem.style){continue}"olddisplay");display=elem.style.display;if (show),values[ index ]=jQuery._data(elem{// Reset the inline display of this element to learn if it is // being hidden by cascaded rules or not if (!values[ index ] && display==="none"){elem.style.display=""}// Set elements which have been overridden with display:none // in a stylesheet to whatever the default browser style is // for such an element if (elem.style.display==="" && isHidden(elem)){values[ index ]=jQuery._data(elem,"olddisplay",css_defaultDisplay(elem.nodeName))}// Set the display of most of the elements in a second loop // to avoid the constant reflow for (index=0;index < length;index++){:elem=elements[ index ];:if (!elem.style){continue}if (!show || elem.style.display==="none" || elem.style.display===""){elem.style.display=show ? values[ index ] || "":"none"}jQuery.fn.extend({css:function(name,value){return jQuery.access(this,function(elem,name,value){,i=0;if (jQuery.isArray(name)){:styles=getStyles(elem);:len=name.length;:for (;:i < len;:i++){map[ name[ i ] ]=jQuery.css(elem,name[ i ],false,styles)},show:function(){return showHide(this,true)},hide:function(){return showHide(this)},toggle:function(state){if (typeof state==="boolean"){return state ? this.show():this.hide()});jQuery.extend({// Add in style property hooks for overriding the default // behavior of getting and setting a style property cssHooks:{opacity:{get:function(elem,computed){if (computed){// We should always get a number back from opacity var ret=curCSS(elem,"opacity");return ret==="" ? "1":ret},// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes if (!elem || elem.nodeType===3 || elem.nodeType===8 ||!elem.style){return}// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value if (value!==undefined){:type=typeof value;:// convert relative number strings (+=or -=) to relative numbers. #7345 if (type==="string" && (ret=rrelNum.exec(value))){value=(ret[1]+1) * ret[2]+parseFloat(jQuery.css(elem,name));:// Fixes bug #9237 type="number"}// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name name=jQuery.cssProps[ origName ] || (jQuery.cssProps[ origName ]=vendorPropName(elem.style,origName));// gets hook for the prefixed version // followed by the unprefixed version hooks=jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];// If a hook was provided get the computed value from there if (hooks && "get" in hooks){val=hooks.get(elem,true,extra)}// Otherwise,if a way to get the computed value exists,use that if (val===undefined){val=curCSS(elem,name,styles)}//convert "normal" to computed value if (val==="normal" && name in cssNormalTransform){val=cssNormalTransform[ name ]}// Return,converting to number if forced or a qualifier was provided and val looks numeric if (extra==="" || extra){:num=parseFloat(val);return extra===true || jQuery.isNumeric(num) ? num || 0:val});// NOTE:we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto if (ret==null && style && style[ name ]){ret=style[ name ]}// From the awesome hack by Dean Edwards // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291 // If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem if (rnumnonpx.test(ret) &&!rposition.test(name)){:// Remember the original values left=style.left;:rs=elem.runtimeStyle;:rsLeft=rs && rs.left;:// Put in the new values to get a computed value out if (rsLeft){rs.left=elem.currentStyle.left}style.left=name==="fontSize" ? "1em":ret;ret=style.pixelLeft+"px";// Revert the changed values style.left=left;if (rsLeft){rs.left=rsLeft}function setPositiveNumber(elem,subtract),value{:var matches=rnumsplit.exec(value);return matches ? // Guard against undefined "subtract",e.g.,when used as in cssHooks Math.max(0,matches[ 1 ] - (subtract || 0))+(matches[ 2 ] || "px"):value}extra,function augmentWidthOrHeight(elem,isBorderBox,name,styles){var i=extra===(isBorderBox ? "border":"content") ? // If we already have the right measurement,avoid augmentation 4 :// Otherwise initialize for horizontal or vertical properties name==="width" ? 1 :0,val=0;:for (;:i < 4;:i +=2){// both box models exclude margin,so add it if we want it if (extra==="margin"){val +=jQuery.css(elem,extra+cssExpand[ i ],true,styles)}if (isBorderBox){// border-box includes padding,so remove it if we want content if (extra==="content"){val -=jQuery.css(elem,"padding"+cssExpand[ i ],true,styles)}// Called ONLY from within css_defaultDisplay function actualDisplay(name,doc){:var elem=jQuery(doc.createElement(name)).appendTo(doc.body),display=jQuery.css(elem[0],"display");:elem.remove();:return display}"width" ],function(i,jQuery.each([ "height",name){jQuery.cssHooks[ name ]={get:function(elem,computed,extra){if (computed){// certain elements can have dimension info if we invisibly show them // however,it must have a current display style that would benefit from this return elem.offsetWidth===0 && rdisplayswap.test(jQuery.css(elem,"display")) ? jQuery.swap(elem,cssShow,function(){return getWidthOrHeight(elem,name,extra)},extra),set:function(elem,value{:var styles=extra && getStyles(elem);return setPositiveNumber(elem,value,extra ? augmentWidthOrHeight(elem,name,extra,jQuery.support.boxSizing && jQuery.css(elem,"boxSizing",false,styles)==="border-box",styles):0)});if (!jQuery.support.opacity){jQuery.cssHooks.opacity={get:function(elem,computed){// IE uses filters for opacity return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter:elem.style.filter) || "") ? (0.01 * parseFloat(RegExp.$1))+"" :computed ? "1" :""},set:function(elem,value){var style=elem.style,currentStyle=elem.currentStyle,opacity=jQuery.isNumeric(value) ? "alpha(opacity="+value * 100+")":"",filter=currentStyle && currentStyle.filter || style.filter || "";:// IE has trouble with opacity if it does not have layout // Force it by setting the zoom level style.zoom=1;:// if setting opacity to 1,and no other filters exist - attempt to remove filter attribute #6652 // if value==="",then remove inline opacity #12685 if ((value >=1 || value==="") && jQuery.trim(filter.replace(ralpha,""))==="" && style.removeAttribute){// Setting style.filter to null,"" & " " still leave "filter:" in the cssText // if "filter:" is present at all,clearType is disabled,we want to avoid this // style.removeAttribute is IE Only,but so apparently is this code path... style.removeAttribute("filter");:// if there is no filter style applied in a css rule or unset inline opacity,we are done if (value==="" || currentStyle &&!currentStyle.filter){return}// These hooks cannot be added until DOM ready because the support test // for it is not run until after DOM ready jQuery(function(){if (!jQuery.support.reliableMarginRight){jQuery.cssHooks.marginRight={get:function(elem,computed){if (computed){// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right // Work around by temporarily setting element display to inline-block return jQuery.swap(elem,{"display":"inline-block"}// Webkit bug:https://bugs.webkit.org/show_bug.cgi?id=29084 // getComputedStyle returns percent when specified for top/left/bottom/right // rather than make the css module depend on the offset module,we just check for it here if (!jQuery.support.pixelPosition && jQuery.fn.position){jQuery.each([ "top","left" ],function(i,prop){jQuery.cssHooks[ prop ]={get:function(elem,computed){if (computed){computed=curCSS(elem,prop);// if curCSS returns percentage,fallback to offset return rnumnonpx.test(computed) ? jQuery(elem).position()[ prop ]+"px":computed});if (jQuery.expr && jQuery.expr.filters){jQuery.expr.filters.hidden=function(elem){// Support:Opera <=12.12 // Opera reports offsetWidths and offsetHeights less than zero on some elements return elem.offsetWidth <=0 && elem.offsetHeight <=0 || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css(elem,"display"))==="none")};jQuery.expr.filters.visible=function(elem){return!jQuery.expr.filters.hidden(elem)}// These hooks are used by animate to expand properties jQuery.each({margin:"",padding:"",border:"Width"},function(prefix,suffix){jQuery.cssHooks[ prefix+suffix ]={expand:function(value){,// assumes a single number if not a string parts=typeof value==="string" ? value.split(" "):[ value ];for (;i < 4;i++){expanded[ prefix+cssExpand[ i ]+suffix ]=parts[ i ] || parts[ i - 2 ] || parts[ 0 ]};if (!rmargin.test(prefix)){jQuery.cssHooks[ prefix+suffix ].set=setPositiveNumber});var r20=/%20/g,rCRLF=/\r?\n/g,rbracket=/\[\]$/,rsubmittable=/^(?:input|select|textarea|keygen)/i;jQuery.fn.extend(,rsubmitterTypes=/^(?:submit|button|image|reset|file)$/i{serialize:function(){return jQuery.param(this.serializeArray())},serializeArray:function(){:return this.map(function(){// Can add propHook for "elements" to filter or add form elements var elements=jQuery.prop(this,"elements");return elements ? jQuery.makeArray(elements):this}) .filter(function(){:var type=this.type;:// Use .is(":disabled") so that fieldset[disabled] works return this.name &&!jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) &&!rsubmitterTypes.test(type) && (this.checked ||!manipulation_rcheckableType.test(type))}) .map(function(i,elem){:var val=jQuery(this).val();return val==null ? null :jQuery.isArray(val) ? jQuery.map(val,function(val){return{name:elem.name,value:val.replace(rCRLF,"\r\n")}) :{name:elem.name,value:val.replace(rCRLF,"\r\n")});//Serialize an array of form elements or a set of //key/values into a query string jQuery.param=function(a,traditional){var prefix,s=[],add=function(key,value){// If value is a function,invoke it and return its value value=jQuery.isFunction(value) ? value():(value==null ? "" :value);:s[ s.length ]=encodeURIComponent(key)+"="+encodeURIComponent(value)};// Set traditional to true for jQuery <=1.3.2 behavior. if (traditional===undefined){traditional=jQuery.ajaxSettings && jQuery.ajaxSettings.traditional}// If an array was passed in,assume that it is an array of form elements. if (jQuery.isArray(a) || (a.jquery &&!jQuery.isPlainObject(a))){// Serialize the form elements jQuery.each(a,function(){add(this.name,this.value)};function buildParams(prefix,add),obj,traditional{:var name;:if (jQuery.isArray(obj)){// Serialize array item. jQuery.each(obj,function(i,v){if (traditional || rbracket.test(prefix)){// Treat each array item as a scalar. add(prefix,v)}else if (!traditional && jQuery.type(obj)==="object"){// Serialize object item. for (name in obj){buildParams(prefix+"["+name+"]",obj[ name ],traditional,add)}function(i,jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick "+"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "+"change select submit keydown keypress keyup error contextmenu").split(" "),name){// Handle event binding jQuery.fn[ name ]=function(data,fn){return arguments.length>0 ? this.on(name,null,data,fn):this.trigger(name)});jQuery.fn.extend({hover:function(fnOver,fnOut){return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)},bind:function(types,data,fn){return this.on(types,null,data,fn)},fn),unbind:function(types{return this.off(types,null,fn)},data,delegate:function(selector,fn),types{return this.on(types,selector,data,fn)},fn),types,undelegate:function(selector{// (namespace) or (selector,types [,fn]) return arguments.length===1 ? this.off(selector,"**"):this.off(types,selector || "**",fn)},// Avoid comment-prolog char sequence (#10098);must appease lint and evade compression allTypes="*/".concat("*");// #8138,IE may throw an exception when accessing // a field from window.location if document.domain has been set try{ajaxLocation=location.href}// Segment location into parts ajaxLocParts=rurl.exec(ajaxLocation.toLowerCase()) || [];// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport function addToPrefiltersOrTransports(structure){:// dataTypeExpression is optional and defaults to "*" return function(dataTypeExpression,func){if (typeof dataTypeExpression!=="string"){func=dataTypeExpression;:dataTypeExpression="*"}dataTypes=dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];if (jQuery.isFunction(func)),i=0,var dataType{:// For each dataType in the dataTypeExpression while ((dataType=dataTypes[i++])){// Prepend if requested if (dataType[0]==="+"){dataType=dataType.slice(1) || "*";:(structure[ dataType ]=structure[ dataType ] || []).unshift(func);:// Otherwise append}// Base inspection function for prefilters and transports function inspectPrefiltersOrTransports(structure,jqXHR),options,originalOptions{,seekingTransport=(structure===transports);function inspect(dataType){:var selected;:inspected[ dataType ]=true;:jQuery.each(structure[ dataType ] || [],function(_,prefilterOrFactory){var dataTypeOrTransport=prefilterOrFactory(options,originalOptions,jqXHR);:if(typeof dataTypeOrTransport==="string" &&!seekingTransport &&!inspected[ dataTypeOrTransport ]){options.dataTypes.unshift(dataTypeOrTransport);:inspect(dataTypeOrTransport);:return false}else if (seekingTransport){return!(selected=dataTypeOrTransport)}// A special extend for ajax options // that takes "flat" options (not to be deep extended) // Fixes #9887 function ajaxExtend(target,src){;for (key in src){if (src[ key ]!==undefined){if (deep){jQuery.extend(true,target,deep)}callback),jQuery.fn.load=function(url,params{if (typeof url!=="string" && _load){return _load.apply(this,arguments)}off=url.indexOf(" ");if (off >=0),response,self=this,type,var selector{:selector=url.slice(off,url.length);:url=url.slice(0,off)}else if (params && typeof params==="object"){type="POST"}// If we have elements to modify,make the request if (self.length>0){jQuery.ajax({url:url,// if "type" variable is undefined,then "GET" method will be used type:type,dataType:"html",data:params}).done(function(responseText){:// Save response for use in complete callback response=arguments;self.html(selector ? // If a selector was specified,locate the right elements in a dummy div // Exclude scripts to avoid IE 'Permission Denied' errors jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector):// Otherwise use the full result responseText)}).complete(callback && function(jqXHR,status){self.each(callback,response || [ jqXHR.responseText,status,jqXHR ])};// Attach a bunch of functions for handling common AJAX events jQuery.each([ "ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend" ],function(i,type){jQuery.fn[ type ]=function(fn){return this.on(type,fn)});jQuery.extend({,ajaxSettings:{url:ajaxLocation,type:"GET",isLocal:rlocalProtocol.test(ajaxLocParts[ 1 ]),global:true,processData:true,async:true,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":allTypes,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},// Data converters // Keys separate source (or catchall "*") and destination types with a single space converters:{// Convert anything to text "* text":String,// Text to html (true=no transformation) "text html":true,// Evaluate text as a json expression "text json":jQuery.parseJSON,// Parse text as xml "text xml":jQuery.parseXML},// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be // deep extended (see ajaxExtend) flatOptions:{url:true,context:true},// Creates a full fledged settings object into target // with both ajaxSettings and settings fields. // If target is omitted,settings),writes into ajaxSettings. ajaxSetup:function(target{return settings ? // Building a settings object ajaxExtend(ajaxExtend(target,jQuery.ajaxSettings),settings):// Extending ajaxSettings ajaxExtend(jQuery.ajaxSettings,target)},// Main method ajax:function(url,ajaxPrefilter:addToPrefiltersOrTransports(prefilters),ajaxTransport:addToPrefiltersOrTransports(transports),options){:// If url is an object,simulate pre-1.5 signature if (typeof url==="object"){options=url;:url=undefined},// Default abort message strAbort="canceled",// Fake xhr jqXHR=,// The jqXHR state state=0{readyState:0,// Builds headers hashtable if needed getResponseHeader:function(key){var match;:if (state===2){if (!responseHeaders){;while ((match=rheaders.exec(responseHeadersString))){responseHeaders[ match[1].toLowerCase() ]=match[ 2 ]},// Raw string getAllResponseHeaders:function(){return state===2 ? responseHeadersString:null},// Caches the header setRequestHeader:function(name,value){:var lname=name.toLowerCase();:if (!state){name=requestHeadersNames[ lname ]=requestHeadersNames[ lname ] || name;:requestHeaders[ name ]=value},// Overrides response content-type header overrideMimeType:function(type){if (!state){s.mimeType=type},// Status-dependent callbacks statusCode:function(map){:var code;:if (map){if (state < 2){for (code in map){// Lazy-add the new callback in a way that preserves old ones statusCode[ code ]=[ statusCode[ code ],map[ code ] ]},// Cancel the request abort:function(statusText){:var finalText=statusText || strAbort;:if (transport){transport.abort(finalText)};// Attach deferreds deferred.promise(jqXHR).complete=completeDeferred.add;jqXHR.success=jqXHR.done;jqXHR.error=jqXHR.fail;// Remove hash character (#7531:and string promotion) // Add protocol if not provided (#5866:IE7 issue with protocol-less urls) // Handle falsy url in the settings object (#10093:consistency with old signature) // We also use the url parameter if available s.url=((url || s.url || ajaxLocation)+"").replace(rhash,"").replace(rprotocol,ajaxLocParts[ 1 ]+"//");// Alias method option to type as per ticket #12004 s.type=options.method || options.type || s.method || s.type;// Extract dataTypes list s.dataTypes=jQuery.trim(s.dataType || "*").toLowerCase().match(core_rnotwhite) || [""];// A cross-domain request is in order when we have a protocol:host:port mismatch if (s.crossDomain==null){:parts=rurl.exec(s.url.toLowerCase());s.crossDomain=!!(parts && (parts[ 1 ]!==ajaxLocParts[ 1 ] || parts[ 2 ]!==ajaxLocParts[ 2 ] || (parts[ 3 ] || (parts[ 1 ]==="http:" ? "80":"443"))!==(ajaxLocParts[ 3 ] || (ajaxLocParts[ 1 ]==="http:" ? "80" :"443"))))}// Convert data if not already a string if (s.data && s.processData && typeof s.data!=="string"){s.data=jQuery.param(s.data,s.traditional)}// Apply prefilters inspectPrefiltersOrTransports(prefilters,jqXHR);// If request was aborted inside a prefilter,options,s,stop there if (state===2){return jqXHR}// We can fire global events as of now if asked to fireGlobals=s.global;// Watch for a new set of requests if (fireGlobals && jQuery.active++===0){jQuery.event.trigger("ajaxStart")}// Add anti-cache in url if needed if (s.cache===false){s.url=rts.test(cacheURL) ? // If there is already a '_' parameter,set its value cacheURL.replace(rts,"$1_="+ajax_nonce++):// Otherwise add one to the end cacheURL+(ajax_rquery.test(cacheURL) ? "&" :"?")+"_="+ajax_nonce++}// Set the If-Modified-Since and/or If-None-Match header,if in ifModified mode. if (s.ifModified){if (jQuery.lastModified[ cacheURL ]){jqXHR.setRequestHeader("If-Modified-Since",jQuery.lastModified[ cacheURL ])}if (jQuery.etag[ cacheURL ]){jqXHR.setRequestHeader("If-None-Match",jQuery.etag[ cacheURL ])}// Set the correct header,if data is being sent if (s.data && s.hasContent && s.contentType!==false || options.contentType){jqXHR.setRequestHeader("Content-Type",s.contentType)}// Set the Accepts header for the server,depending on the dataType jqXHR.setRequestHeader("Accept",s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ? s.accepts[ s.dataTypes[0] ]+(s.dataTypes[ 0 ]!=="*" ? ", "+allTypes+"; q=0.01":"") :s.accepts[ "*" ]);// Check for headers option for (i in s.headers){jqXHR.setRequestHeader(i,s.headers[ i ])}// Allow custom headers/mimetypes and early abort if (s.beforeSend && (s.beforeSend.call(callbackContext,jqXHR,s)===false || state===2)){// Abort if not done already and return return jqXHR.abort()}// aborting is no longer a cancellation strAbort="abort";// Install callbacks on deferreds for (i in{success:1,error:1,complete:1}// Get transport transport=inspectPrefiltersOrTransports(transports,jqXHR);// If no transport,options,s,we auto-abort if (!transport){done(-1,"No Transport")}// Timeout if (s.async && s.timeout>0){timeoutTimer=setTimeout(function(){jqXHR.abort("timeout")}// Callback for when everything is done function done(status,headers),nativeStatusText,responses{:var isSuccess,success,error,response,modified,statusText=nativeStatusText;:// Called once if (state===2){return}// State is "done" now state=2;// Clear timeout if it exists if (timeoutTimer){clearTimeout(timeoutTimer)}// Dereference transport for early garbage collection // (no matter how long the jqXHR object will be used) transport=undefined;// Cache response headers responseHeadersString=headers || "";// Set readyState jqXHR.readyState=status>0 ? 4:0;// Determine if successful isSuccess=status >=200 && status < 300 || status===304;// Get response data if (responses){response=ajaxHandleResponses(s,jqXHR,responses)}// Convert no matter what (that way responseXXX fields are always set) response=ajaxConvert(s,handle type chaining if (isSuccess),isSuccess);// If successful,jqXHR,response{:// Set the If-Modified-Since and/or If-None-Match header,if in ifModified mode. if (s.ifModified){modified=jqXHR.getResponseHeader("Last-Modified");:if (modified){jQuery.lastModified[ cacheURL ]=modified}modified=jqXHR.getResponseHeader("etag");if (modified){jQuery.etag[ cacheURL ]=modified}// if no content if (status===204 || s.type==="HEAD"){:statusText="nocontent";:// if not modified}else if (status===304){:statusText="notmodified";:// If we have data,let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type if (ct){for (type in contents){if (contents[ type ] && contents[ type ].test(ct)){dataTypes.unshift(type);:break}// Check to see if we have a response for the expected dataType if (dataTypes[ 0 ] in responses){finalDataType=dataTypes[ 0 ]}if (!firstDataType){firstDataType=type}// If we found a dataType // We add the dataType to the list if needed // and return the corresponding response if (finalDataType){if (finalDataType!==dataTypes[ 0 ]){dataTypes.unshift(finalDataType)}function ajaxConvert(s,isSuccess),jqXHR,response{,// Work with a copy of dataTypes in case we need to modify it for conversion dataTypes=s.dataTypes.slice();// Create converters map with lowercased keys if (dataTypes[ 1 ]){for (conv in s.converters){converters[ conv.toLowerCase() ]=s.converters[ conv ]}current=dataTypes.shift();// Convert to each sequential dataType while (current){if (s.responseFields[ current ]){jqXHR[ s.responseFields[ current ] ]=response}// Apply the dataFilter if provided if (!prev && isSuccess && s.dataFilter){response=s.dataFilter(response,s.dataType)}prev=current;current=dataTypes.shift();if (current){// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global jQuery.ajaxPrefilter("script",function(s){if (s.cache===undefined){s.cache=false}if (s.crossDomain){:s.type="GET";:s.global=false});// Bind script tag hack transport jQuery.ajaxTransport("script",function(s){return{send:function(_,callback){script=document.createElement("script");:script.async=true;:if (s.scriptCharset){script.charset=s.scriptCharset}isAbort),script.src=s.url;// Attach handlers for all browsers script.onload=script.onreadystatechange=function(_{:if (isAbort ||!script.readyState || /loaded|complete/.test(script.readyState)){// Handle memory leak in IE script.onload=script.onreadystatechange=null;:// Remove the script if (script.parentNode){script.parentNode.removeChild(script)}// Dereference the script script=null;// Callback if not abort if (!isAbort){callback(200,"success")});var oldCallbacks=[],rjsonp=/(=)\?(?=&|$)|\?\?/;// Default jsonp settings jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var callback=oldCallbacks.pop() || (jQuery.expando+"_"+(ajax_nonce++));:this[ callback ]=true;:return callback});// Detect,function(s,jqXHR),normalize options and install callbacks for jsonp requests jQuery.ajaxPrefilter("json jsonp",originalSettings{var callbackName,overwritten,responseContainer,jsonProp=s.jsonp!==false && (rjsonp.test(s.url) ? "url":typeof s.data==="string" &&!(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");// Handle iff the expected data type is "jsonp" or we have a parameter to set if (jsonProp || s.dataTypes[ 0 ]==="jsonp"){// Get callback name,remembering preexisting value associated with it callbackName=s.jsonpCallback=jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback():s.jsonpCallback;:// Insert callback into url or form data if (jsonProp){s[ jsonProp ]=s[ jsonProp ].replace(rjsonp,"$1"+callbackName)}else if (s.jsonp!==false){s.url +=(ajax_rquery.test(s.url) ? "&":"?")+s.jsonp+"="+callbackName}// Use data converter to retrieve json after script execution s.converters["script json"]=function(){if (!responseContainer){jQuery.error(callbackName+" was not called")};// force json dataType s.dataTypes[ 0 ]="json";// Install callback overwritten=window[ callbackName ];window[ callbackName ]=function(){responseContainer=arguments};// Clean-up function (fires after converters) jqXHR.always(function(){:// Restore preexisting value window[ callbackName ]=overwritten;:// Save back as free if (s[ callbackName ]){// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload xhrOnUnloadAbort=window.ActiveXObject && function(){// Abort all pending requests var key;:for (key in xhrCallbacks){xhrCallbacks[ key ](undefined,true)};// Functions to create xhrs function createStandardXHR(){try{return new window.XMLHttpRequest()}function createActiveXHR(){try{return new window.ActiveXObject("Microsoft.XMLHTTP")}// Create the request object // (This is still attached to ajaxSettings for backward compatibility) jQuery.ajaxSettings.xhr=window.ActiveXObject ? function(){return!this.isLocal && createStandardXHR() || createActiveXHR()}:// For all other browsers,use the standard XMLHttpRequest object createStandardXHR;// Determine support properties xhrSupported=jQuery.ajaxSettings.xhr();jQuery.support.cors=!!xhrSupported && ("withCredentials" in xhrSupported);xhrSupported=jQuery.support.ajax=!!xhrSupported;// Create transport if the browser can provide an xhr if (xhrSupported){return{send:function(headers,complete){// Get a new xhr var handle,i,xhr=s.xhr();:// Open the socket // Passing null username,generates a login popup on Opera (#2865) if (s.username){xhr.open(s.type,s.url,s.async,s.username,s.password)}// Apply custom fields if provided if (s.xhrFields){for (i in s.xhrFields){xhr[ i ]=s.xhrFields[ i ]}// Override mime type if needed if (s.mimeType && xhr.overrideMimeType){xhr.overrideMimeType(s.mimeType)}// X-Requested-With header // For cross-domain requests,seeing as conditions for a preflight are // akin to a jigsaw puzzle,we simply never set it to be sure. // (it can always be set on a per-request basis or even using ajaxSetup) // For same-domain requests,won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort if (isAbort){// Abort it manually if needed if (xhr.readyState!==4){xhr.abort()};status=xhr.status;responseHeaders=xhr.getAllResponseHeaders();// When requesting binary data,IE6-9 will throw an exception // on any attempt to access responseText (#11426) if (typeof xhr.responseText==="string"){responses.text=xhr.responseText}// Firefox throws an exception when accessing // statusText for faulty cross-domain requests try{statusText=xhr.statusText}// Filter status for non standard behaviors // If the request is local and we have data:assume a success // (success with no data won't get notified, that's the best we // can do given current implementations) if (!status && s.isLocal &&!s.crossDomain){status=responses.text ? 200:404;// IE - #1450:sometimes returns 1223 when it should be 204}else if (status===1223){status=204}catch(firefoxAccessException){if (!isAbort){complete(-1,firefoxAccessException)}// Call complete if needed if (responses){complete(status,statusText,responses,responseHeaders)};if (!s.async){// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been // retrieved directly we need to fire the callback setTimeout(callback)}"i"),animationPrefilters=[ defaultPrefilter ],rfxnum=new RegExp("^(?:([+-])=|)("+core_pnum+")([a-z%]*)$",rfxtypes=/^(?:toggle|show|hide)$/,rrun=/queueHooks$/,timerId,tweeners=,var fxNow{"*":[function(prop,value){var tween=this.createTween(prop,value),target=tween.cur(),parts=rfxnum.exec(value),unit=parts && parts[ 3 ] || (jQuery.cssNumber[ prop ] ? "":"px"),// Starting value computation is required for potential unit mismatches start=(jQuery.cssNumber[ prop ] || unit!=="px" && +target) && rfxnum.exec(jQuery.css(tween.elem,prop)),scale=1,maxIterations=20;:if (start && start[ 3 ]!==unit){// Trust units reported by jQuery.css unit=unit || start[ 3 ];:// Make sure we update the tween properties later on parts=parts || [];:// Iteratively approximate from a nonzero starting point start=+target || 1;:do{// If previous iteration zeroed out,double until we get *something* // Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough}// Update tween properties if (parts){:start=tween.start=+start || +target || 0;:tween.unit=unit;:// If a +=/-=token was provided,we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property return tween}function Animation(elem,options),properties{:var result,stopped,index=0,length=animationPrefilters.length,deferred=jQuery.Deferred().always(function(){// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - (0.5 || 0) (#12497) temp=remaining / animation.duration || 0,percent=1 - temp,index=0,length=animation.tweens.length;:for (;:index < length;:index++){animation.tweens[ index ].run(percent)}[ animation,deferred.notifyWith(elem,percent,remaining ]);if (percent < 1 && length){return remaining},animation=deferred.promise({,opts:jQuery.extend(true,properties){,createTween:function(prop,duration:options.duration,end),options),originalOptions:options,originalProperties:properties,startTime:fxNow || createFxNow(),tweens:[]{:var tween=jQuery.Tween(elem,animation.opts,prop,end,animation.opts.specialEasing[ prop ] || animation.opts.easing);:animation.tweens.push(tween);:return tween},stop:function(gotoEnd){var index=0,// if we are going to the end,we want to run all the tweens // otherwise we skip this part length=gotoEnd ? animation.tweens.length:0;:if (stopped){return this}stopped=true;for (;index < length;index++){animation.tweens[ index ].run(1)}// resolve when we played the last frame // otherwise,reject if (gotoEnd){deferred.resolveWith(elem,[ animation,gotoEnd ])}),animation.opts.specialEasing);for (;index < length;index++),props=animation.props;propFilter(props{:result=animationPrefilters[ index ].call(animation,elem,props,animation.opts);:if (result){return result}animation);if (jQuery.isFunction(animation.opts.start)),createTween,jQuery.map(props{animation.opts.start.call(elem,animation)},jQuery.fx.timer(jQuery.extend(tick{elem:elem,anim:animation,queue:animation.opts.queue}function propFilter(props,specialEasing){:var index,name,easing,value,hooks;:// camelCase,specialEasing and expand cssHook pass for (index in props){name=jQuery.camelCase(index);:easing=specialEasing[ name ];:value=props[ index ];:if (jQuery.isArray(value)){easing=value[ 1 ];:value=props[ index ]=value[ 0 ]}if (index!==name){:props[ name ]=value;:delete props[ index ]}hooks=jQuery.cssHooks[ name ];if (hooks && "expand" in hooks){:value=hooks.expand(value);:delete props[ name ];:// not quite $.extend,this wont overwrite keys already present. // also - reusing 'index' from above because we have the correct "name" for (index in value){if (!(index in props)){props[ index ]=value[ index ];:specialEasing[ index ]=easing},jQuery.Animation=jQuery.extend(Animation{tweener:function(props,callback){if (jQuery.isFunction(props)){callback=props;:props=[ "*" ]}index=0,length=props.length;for (;index < length;index++),var prop{:prop=props[ index ];:tweeners[ prop ]=tweeners[ prop ] || [];:tweeners[ prop ].unshift(callback)},prefilter:function(callback,prepend){if (prepend){animationPrefilters.unshift(callback)});function defaultPrefilter(elem,opts),props{,"fxshow");// handle queue:false promises if (!opts.queue),dataShow=jQuery._data(elem,hidden=elem.nodeType && isHidden(elem),style=elem.style{:hooks=jQuery._queueHooks(elem,"fx");:if (hooks.unqueued==null){hooks.unqueued=0;:oldfire=hooks.empty.fire;:hooks.empty.fire=function(){if (!hooks.unqueued){oldfire()}hooks.unqueued++;anim.always(function(){:// doing this makes sure that the complete handler will be called // before this completes anim.always(function(){hooks.unqueued--;:if (!jQuery.queue(elem,"fx").length){hooks.empty.fire()}// height/width overflow pass if (elem.nodeType===1 && ("height" in props || "width" in props)){:// Make sure that nothing sneaks out // Record all 3 overflow attributes because IE does not // change the overflow attribute when overflowX and // overflowY are set to the same value opts.overflow=[ style.overflow,style.overflowX,style.overflowY ];:// Set display property to inline-block for height/width // animations on inline elements that are having width/height animated if (jQuery.css(elem,"display")==="inline" && jQuery.css(elem,"float")==="none"){// inline-level elements accept inline-block;:// block-level elements need to be inline with layout if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName)==="inline"){style.display="inline-block"}if (opts.overflow){:style.overflow="hidden";:if (!jQuery.support.shrinkWrapBlocks){anim.always(function(){style.overflow=opts.overflow[ 0 ];:style.overflowX=opts.overflow[ 1 ];:style.overflowY=opts.overflow[ 2 ]}// show/hide pass for (prop in props){:value=props[ prop ];:if (rfxtypes.exec(value)){delete props[ prop ];:toggle=toggle || value==="toggle";if (value===(hidden ? "hide" :"show")){continue}if (!jQuery.isEmptyObject(orig)){if (dataShow){if ("hidden" in dataShow){hidden=dataShow.hidden}// store state if its toggle - enables .stop().toggle() to "reverse" if (toggle){dataShow.hidden=!hidden}if (hidden){jQuery(elem).show()}anim.done(function(){:var prop;:jQuery._removeData(elem,"fxshow");:for (prop in orig){jQuery.style(elem,prop,orig[ prop ])});for (prop in orig){tween=createTween(hidden ? dataShow[ prop ]:0,prop,anim);:if (!(prop in dataShow)){dataShow[ prop ]=tween.start;:if (hidden){tween.end=tween.start;tween.start=prop==="width" || prop==="height" ? 1:0}easing),end,function Tween(elem,options,prop{return new Tween.prototype.init(elem,options,prop,end,easing)}jQuery.Tween=Tween;Tween.prototype={constructor:Tween,init:function(elem,options,prop,end,easing,unit){this.elem=elem;:this.prop=prop;:this.easing=easing || "swing";:this.options=options;:this.start=this.now=this.cur();:this.end=end;this.unit=unit || (jQuery.cssNumber[ prop ] ? "":"px")},cur:function(){:var hooks=Tween.propHooks[ this.prop ];return hooks && hooks.get ? hooks.get(this):Tween.propHooks._default.get(this)},run:function(percent){:var eased,hooks=Tween.propHooks[ this.prop ];:if (this.options.duration){this.pos=eased=jQuery.easing[ this.easing ](percent,this.options.duration * percent,0,1,this.options.duration)}this.now=(this.end - this.start) * eased+this.start;if (this.options.step){this.options.step.call(this.elem,this.now,this)}if (hooks && hooks.set){hooks.set(this)};Tween.prototype.init.prototype=Tween.prototype;Tween.propHooks={_default:{get:function(tween){var result;:if (tween.elem[ tween.prop ]!=null && (!tween.elem.style || tween.elem.style[ tween.prop ]==null)){return tween.elem[ tween.prop ]},set:function(tween){// use step hook for back compat - use cssHook if its there - use .style if its // available and use plain properties where available if (jQuery.fx.step[ tween.prop ]){jQuery.fx.step[ tween.prop ](tween)}else if (tween.elem.style && (tween.elem.style[ jQuery.cssProps[ tween.prop ] ]!=null || jQuery.cssHooks[ tween.prop ])){jQuery.style(tween.elem,tween.prop,tween.now+tween.unit)};// Support:IE <=9 // Panic based approach to setting things on disconnected nodes Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(tween){if (tween.elem.nodeType && tween.elem.parentNode){tween.elem[ tween.prop ]=tween.now};jQuery.each([ "toggle","hide" ],"show",function(i,name){:var cssFn=jQuery.fn[ name ];jQuery.fn[ name ]=function(speed,easing,callback){return speed==null || typeof speed==="boolean" ? cssFn.apply(this,arguments):this.animate(genFx(name,true),speed,easing,callback)});jQuery.fn.extend({fadeTo:function(speed,to,easing,callback){// show any hidden elements after setting opacity to 0 return this.filter(isHidden).css("opacity",0).show() // animate to the value specified .end().animate({opacity:to},animate:function(prop,callback),easing,speed{var empty=jQuery.isEmptyObject(prop),optall=jQuery.speed(speed,easing,callback),doAnimation=function(){, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced // timers currently will call their complete callbacks,which will dequeue // but only if they were gotoEnd if (dequeue ||!gotoEnd){jQuery.dequeue(this,type)},finish:function(type){if (type!==false){type=type || "fx"}return this.each(function(){var index,data=jQuery._data(this),queue=data[ type+"queue" ],hooks=data[ type+"queueHooks" ],timers=jQuery.timers,length=queue ? queue.length:0;:// enable finishing flag on private data data.finish=true;:// empty the queue first jQuery.queue(this,type,[]);:if (hooks && hooks.stop){hooks.stop.call(this,true)}// look for any active animations,and finish them for (index=timers.length;index--;){:if (timers[ index ].elem===this && timers[ index ].queue===type){timers[ index ].anim.stop(true);:timers.splice(index,1)}// look for any animations in the old queue and finish them for (index=0;index < length;index++){if (queue[ index ] && queue[ index ].finish){queue[ index ].finish.call(this)});// Generate parameters to create a standard animation function genFx(type,includeWidth){var which,attrs={height:type},// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node if (!jQuery.contains(docElem,elem)),i=0;// if we include width,step value is 1 to do all cssExpand values{return box}// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent if (jQuery.css(elem,"position")==="fixed"){// we assume that getBoundingClientRect is available when computed position is fixed offset=elem.getBoundingClientRect()}// Subtract parent offsets and element margins // note:when an element has margin:auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 return{top:offset.top - parentOffset.top - jQuery.css(elem,"marginTop",true),left:offset.left - parentOffset.left - jQuery.css(elem,"marginLeft",true)},offsetParent:function(){:return this.map(function(){var offsetParent=this.offsetParent || docElem;:while (offsetParent && (!jQuery.nodeName(offsetParent,"html") && jQuery.css(offsetParent,"position")==="static")){offsetParent=offsetParent.offsetParent});// Create scrollLeft and scrollTop methods jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(method,prop){:var top=/Y/.test(prop);:jQuery.fn[ method ]=function(val){return jQuery.access(this,function(elem,method,val){var win=getWindow(elem);if (val===undefined){return win ? (prop in win) ? win[ prop ]:win.document.documentElement[ method ] :elem[ method ]}if (win){win.scrollTo(!top ? val:jQuery(win).scrollLeft(),top ? val :jQuery(win).scrollTop())});function getWindow(elem){return jQuery.isWindow(elem) ? elem:elem.nodeType===9 ? elem.defaultView || elem.parentWindow :false}// Create innerHeight,height,innerWidth,outerHeight and outerWidth methods jQuery.each(,width{Height:"height",Width:"width"},function(name,type){jQuery.each({padding:"inner"+name,content:type,"":"outer"+name},funcName),function(defaultExtra{// margin is only for outerHeight,outerWidth jQuery.fn[ funcName ]=function(margin,value){var chainable=arguments.length && (defaultExtra || typeof margin!=="boolean"),extra=defaultExtra || (margin===true || value===true ? "margin":"border");if (jQuery.isWindow(elem)){// As of 5/8/2012 this will yield incorrect results for Mobile Safari,but there // isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Limit scope pollution from any deprecated API
// (function() {

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// })();
if ( typeof module === "object" && module && typeof module.exports === "object" ) {
	// Expose jQuery as module.exports in loaders that implement the Node
	// module pattern (including browserify). Do not create the global, since
	// the user will be storing it themselves locally, and globals are frowned
	// upon in the Node module world.
	module.exports = jQuery;
} else {
	// Otherwise expose jQuery to the global object as usual
	window.jQuery = window.$ = jQuery;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	if ( typeof define === "function" && define.amd ) {
		define( "jquery", [], function () { return jQuery; } );
	}
}

})( window );


(function(window, document, undefined) {'use strict';



function minErr(module) {
  return function () {
    var code = arguments[0],
      prefix = '[' + (module ? module + ':' : '') + code + '] ',
      template = arguments[1],
      templateArgs = arguments,
      stringify = function (obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (typeof obj === 'undefined') {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return JSON.stringify(obj);
        }
        return obj;
      },
      message, i;

    message = prefix + template.replace(/\{\d+\}/g, function (match) {
      var index = +match.slice(1, -1), arg;

      if (index + 2 < templateArgs.length) {
        arg = templateArgs[index + 2];
        if (typeof arg === 'function') {
          return arg.toString().replace(/ ?\{[\s\S]*$/, '');
        } else if (typeof arg === 'undefined') {
          return 'undefined';
        } else if (typeof arg !== 'string') {
          return toJson(arg);
        }
        return arg;
      }
      return match;
    });

    message = message + '\nhttp://errors.angularjs.org/1.2.6/' +
      (module ? module + '/' : '') + code;
    for (i = 2; i < arguments.length; i++) {
      message = message + (i == 2 ? '?' : '&') + 'p' + (i-2) + '=' +
        encodeURIComponent(stringify(arguments[i]));
    }

    return new Error(message);
  };
}




////////////////////////////////////


var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};



var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


var manualLowercase = function(s) {
  
  return isString(s)
      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
      : s;
};
var manualUppercase = function(s) {
  
  return isString(s)
      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
      : s;
};


// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish // locale,for this reason we need to detect this case and redefine lowercase/uppercase methods // with correct but slower alternatives. if ('i'!=='I'.toLowerCase()){lowercase=manualLowercase;:uppercase=manualUppercase}),'0','0'];msie=int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);if (isNaN(msie)),angularModule,nodeName_,uid=['0'{:msie=int((/trident\/.*;rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])}function isArrayLike(obj){if (obj==null || isWindow(obj)){return false}var length=obj.length;if (obj.nodeType===1 && length){return true}context),function forEach(obj,iterator{:var key;:if (obj){if (isFunction(obj)){for (key in obj){// Need to check if hasOwnProperty exists,// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function if (key!='prototype' && key!='length' && key!='name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))){iterator.call(context,obj[key],key)}else if (obj.forEach && obj.forEach!==forEach){obj.forEach(iterator,context)}else if (isArrayLike(obj)){:for (key=0;:key < obj.length;:key++) iterator.call(context,obj[key],key)}function sortedKeys(obj){:var keys=[];:for (var key in obj){if (obj.hasOwnProperty(key)){keys.push(key)}context),function forEachSorted(obj,iterator{:var keys=sortedKeys(obj);:for (var i=0;:i < keys.length;:i++){iterator.call(context,obj[keys[i]],keys[i])}function reverseParams(iteratorFn){return function(value,key){iteratorFn(key,value)}function nextUid(){:var index=uid.length;:var digit;:while(index){index--;:digit=uid[index].charCodeAt(0);:if (digit==57){uid[index]='A';:return uid.join('')}if (digit==90){uid[index]='0'}function setHashKey(obj,h){if (h){obj.$$hashKey=h}function extend(dst){:var h=dst.$$hashKey;:forEach(arguments,function(obj){if (obj!==dst){forEach(obj,function(value,key){dst[key]=value}function int(str){return parseInt(str,10)}extra),function inherit(parent{noop.$inject=[];function identity($){return $}identity.$inject=[];function valueFn(value){return function(){return value}function isUndefined(value){return typeof value==='undefined'}function isDefined(value){return typeof value!=='undefined'}function isObject(value){return value!=null && typeof value==='object'}function isString(value){return typeof value==='string'}function isNumber(value){return typeof value==='number'}function isDate(value){return toString.call(value)==='[object Date]'}function isArray(value){return toString.call(value)==='[object Array]'}function isFunction(value){return typeof value==='function'}function isRegExp(value){return toString.call(value)==='[object RegExp]'}function isWindow(obj){return obj && obj.document && obj.location && obj.alert && obj.setInterval}function isScope(obj){return obj && obj.$evalAsync && obj.$watch}function isFile(obj){return toString.call(obj)==='[object File]'}function isBoolean(value){return typeof value==='boolean'}var trim=(function(){// native trim is way faster:http://jsperf.com/angular-trim-test // but IE doesn't have it... :-(
  // TODO: we should move this into IE/ES5 polyfill
  if (!String.prototype.trim) {
    return function(value) {
      return isString(value) ? value.replace(/^\s\s*/, '').replace(/\s\s*$/, '') : value;
    };
  }
  return function(value) {
    return isString(value) ? value.trim() : value;
  };
})();



function isElement(node) {
  return !!(node &&
    (node.nodeName  // we are a direct element
    || (node.on && node.find)));  // we have an on and find method part of jQuery API
}


function makeMap(str){, items = str.split(","), i;
  for ( i = 0; i < items.length; i++ )
    obj[ items[i] ] = true;
  return obj;
}


if (msie < 9) {
  nodeName_ = function(element) {
    element = element.nodeName ? element : element[0];
    return (element.scopeName && element.scopeName != 'HTML')
      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
  };
} else {
  nodeName_ = function(element) {
    return element.nodeName ? element.nodeName : element[0].nodeName;
  };
}


function map(obj, iterator, context) {
  var results = [];
  forEach(obj, function(value, index, list) {
    results.push(iterator.call(context, value, index, list));
  });
  return results;
}



function size(obj, ownPropsOnly) {
  var count = 0, key;

  if (isArray(obj) || isString(obj)) {
    return obj.length;
  } else if (isObject(obj)){
    for (key in obj)
      if (!ownPropsOnly || obj.hasOwnProperty(key))
        count++;
  }

  return count;
}


function includes(array, obj) {
  return indexOf(array, obj) != -1;
}

function indexOf(array, obj) {
  if (array.indexOf) return array.indexOf(obj);

  for (var i = 0; i < array.length; i++) {
    if (obj === array[i]) return i;
  }
  return -1;
}

function arrayRemove(array, value) {
  var index = indexOf(array, value);
  if (index >=0)
    array.splice(index, 1);
  return value;
}

function isLeafNode (node) {
  if (node) {
    switch (node.nodeName) {
    case "OPTION":
    case "PRE":
    case "TITLE":
      return true;
    }
  }
  return false;
}


function copy(source, destination){
  if (isWindow(source) || isScope(source)) {
    throw ngMinErr('cpws',
      "Can't copy!Making copies of Window or Scope instances is not supported.");
  }

  if (!destination) {
    destination = source;
    if (source) {
      if (isArray(source)) {
        destination = copy(source, []);
      } else if (isDate(source)) {
        destination = new Date(source.getTime());
      } else if (isRegExp(source)) {
        destination = new RegExp(source.source);
      } else if (isObject(source)) {);
      }
    }
  } else {
    if (source === destination) throw ngMinErr('cpi',
      "Can't copy! Source and destination are identical.");
    if (isArray(source)) {
      destination.length = 0;
      for ( var i = 0; i < source.length; i++) {
        destination.push(copy(source[i]));
      }
    } else {
      var h = destination.$$hashKey;
      forEach(destination, function(value, key){
        delete destination[key];
      });
      for ( var key in source) {
        destination[key] = copy(source[key]);
      }
      setHashKey(destination,h);
    }
  }
  return destination;
}


function shallowCopy(src, dst) {;

  for(var key in src) {
    // shallowCopy is only ever called by $compile nodeLinkFn, which has control over src
    // so we don't need to worry about using our custom hasOwnProperty here if (src.hasOwnProperty(key) && key.charAt(0)!=='$' && key.charAt(1)!=='$'){dst[key]=src[key]}function equals(o1,o2){:if (o1===o2) return true;:if (o1===null || o2===null) return false;:if (o1!==o1 && o2!==o2) return true;:// NaN===NaN var t1=typeof o1,t2=typeof o2,length,key,keySet;:if (t1==t2){if (t1=='object'){if (isArray(o1)){if (!isArray(o2)) return false;:if ((length=o1.length)==o2.length){for(key=0;:key<length;:key++){if (!equals(o1[key],o2[key])) return false}else if (isDate(o1)){return isDate(o2) && o1.getTime()==o2.getTime()}else if (isRegExp(o1) && isRegExp(o2)){return o1.toString()==o2.toString()};for(key in o1){:if (key.charAt(0)==='$' || isFunction(o1[key])) continue;:if (!equals(o1[key],o2[key])) return false;:keySet[key]=true}for(key in o2){if (!keySet.hasOwnProperty(key) && key.charAt(0)!=='$' && o2[key]!==undefined &&!isFunction(o2[key])) return false}function csp(){return (document.securityPolicy && document.securityPolicy.isActive) || (document.querySelector &&!!(document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]')))}array2,function concat(array1,index){return array1.concat(slice.call(array2,index))}function sliceArgs(args,startIndex){return slice.call(args,startIndex || 0)}fn),function bind(self{var curryArgs=arguments.length>2 ? sliceArgs(arguments,2):[];if (isFunction(fn) &&!(fn instanceof RegExp)){return curryArgs.length ? function(){return arguments.length ? fn.apply(self,curryArgs.concat(slice.call(arguments,0))):fn.apply(self,curryArgs)}:function(){return arguments.length ? fn.apply(self,arguments):fn.call(self)}'", tag);
    }

    modules = modules || [];
    modules.unshift(['$provide', function($provide) {
      $provide.value('$rootElement', element);
    }]);
    modules.unshift('ng');
    var injector = createInjector(modules);
    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate',
       function(scope, element, compile, injector, animate) {
        scope.$apply(function() {
          element.data('$injector', injector);
          compile(element)(scope);
        });
      }]
    );
    return injector;
  };

  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return doBootstrap();
  }

  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
  angular.resumeBootstrap = function(extraModules) {
    forEach(extraModules, function(module) {
      modules.push(module);
    });
    doBootstrap();
  };
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator){
  separator = separator || '_';
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
  });
}

function bindJQuery() {
  // bind to jQuery if present;
  jQuery = window.jQuery;
  // reset to jQuery or default to us.
  if (jQuery) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });
    // Method signature:
    //     jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)
    jqLitePatchJQueryRemove('remove', true, true, false);
    jqLitePatchJQueryRemove('empty', false, false, false);
    jqLitePatchJQueryRemove('html', false, false, true);
  } else {
    jqLite = JQLite;
  }
  angular.element = jqLite;
}


function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument ',' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
  }

  assertArg(isFunction(arg), name, 'not a function,got ' +
      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
  return arg;
}


function assertNotHasOwnProperty(name, context) {
  if (name === 'hasOwnProperty') {
    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
  }
}


//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
  if (!path) return obj;
  var keys = path.split('.');
  var key;
  var lastInstance = obj;
  var len = keys.length;

  for (var i = 0; i < len; i++) {
    key = keys[i];
    if (obj) {
      obj = (lastInstance = obj)[key];
    }
  }
  if (!bindFnToScope && isFunction(obj)) {
    return bind(lastInstance, obj);
  }
  return obj;
}


function getBlockElements(nodes) {
  var startNode = nodes[0],
      endNode = nodes[nodes.length - 1];
  if (startNode === endNode) {
    return jqLite(startNode);
  }

  var element = startNode;
  var elements = [element];

  do {
    element = element.nextSibling;
    if (!element) break;
    elements.push(element);
  } while (element !== endNode);

  return jqLite(elements);
}



function setupModuleLoader(window) {

  var $injectorMinErr = minErr('$injector');
  var ngMinErr = minErr('ng');

  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  var angular = ensure(window, 'angular', Object);

  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap
  angular.$$minErr = angular.$$minErr || minErr;

  return ensure(angular, 'module', function() {;

    
    return function module(name, requires, configFn) {
      var assertNotHasOwnProperty = function(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', 'hasOwnProperty is not a valid,name', context);
        }
      };

      assertNotHasOwnProperty(name, 'module');
      if (requires && modules.hasOwnProperty(name)) {
        modules[name] = null;
      }
      return ensure(modules, name, function() {
        if (!requires) {
          throw $injectorMinErr('nomod', "Module '{0};function publishExternalAPI(angular){extend(angular,{'bootstrap':bootstrap,'copy':copy,'extend':extend,'equals':equals,'element':jqLite,'forEach':forEach,'injector':createInjector,'noop':noop,'bind':bind,'toJson':toJson,'fromJson':fromJson,'identity':identity,'isUndefined':isUndefined,'isDefined':isDefined,'isString':isString,'isFunction':isFunction,'isObject':isObject,'isNumber':isNumber,'isElement':isElement,'isArray':isArray,'version':version,'isDate':isDate,'lowercase':lowercase,'uppercase':uppercase,'callbacks':{counter:0});angularModule=setupModuleLoader(window);try{angularModule('ngLocale')}['ngLocale'],['$provide',angularModule('ng',function ngModule($provide){// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it. $provide.provider({$$sanitizeUri:$$SanitizeUriProvider}$CompileProvider). directive(,);$provide.provider('$compile'{a:htmlAnchorDirective,input:inputDirective,textarea:inputDirective,form:formDirective,script:scriptDirective,select:selectDirective,style:styleDirective,option:optionDirective,ngBind:ngBindDirective,ngBindHtml:ngBindHtmlDirective,ngBindTemplate:ngBindTemplateDirective,ngClass:ngClassDirective,ngClassEven:ngClassEvenDirective,ngClassOdd:ngClassOddDirective,ngCloak:ngCloakDirective,ngController:ngControllerDirective,ngForm:ngFormDirective,ngHide:ngHideDirective,ngIf:ngIfDirective,ngInclude:ngIncludeDirective,ngInit:ngInitDirective,ngNonBindable:ngNonBindableDirective,ngPluralize:ngPluralizeDirective,ngRepeat:ngRepeatDirective,ngShow:ngShowDirective,ngStyle:ngStyleDirective,ngSwitch:ngSwitchDirective,ngSwitchWhen:ngSwitchWhenDirective,ngSwitchDefault:ngSwitchDefaultDirective,ngOptions:ngOptionsDirective,ngTransclude:ngTranscludeDirective,ngModel:ngModelDirective,ngList:ngListDirective,ngChange:ngChangeDirective,required:requiredDirective,ngRequired:requiredDirective,ngValue:ngValueDirective}). directive({ngInclude:ngIncludeFillContentDirective}). directive(ngAttributeAliasDirectives). directive(ngEventDirectives);$provide.provider({$anchorScroll:$AnchorScrollProvider,$animate:$AnimateProvider,$browser:$BrowserProvider,$cacheFactory:$CacheFactoryProvider,$controller:$ControllerProvider,$document:$DocumentProvider,$exceptionHandler:$ExceptionHandlerProvider,$filter:$FilterProvider,$interpolate:$InterpolateProvider,$interval:$IntervalProvider,$http:$HttpProvider,$httpBackend:$HttpBackendProvider,$location:$LocationProvider,$log:$LogProvider,$parse:$ParseProvider,$rootScope:$RootScopeProvider,$q:$QProvider,$sce:$SceProvider,$sceDelegate:$SceDelegateProvider,$sniffer:$SnifferProvider,$templateCache:$TemplateCacheProvider,$timeout:$TimeoutProvider,$window:$WindowProvider},addEventListenerFn=(window.document.addEventListener ? function(element,fn),jqId=1,jqName=JQLite.expando='ng-'+new Date().getTime(),type{element.addEventListener(type,fn,false)}),fn),removeEventListenerFn=(window.document.removeEventListener ? function(element,type{element.removeEventListener(type,fn,false)});function jqNextId(){return ++jqId}var SPECIAL_CHARS_REGEXP=/([\:\-\_]+(.))/g;var MOZ_HACK_REGEXP=/^moz([A-Z])/;var jqLiteMinErr=minErr('jqLite');function camelCase(name){return name. replace(SPECIAL_CHARS_REGEXP,function(_,separator,letter,offset){return offset ? letter.toUpperCase():letter}function jqLiteHasClass(element,selector){:if (!element.getAttribute) return false;:return ((" "+(element.getAttribute('class') || '')+" ").replace(/[\n\t]/g," "). indexOf(" "+selector+" ")>-1)}cssClasses),function jqLiteRemoveClass(element{if (cssClasses && element.setAttribute){forEach(cssClasses.split(' '),function(cssClass){element.setAttribute('class',trim((" "+(element.getAttribute('class') || '')+" ") .replace(/[\n\t]/g," ") .replace(" "+trim(cssClass)+" "," ")))}cssClasses),function jqLiteAddClass(element{:if (cssClasses && element.setAttribute){var existingClasses=(' '+(element.getAttribute('class') || '')+' ') .replace(/[\n\t]/g," ");:forEach(cssClasses.split(' '),function(cssClass){cssClass=trim(cssClass);:if (existingClasses.indexOf(' '+cssClass+' ')===-1){existingClasses +=cssClass+' '}elements),function jqLiteAddNodes(root{if (elements){elements=(!elements.nodeName && isDefined(elements.length) &&!isWindow(elements)) ? elements:[ elements ];:for(var i=0;:i < elements.length;:i++){root.push(elements[i])}function jqLiteController(element,name){return jqLiteInheritedData(element,'$'+(name || 'ngController')+'Controller')}function jqLiteInheritedData(element,name,value){:element=jqLite(element);:// if element is the document object work with the html element instead // this makes $(document).scope() possible if(element[0].nodeType==9){element=element.find('html')}var names=isArray(name) ? name:[name];while (element.length){:for (var i=0,ii=names.length;:i < ii;:i++){if ((value=element.data(names[i]))!==undefined) return value}function jqLiteEmpty(element){:for (var i=0,childNodes=element.childNodes;:i < childNodes.length;:i++){jqLiteDealoc(childNodes[i])}while (element.firstChild){element.removeChild(element.firstChild)}////////////////////////////////////////// // Functions which are declared directly. ////////////////////////////////////////// var JQLitePrototype=JQLite.prototype={ready:function(fn){var fired=false;:function trigger(){if (fired) return;:fired=true;:fn()}// check if document already is loaded if (document.readyState==='complete'){setTimeout(trigger)},toString:function(){:var value=[];:forEach(this,function(e){value.push(''+e)},eq:function(index){return (index >=0) ? jqLite(this[index]):jqLite(this[this.length+index])};forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','),function(value){BOOLEAN_ATTR[lowercase(value)]=value};forEach('input,select,option,textarea,button,form,details'.split(','),function(value){BOOLEAN_ELEMENTS[uppercase(value)]=true});function getBooleanAttrName(element,name){:// check dom last since we will most likely fail on name var booleanAttr=BOOLEAN_ATTR[name.toLowerCase()];:// booleanAttr is here twice to minimize DOM access return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr}forEach({data:jqLiteData,inheritedData:jqLiteInheritedData,scope:function(element){// Can't use jqLiteData here directly so we stay compatible with jQuery!
    return jqLite(element).data('$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
  },

  isolateScope: function(element) {
    // Can't use jqLiteData here directly so we stay compatible with jQuery!return jqLite(element).data('$isolateScope') || jqLite(element).data('$isolateScopeNoTemplate')},controller:jqLiteController,injector:function(element){return jqLiteInheritedData(element,'$injector')},name),removeAttr:function(element{element.removeAttribute(name)},css:function(element,hasClass:jqLiteHasClass,name,value){:name=camelCase(name);:if (isDefined(value)){element.style[name]=value}val=val || element.style[name];if (msie <=8){// jquery weirdness:-/ val=(val==='') ? undefined :val},attr:function(element,name,value){:var lowercasedName=lowercase(name);:if (BOOLEAN_ATTR[lowercasedName]){if (isDefined(value)){if (!!value){element[name]=true;:element.setAttribute(name,lowercasedName)}else if (isDefined(value)){element.setAttribute(name,value)}else if (element.getAttribute){:// the extra argument "2" is to get the right thing for a.href in IE,see jQuery code // some elements (e.g. Document) don't have get attribute, so return undefined
      var ret = element.getAttribute(name, 2);
      // normalize non-existing attributes to undefined (as jQuery)
      return ret === null ? undefined : ret;
    }
  },

  prop: function(element, name, value) {
    if (isDefined(value)) {
      element[name] = value;
    } else {
      return element[name];
    }
  },

  text: (function() {
    var NODE_TYPE_TEXT_PROPERTY = [];
    if (msie < 9) {
      NODE_TYPE_TEXT_PROPERTY[1] = 'innerText';    
      NODE_TYPE_TEXT_PROPERTY[3] = 'nodeValue';    
    } else {
      NODE_TYPE_TEXT_PROPERTY[1] =                 
      NODE_TYPE_TEXT_PROPERTY[3] = 'textContent';  
    }
    getText.$dv = '';
    return getText;

    function getText(element, value) {
      var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
      if (isUndefined(value)) {
        return textProp ? element[textProp] : '';
      }
      element[textProp] = value;
    }
  })(),

  val: function(element, value) {
    if (isUndefined(value)) {
      if (nodeName_(element) === 'SELECT' && element.multiple) {
        var result = [];
        forEach(element.options, function (option) {
          if (option.selected) {
            result.push(option.value || option.text);
          }
        });
        return result.length === 0 ? null : result;
      }
      return element.value;
    }
    element.value = value;
  },

  html: function(element, value) {
    if (isUndefined(value)) {
      return element.innerHTML;
    }
    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
      jqLiteDealoc(childNodes[i]);
    }
    element.innerHTML = value;
  },

  empty: jqLiteEmpty
}, function(fn, name){
  
  JQLite.prototype[name] = function(arg1, arg2) {
    var i, key;

    // jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
    // in a way that survives minification.
    // jqLiteEmpty takes no arguments but is a setter.
    if (fn !== jqLiteEmpty &&
        (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
      if (isObject(arg1)) {

        // we are a write, but the object properties are the key/values
        for (i = 0; i < this.length; i++) {
          if (fn === jqLiteData) {
            // data() takes the whole object in jQuery
            fn(this[i], arg1);
          } else {
            for (key in arg1) {
              fn(this[i], key, arg1[key]);
            }
          }
        }
        // return self for chaining
        return this;
      } else {
        // we are a read, so read the first child.
        var value = fn.$dv;
        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
        var jj = (value === undefined) ? Math.min(this.length, 1) : this.length;
        for (var j = 0; j < jj; j++) {
          var nodeValue = fn(this[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        }
        return value;
      }
    } else {
      // we are a write, so apply to all children
      for (i = 0; i < this.length; i++) {
        fn(this[i], arg1, arg2);
      }
      // return self for chaining
      return this;
    }
  };
});

function createEventHandler(element, events) {
  var eventHandler = function (event, type) {
    if (!event.preventDefault) {
      event.preventDefault = function() {
        event.returnValue = false; //ie
      };
    }

    if (!event.stopPropagation) {
      event.stopPropagation = function() {
        event.cancelBubble = true; //ie
      };
    }

    if (!event.target) {
      event.target = event.srcElement || document;
    }

    if (isUndefined(event.defaultPrevented)) {
      var prevent = event.preventDefault;
      event.preventDefault = function() {
        event.defaultPrevented = true;
        prevent.call(event);
      };
      event.defaultPrevented = false;
    }

    event.isDefaultPrevented = function() {
      return event.defaultPrevented || event.returnValue === false;
    };

    // Copy event handlers in case event handlers array is modified during execution.
    var eventHandlersCopy = shallowCopy(events[type || event.type] || []);

    forEach(eventHandlersCopy, function(fn) {
      fn.call(element, event);
    });

    // Remove monkey-patched methods (IE),
    // as they would cause memory leaks in IE8.
    if (msie <= 8) {
      // IE7/8 does not allow to delete property on native object
      event.preventDefault = null;
      event.stopPropagation = null;
      event.isDefaultPrevented = null;
    } else {
      // It shouldn't affect normal browsers (native methods are defined on prototype). delete event.preventDefault;:delete event.stopPropagation;:delete event.isDefaultPrevented}////////////////////////////////////////// // Functions iterating traversal. // These functions chain results into a single // selector. ////////////////////////////////////////// forEach({removeData:jqLiteRemoveData,dealoc:jqLiteDealoc,on:function onFn(element,type,fn,unsupported){);if (!handle) jqLiteExpandoStore(element,'handle',events));forEach(type.split(' '),function(type),handle=createEventHandler(element{:var eventFns=events[type];if (!eventFns){if (type=='mouseenter' || type=='mouseleave'){var contains=document.body.contains || document.body.compareDocumentPosition ? function(a,b){// jshint bitwise:false var adown=a.nodeType===9 ? a.documentElement:a,bup=b && b.parentNode;return a===bup ||!!(bup && bup.nodeType===1 && (adown.contains ? adown.contains(bup):a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))}:function(a,b){if (b){while ((b=b.parentNode)){if (b===a){return true};events[type]=[];// Refer to jQuery's implementation of mouseenter & mouseleave
          // Read about mouseenter and mouseleave:
          // http://www.quirksmode.org/js/events_mouse.html#link8
          var eventmap = { mouseleave : "mouseout", mouseenter : "mouseover"};

          onFn(element, eventmap[type], function(event) {
            var target = this, related = event.relatedTarget;
            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !contains(target, related)) ){
              handle(event, type);
            }
          });

        } else {
          addEventListenerFn(element, type, handle);
          events[type] = [];
        }
        eventFns = events[type];
      }
      eventFns.push(fn);
    });
  },

  off: jqLiteOff,

  one: function(element, type, fn) {
    element = jqLite(element);

    //add the listener twice so that when it is called
    //you can remove the original function and still be
    //able to call element.off(ev, fn) normally
    element.on(type, function onFn() {
      element.off(type, fn);
      element.off(type, onFn);
    });
    element.on(type, fn);
  },

  replaceWith: function(element, replaceNode) {
    var index, parent = element.parentNode;
    jqLiteDealoc(element);
    forEach(new JQLite(replaceNode), function(node){
      if (index) {
        parent.insertBefore(node, index.nextSibling);
      } else {
        parent.replaceChild(node, element);
      }
      index = node;
    });
  },

  children: function(element) {
    var children = [];
    forEach(element.childNodes, function(element){
      if (element.nodeType === 1)
        children.push(element);
    });
    return children;
  },

  contents: function(element) {
    return element.childNodes || [];
  },

  append: function(element, node) {
    forEach(new JQLite(node), function(child){
      if (element.nodeType === 1 || element.nodeType === 11) {
        element.appendChild(child);
      }
    });
  },

  prepend: function(element, node) {
    if (element.nodeType === 1) {
      var index = element.firstChild;
      forEach(new JQLite(node), function(child){
        element.insertBefore(child, index);
      });
    }
  },

  wrap: function(element, wrapNode) {
    wrapNode = jqLite(wrapNode)[0];
    var parent = element.parentNode;
    if (parent) {
      parent.replaceChild(wrapNode, element);
    }
    wrapNode.appendChild(element);
  },

  remove: function(element) {
    jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  },

  after: function(element, newElement) {
    var index = element, parent = element.parentNode;
    forEach(new JQLite(newElement), function(node){
      parent.insertBefore(node, index.nextSibling);
      index = node;
    });
  },

  addClass: jqLiteAddClass,
  removeClass: jqLiteRemoveClass,

  toggleClass: function(element, selector, condition) {
    if (isUndefined(condition)) {
      condition = !jqLiteHasClass(element, selector);
    }
    (condition ? jqLiteAddClass : jqLiteRemoveClass)(element, selector);
  },

  parent: function(element) {
    var parent = element.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },

  next: function(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }

    // IE8 doesn't have nextElementSibling var elm=element.nextSibling;while (elm!=null && elm.nodeType!==1){elm=elm.nextSibling},find:function(element,selector){if (element.getElementsByTagName){return element.getElementsByTagName(selector)},clone:jqLiteClone,eventData),eventName,triggerHandler:function(element{)[eventName];eventData=eventData || [];var event=[{preventDefault:noop,stopPropagation:noop}];forEach(eventFns,function(fn){fn.apply(element,event.concat(eventData))},function(fn,name){:JQLite.prototype[name]=function(arg1,arg2,arg3){var value;:for(var i=0;:i < this.length;:i++){if (isUndefined(value)){value=fn(this[i],arg1,arg2,arg3);:if (isDefined(value)){// any function which returns a value needs to be wrapped value=jqLite(value)});function hashKey(obj){:var objType=typeof obj,key;:if (objType=='object' && obj!==null){if (typeof (key=obj.$$hashKey)=='function'){// must invoke on object to keep the right this key=obj.$$hashKey()}else if (key===undefined){key=obj.$$hashKey=nextUid()}function HashMap(array){forEach(array,this.put,this)}HashMap.prototype={put:function(key,value){this[hashKey(key)]=value},get:function(key){return this[hashKey(key)]},remove:function(key){:var value=this[key=hashKey(key)];:delete this[key];:return value}/;var FN_ARG=/^\s*(_?)(\S+?)\1\s*$/;var STRIP_COMMENTS=/((\/\/.*$)|(\/\[\s\S]*?\*\/))/mg;var $injectorMinErr=minErr('$injector');function annotate(fn),;var FN_ARGS=/^function\s[^\(]*\(\s*([^\)]*)\)/m;var FN_ARG_SPLIT=/{:var $inject,fnText,argDecl,last;:if (typeof fn=='function'){if (!($inject=fn.$inject)){$inject=[];:if (fn.length){fnText=fn.toString().replace(STRIP_COMMENTS,'');:argDecl=fnText.match(FN_ARGS);:forEach(argDecl[1].split(FN_ARG_SPLIT),function(arg){arg.replace(FN_ARG,function(all,underscore,name){$inject.push(name)}else if (isArray(fn)){:last=fn.length - 1;:assertArgFn(fn[last],'fn');:$inject=fn.slice(0,last)}/////////////////////////////////////// function createInjector(modulesToLoad){,loadedModules=new HashMap(),path=[],providerCache=,providerSuffix='Provider'{$provide:{provider:supportObject(provider),factory:supportObject(factory),service:supportObject(service),value:supportObject(value),constant:supportObject(constant),decorator:decorator},function(),providerInjector=(providerCache.$injector=createInternalInjector(providerCache{throw $injectorMinErr('unpr',"Unknown provider: {0}",path.join(' <- '))},function(servicename),instanceInjector=(instanceCache.$injector=createInternalInjector(instanceCache{:var provider=providerInjector.get(servicename+providerSuffix);:return instanceInjector.invoke(provider.$get,provider)}));forEach(loadModules(modulesToLoad),function(fn){instanceInjector.invoke(fn || noop)});return instanceInjector;//////////////////////////////////// // $provider //////////////////////////////////// function supportObject(delegate){return function(key,value){if (isObject(key)){forEach(key,reverseParams(delegate))}function provider(name,provider_){:assertNotHasOwnProperty(name,'service');:if (isFunction(provider_) || isArray(provider_)){provider_=providerInjector.instantiate(provider_)}if (!provider_.$get){throw $injectorMinErr('pget',"Provider '{0}' must define $get factory method.",name)}factoryFn),function factory(name{return provider(name,{$get:factoryFn}constructor),function service(name{return factory(name,['$injector',function($injector){return $injector.instantiate(constructor)}function value(name,val){return factory(name,valueFn(val))}function constant(name,value){:assertNotHasOwnProperty(name,'constant');:providerCache[name]=value;:instanceCache[name]=value}decorFn),function decorator(serviceName{:var origProvider=providerInjector.get(serviceName+providerSuffix),orig$get=origProvider.$get;:origProvider.$get=function(){var origInstance=instanceInjector.invoke(orig$get,origProvider);return instanceInjector.invoke(decorFn,null,{$delegate:origInstance}//////////////////////////////////// // Module Loading //////////////////////////////////// function loadModules(modulesToLoad){:var runBlocks=[],moduleFn,invokeQueue,i,ii;:forEach(modulesToLoad,function(module){if (loadedModules.get(module)) return;:loadedModules.put(module,true);:try{if (isString(module)){moduleFn=angularModule(module);:runBlocks=runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);:for(invokeQueue=moduleFn._invokeQueue,i=0,ii=invokeQueue.length;:i < ii;:i++){var invokeArgs=invokeQueue[i],provider=providerInjector.get(invokeArgs[0]);:provider[invokeArgs[1]].apply(provider,invokeArgs[2])}else if (isArray(module)),else if (isFunction(module)){runBlocks.push(providerInjector.invoke(module))}if (e.message && e.stack && e.stack.indexOf(e.message)==-1){// Safari & FF's stack traces don't contain error.message content // unlike those of Chrome and IE // So if stack doesn't contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here. e=e.message+'\n'+e.stack}//////////////////////////////////// // internal Injector //////////////////////////////////// function createInternalInjector(cache,factory){function getService(serviceName){if (cache.hasOwnProperty(serviceName)){if (cache[serviceName]===INSTANTIATING){throw $injectorMinErr('cdep','Circular dependency found: {0}',path.join(' <- '))}function invoke(fn,locals),self{:var args=[],$inject=annotate(fn),length,i,key;:for(i=0,length=$inject.length;:i < length;:i++){key=$inject[i];:if (typeof key!=='string'){throw $injectorMinErr('itkn','Incorrect injection token! Expected service name as string, got {0}',key)}if (!fn.$inject){// this means that we must be an array. fn=fn[length]}function instantiate(Type,locals){return{invoke:invoke,instantiate:instantiate,get:getService,annotate:annotate,has:function(name){return providerCache.hasOwnProperty(name+providerSuffix) || cache.hasOwnProperty(name)}function $AnchorScrollProvider(){:var autoScrollingEnabled=true;:this.disableAutoScrolling=function(){autoScrollingEnabled=false}$location,$rootScope),;this.$get=['$window','$location','$rootScope',function($window{// helper function to get first anchor from a NodeList // can't use filter.filter, as it accepts only instances of Array
    // and IE can't convert NodeList to an array using [].slice // TODO(vojta):use filter if we change it to accept lists as well function getFirstAnchor(list){var result=null;:forEach(list,function(element){if (!result && lowercase(element.nodeName)==='a') result=element}function scroll(){// first anchor with given name:-D else if ((elm=getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();:// no element and hash=='top',scroll to the top of the page else if (hash==='top') $window.scrollTo(0,0)}// does not scroll when user clicks on anchor link that is currently on // (no url change,browser native does scroll if (autoScrollingEnabled),no $location.hash() change){$rootScope.$watch(function autoScrollWatch(){return $location.hash()},function autoScrollWatchAction(){$rootScope.$evalAsync(scroll)}function($provide),var $animateMinErr=minErr('$animate');var $AnimateProvider=['$provide'{;this.register=function(name,factory){:var key=name+'-animation';:if (name && name.charAt(0)!='.') throw $animateMinErr('notcsel',"Expecting class selector starting with '.' got '{0}'.",name);:this.$$selectors[name.substr(1)]=key;:$provide.factory(key,factory)};this.classNameFilter=function(expression){if(arguments.length===1){this.$$classNameFilter=(expression instanceof RegExp) ? expression:null};this.$get=['$timeout',function($timeout){return{enter :function(element,parent,after,done){if (after){after.after(element)},done),leave :function(element{:element.remove();:done && $timeout(done,0,false)},after,done),move :function(element,parent{// Do not remove element before insert. Removing will cause data associated with the // element to be dropped. Insert will implicitly do the remove. this.enter(element,parent,after,done)},addClass :function(element,className,done){className=isString(className) ? className:isArray(className) ? className.join(' ') :'';:forEach(element,function (element){jqLiteAddClass(element,className)},className,done),removeClass :function(element{className=isString(className) ? className:isArray(className) ? className.join(' ') :'';:forEach(element,function (element){jqLiteRemoveClass(element,className)}$log,$sniffer),];function Browser(window,document{;self.isMock=false;var outstandingRequestCount=0;var outstandingRequestCallbacks=[];// TODO(vojta):remove this temporary api self.$$completeOutstandingRequest=completeOutstandingRequest;self.$$incOutstandingRequestCount=function(){outstandingRequestCount++};function completeOutstandingRequest(fn){try{fn.apply(null,sliceArgs(arguments,1))}self.notifyWhenNoOutstandingRequests=function(callback){expires=Thu,01 Jan 1970 00:00:00 GMT";
      } else {
        if (isString(value)) {
          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) +
                                ';path=' + cookiePath).length + 1;

          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
          // - 300 cookies
          // - 20 cookies per unique domain
          // - 4096 bytes per cookie
          if (cookieLength > 4096) {
            $log.warn("Cookie '"+ name +
              "' possibly not set or overflowed because it was too large ("+
              cookieLength + ">4096 bytes)!");
          }
        }
      }
    } else {
      if (rawDocument.cookie !== lastCookieString) {;

        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf('=');
          if (index > 0) { //ignore nameless cookies
            name = unescape(cookie.substring(0, index));
            // the first value that is seen for a cookie is the most
            // specific one.  values for the same cookie name that
            // follow are for less specific paths.
            if (lastCookies[name] === undefined) {
              lastCookies[name] = unescape(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    }
  };


  
  self.defer = function(fn, delay) {
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(function() {
      delete pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    }, delay || 0);
    pendingDeferIds[timeoutId] = true;
    return timeoutId;
  };


  
  self.defer.cancel = function(deferId) {
    if (pendingDeferIds[deferId]) {
      delete pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      return true;
    }
    return false;
  };

}

function $BrowserProvider(){
  this.$get = ['$window', '$log', '$sniffer', '$document',
      function( $window,   $log,   $sniffer,   $document){
        return new Browser($window, $document, $log, $sniffer);
      }];
}


function $CacheFactoryProvider() {

  this.$get = function() {;

    function cacheFactory(cacheId, options) {
      if (cacheId in caches) {
        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
      }, options, {id: cacheId},
          freshEnd = null,
          staleEnd = null;

      return caches[cacheId] = {

        put: function(key, value) {
          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

          refresh(lruEntry);

          if (isUndefined(value)) return;
          if (!(key in data)) size++;
          data[key] = value;

          if (size > capacity) {
            this.remove(staleEnd.key);
          }

          return value;
        },


        get: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          refresh(lruEntry);

          return data[key];
        },


        remove: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          if (lruEntry == freshEnd) freshEnd = lruEntry.p;
          if (lruEntry == staleEnd) staleEnd = lruEntry.n;
          link(lruEntry.n,lruEntry.p);

          delete lruHash[key];
          delete data[key];
          size--;
        },


        removeAll: function() {;
          freshEnd = staleEnd = null;
        },


        destroy: function() {
          data = null;
          stats = null;
          lruHash = null;
          delete caches[cacheId];
        },


        info: function() {, stats, {size: size});
        }
      };


      
      function refresh(entry) {
        if (entry != freshEnd) {
          if (!staleEnd) {
            staleEnd = entry;
          } else if (staleEnd == entry) {
            staleEnd = entry.n;
          }

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        }
      }


      
      function link(nextEntry, prevEntry) {
        if (nextEntry != prevEntry) {
          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
        }
      }
    }


  
    cacheFactory.info = function() {;
      forEach(caches, function(cache, cacheId) {
        info[cacheId] = cache.info();
      });
      return info;
    };


  
    cacheFactory.get = function(cacheId) {
      return caches[cacheId];
    };


    return cacheFactory;
  };
}


function $TemplateCacheProvider() {
  this.$get = ['$cacheFactory', function($cacheFactory) {
    return $cacheFactory('templates');
  }];
}






var $compileMinErr = minErr('$compile');


$CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
function $CompileProvider($provide, $$sanitizeUriProvider) {,
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;

  
   this.directive = function registerDirective(name, directiveFactory) {
    assertNotHasOwnProperty(name, 'directive');
    if (isString(name)) {
      assertArg(directiveFactory, 'directiveFactory');
      if (!hasDirectives.hasOwnProperty(name)) {
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
          function($injector, $exceptionHandler) {
            var directives = [];
            forEach(hasDirectives[name], function(directiveFactory, index) {
              try {
                var directive = $injector.invoke(directiveFactory);
                if (isFunction(directive)) {
                  directive = { compile: valueFn(directive) };
                } else if (!directive.compile && directive.link) {
                  directive.compile = valueFn(directive.link);
                }
                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller && directive.name);
                directive.restrict = directive.restrict || 'A';
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          }]);
      }
      hasDirectives[name].push(directiveFactory);
    } else {
      forEach(name, reverseParams(registerDirective));
    }
    return this;
  };


  
  this.aHrefSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
      return this;
    } else {
      return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
    }
  };


  
  this.imgSrcSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
      return this;
    } else {
      return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
    }
  };

  this.$get = [
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',
            '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri',
    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) {

    var Attributes = function(element, attr) {;
    };

    Attributes.prototype = {
      $normalize: directiveNormalize,


      
      $addClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.addClass(this.$$element, classVal);
        }
      },

      
      $removeClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.removeClass(this.$$element, classVal);
        }
      },

      
      $updateClass : function(newClasses, oldClasses) {
        this.$removeClass(tokenDifference(oldClasses, newClasses));
        this.$addClass(tokenDifference(newClasses, oldClasses));
      },

      
      $set: function(key, value, writeAttr, attrName) {
        // TODO: decide whether or not to throw an error if "class"
        //is set through this function since it may cause $updateClass to
        //become unstable.

        var booleanKey = getBooleanAttrName(this.$$element[0], key),
            normalizedVal,
            nodeName;

        if (booleanKey) {
          this.$$element.prop(key, value);
          attrName = booleanKey;
        }

        this[key] = value;

        // translate normalized key to actual key
        if (attrName) {
          this.$attr[key] = attrName;
        } else {
          attrName = this.$attr[key];
          if (!attrName) {
            this.$attr[key] = attrName = snake_case(key, '-');
          }
        }

        nodeName = nodeName_(this.$$element);

        // sanitize a[href] and img[src] values
        if ((nodeName === 'A' && key === 'href') ||
            (nodeName === 'IMG' && key === 'src')) {
          this[key] = value = $$sanitizeUri(value, key === 'src');
        }

        if (writeAttr !== false) {
          if (value === null || value === undefined) {
            this.$$element.removeAttr(attrName);
          } else {
            this.$$element.attr(attrName, value);
          }
        }

        // fire observers
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[key], function(fn) {
          try {
            fn(value);
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      },


      
      $observe: function(key, fn) {)),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(function() {
          if (!listeners.$$inter) {
            // no one registered attribute interpolation function, so lets call it manually
            fn(attrs[key]);
          }
        });
        return fn;
      }
    };

    var startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
            ? identity
            : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
        },
        NG_ATTR_BINDING = /^ngAttr[A-Z]/;


    return compile;

    //================================

    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
                        previousCompileContext) {
      if (!($compileNodes instanceof jqLite)) {
        // jquery always rewraps, whereas we need to preserve the original selector so that we can
        // modify it.
        $compileNodes = jqLite($compileNodes);
      }
      // We can not compile top level text elements since text nodes can be merged and we will
      // not be able to attach scope data to them, so we will wrap them in <span>
      forEach($compileNodes, function(node, index){
        if (node.nodeType == 3  && node.nodeValue.match(/\S+/)  ) {
          $compileNodes[index] = node = jqLite(node).wrap('<span></span>').parent()[0];
        }
      });
      var compositeLinkFn =
              compileNodes($compileNodes, transcludeFn, $compileNodes,
                           maxPriority, ignoreDirective, previousCompileContext);
      safeAddClass($compileNodes, 'ng-scope');
      return function publicLinkFn(scope, cloneConnectFn, transcludeControllers){
        assertArg(scope, 'scope');
        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
        // and sometimes changes the structure of the DOM.
        var $linkNode = cloneConnectFn
          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!
          : $compileNodes;

        forEach(transcludeControllers, function(instance, name) {
          $linkNode.data('$' + name + 'Controller', instance);
        });

        // Attach scope only to non-text nodes.
        for(var i = 0, ii = $linkNode.length; i<ii; i++) {
          var node = $linkNode[i],
              nodeType = node.nodeType;
          if (nodeType === 1  || nodeType === 9 ) {
            $linkNode.eq(i).data('$scope', scope);
          }
        }

        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
        return $linkNode;
      };
    }

    function safeAddClass($element, className) {
      try {
        $element.addClass(className);
      } catch(e) {
        // ignore, since it means that we are trying to set class on
        // SVG element, where class name is read-only.
      }
    }

    
    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
                            previousCompileContext) {
      var linkFns = [],
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound;

      for (var i = 0; i < nodeList.length; i++) {
        attrs = new Attributes();

        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
                                        ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                                      null, [], [], previousCompileContext)
            : null;

        if (nodeLinkFn && nodeLinkFn.scope) {
          safeAddClass(jqLite(nodeList[i]), 'ng-scope');
        }

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
                      !(childNodes = nodeList[i].childNodes) ||
                      !childNodes.length)
            ? null
            : compileNodes(childNodes,
                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

        linkFns.push(nodeLinkFn, childLinkFn);
        linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
        //use the previous context only for the first element in the virtual group
        previousCompileContext = null;
      }

      // return a linking function if we have found anything, null otherwise
      return linkFnFound ? compositeLinkFn : null;

      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
        var nodeLinkFn, childLinkFn, node, $node, childScope, childTranscludeFn, i, ii, n;

        // copy nodeList so that linking doesn't break due to live list updates.
        var nodeListLength = nodeList.length,
            stableNodeList = new Array(nodeListLength);
        for (i = 0; i < nodeListLength; i++) {
          stableNodeList[i] = nodeList[i];
        }

        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
          node = stableNodeList[n];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];
          $node = jqLite(node);

          if (nodeLinkFn) {
            if (nodeLinkFn.scope) {
              childScope = scope.$new();
              $node.data('$scope', childScope);
            } else {
              childScope = scope;
            }
            childTranscludeFn = nodeLinkFn.transclude;
            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                createBoundTranscludeFn(scope, childTranscludeFn || transcludeFn)
              );
            } else {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement, boundTranscludeFn);
            }
          } else if (childLinkFn) {
            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
          }
        }
      }
    }

    function createBoundTranscludeFn(scope, transcludeFn) {
      return function boundTranscludeFn(transcludedScope, cloneFn, controllers) {
        var scopeCreated = false;

        if (!transcludedScope) {
          transcludedScope = scope.$new();
          transcludedScope.$$transcluded = true;
          scopeCreated = true;
        }

        var clone = transcludeFn(transcludedScope, cloneFn, controllers);
        if (scopeCreated) {
          clone.on('$destroy', bind(transcludedScope, transcludedScope.$destroy));
        }
        return clone;
      };
    }

    
    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      switch(nodeType) {
        case 1: 
          // use the node name: <directive>
          addDirective(directives,
              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority, ignoreDirective);

          // iterate over the attributes
          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
            var attrStartName = false;
            var attrEndName = false;

            attr = nAttrs[j];
            if (!msie || msie >= 8 || attr.specified) {
              name = attr.name;
              // support ngAttr attribute binding
              ngAttrName = directiveNormalize(name);
              if (NG_ATTR_BINDING.test(ngAttrName)) {
                name = snake_case(ngAttrName.substr(6), '-');
              }

              var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
              if (ngAttrName === directiveNName + 'Start') {
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + 'end';
                name = name.substr(0, name.length - 6);
              }

              nName = directiveNormalize(name.toLowerCase());
              attrsMap[nName] = name;
              attrs[nName] = value = trim(attr.value);
              if (getBooleanAttrName(node, nName)) {
                attrs[nName] = true; // presence means true
              }
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
                            attrEndName);
            }
          }

          // use class as directive
          className = node.className;
          if (isString(className) && className !== '') {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;
        case 3: 
          addTextInterpolateDirective(directives, node.nodeValue);
          break;
        case 8: 
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {
            // turns out that under some circumstances IE9 throws errors when one attempts to read
            // comment's node value.
            // Just ignore it and continue. (Can't seem to reproduce in test case.)
          }
          break;
      }

      directives.sort(byPriority);
      return directives;
    }

    
    function groupScan(node, attrStart, attrEnd) {
      var nodes = [];
      var depth = 0;
      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
        var startNode = node;
        do {
          if (!node) {
            throw $compileMinErr('uterdir',
                      "Unterminated attribute,found '{0}' but no matching '{1}' found.",
                      attrStart, attrEnd);
          }
          if (node.nodeType == 1 ) {
            if (node.hasAttribute(attrStart)) depth++;
            if (node.hasAttribute(attrEnd)) depth--;
          }
          nodes.push(node);
          node = node.nextSibling;
        } while (depth > 0);
      } else {
        nodes.push(node);
      }

      return jqLite(nodes);
    }

    
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
      return function(scope, element, attrs, controllers, transcludeFn) {
        element = groupScan(element[0], attrStart, attrEnd);
        return linkFn(scope, element, attrs, controllers, transcludeFn);
      };
    }

    
    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
                                   previousCompileContext) {;

      var terminalPriority = -Number.MAX_VALUE,
          newScopeDirective,
          controllerDirectives = previousCompileContext.controllerDirectives,
          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
          templateDirective = previousCompileContext.templateDirective,
          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
          hasTranscludeDirective = false,
          hasElementTranscludeDirective = false,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          linkFn,
          directiveValue;

      // executes all directives on the current element
      for(var i = 0, ii = directives.length; i < ii; i++) {
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        // collect multiblock sections
        if (attrStart) {
          $compileNode = groupScan(compileNode, attrStart, attrEnd);
        }
        $template = undefined;

        if (terminalPriority > directive.priority) {
          break; // prevent further processing of directives
        }

        if (directiveValue = directive.scope) {
          newScopeDirective = newScopeDirective || directive;

          // skip the check for directives with async templates, we'll check the derived sync
          // directive when the template arrives
          if (!directive.templateUrl) {
            assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
                              $compileNode);
            if (isObject(directiveValue)) {
              newIsolateScopeDirective = directive;
            }
          }
        }

        directiveName = directive.name;

        if (!directive.templateUrl && directive.controller) {;
          assertNoDuplicate("'" + directiveName + "' controller",
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        }

        if (directiveValue = directive.transclude) {
          hasTranscludeDirective = true;

          // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
          // This option should only be used by directives that know how to how to safely handle element transclusion,
          // where the transcluded nodes are added or replaced after linking.
          if (!directive.$$tlb) {
            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
            nonTlbTranscludeDirective = directive;
          }

          if (directiveValue == 'element') {
            hasElementTranscludeDirective = true;
            terminalPriority = directive.priority;
            $template = groupScan(compileNode, attrStart, attrEnd);
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(' ' + directiveName + ': ' +
                                              templateAttrs[directiveName] + ' '));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name, {
                                          // Don't pass in:
                                          // - controllerDirectives - otherwise we'll create duplicates controllers
                                          // - newIsolateScopeDirective or templateDirective - combining templates with
                                          //   element transclusion doesn't make sense.
                                          //
                                          // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
                                          // on the same element more than once.
                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                        });
          } else {
            $template = jqLite(jqLiteClone(compileNode)).contents();
            $compileNode.empty(); // clear contents
            childTranscludeFn = compile($template, transcludeFn);
          }
        }

        if (directive.template) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          if (directive.replace) {
            replaceDirective = directive;
            $template = jqLite('<div>' +
                                 trim(directiveValue) +
                               '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt',
                  "Template for directive '{0}' must have exactly one root element.{1}",
                  directiveName, '');
            };

            // combine directives from the original node and from the template:
            // - take the array of directives for this element
            // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
            // - collect directives from the template and sort them by priority
            // - combine directives as: processed + template + unprocessed
            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));

            if (newIsolateScopeDirective) {
              markDirectivesAsIsolate(templateDirectives);
            }
            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          } else {
            $compileNode.html(directiveValue);
          }
        }

        if (directive.templateUrl) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          if (directive.replace) {
            replaceDirective = directive;
          }

          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
              templateAttrs, jqCollection, childTranscludeFn, preLinkFns, postLinkFns, {
                controllerDirectives: controllerDirectives,
                newIsolateScopeDirective: newIsolateScopeDirective,
                templateDirective: templateDirective,
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              });
          ii = directives.length;
        } else if (directive.compile) {
          try {
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            if (isFunction(linkFn)) {
              addLinkFns(null, linkFn, attrStart, attrEnd);
            } else if (linkFn) {
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            }
          } catch (e) {
            $exceptionHandler(e, startingTag($compileNode));
          }
        }

        if (directive.terminal) {
          nodeLinkFn.terminal = true;
          terminalPriority = Math.max(terminalPriority, directive.priority);
        }

      }

      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
      nodeLinkFn.transclude = hasTranscludeDirective && childTranscludeFn;

      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
      return nodeLinkFn;

      ////////////////////

      function addLinkFns(pre, post, attrStart, attrEnd) {
        if (pre) {
          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
            pre = cloneAndAnnotateFn(pre, {isolateScope: true});
          }
          preLinkFns.push(pre);
        }
        if (post) {
          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
            post = cloneAndAnnotateFn(post, {isolateScope: true});
          }
          postLinkFns.push(post);
        }
      }


      function getControllers(require, $element, elementControllers) {
        var value, retrievalMethod = 'data', optional = false;
        if (isString(require)) {
          while((value = require.charAt(0)) == '^' || value == '?') {
            require = require.substr(1);
            if (value == '^') {
              retrievalMethod = 'inheritedData';
            }
            optional = optional || value == '?';
          }
          value = null;

          if (elementControllers && retrievalMethod === 'data') {
            value = elementControllers[require];
          }
          value = value || $element[retrievalMethod]('$' + require + 'Controller');

          if (!value && !optional) {
            throw $compileMinErr('ctreq',
                "Controller '{0}',required by directive '{1}',can't be found!",
                require, directiveName);
          }
          return value;
        } else if (isArray(require)) {
          value = [];
          forEach(require, function(require) {
            value.push(getControllers(require, $element, elementControllers));
          });
        }
        return value;
      }


      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {, transcludeFn;

        if (compileNode === linkNode) {
          attrs = templateAttrs;
        } else {
          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
        }
        $element = attrs.$$element;

        if (newIsolateScopeDirective) {
          var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
          var $linkNode = jqLite(linkNode);

          isolateScope = scope.$new(true);

          if (templateDirective && (templateDirective === newIsolateScopeDirective.$$originalDirective)) {
            $linkNode.data('$isolateScope', isolateScope) ;
          } else {
            $linkNode.data('$isolateScopeNoTemplate', isolateScope);
          }



          safeAddClass($linkNode, 'ng-isolate-scope');

          forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                optional = (match[2] == '?'),
                mode = match[1], // @, =, or &
                lastValue,
                parentGet, parentSet, compare;

            isolateScope.$$isolateBindings[scopeName] = mode + attrName;

            switch (mode) {

              case '@':
                attrs.$observe(attrName, function(value) {
                  isolateScope[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = scope;
                if( attrs[attrName] ) {
                  // If the attribute has been provided then we trigger an interpolation to ensure
                  // the value is there for use in the link fn
                  isolateScope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;

              case '=':
                if (optional && !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function(a,b) { return a === b; };
                }
                parentSet = parentGet.assign || function() {' used with directive '{1}' is non-assignable!",
                      attrs[attrName], newIsolateScopeDirective.name);
                };
                lastValue = isolateScope[scopeName] = parentGet(scope);
                isolateScope.$watch(function parentValueWatch() {
                  var parentValue = parentGet(scope);
                  if (!compare(parentValue, isolateScope[scopeName])) {
                    // we are out of sync and need to copy
                    if (!compare(parentValue, lastValue)) {
                      // parent changed and it has precedence
                      isolateScope[scopeName] = parentValue;
                    } else {
                      // if the parent can be assigned then do so
                      parentSet(scope, parentValue = isolateScope[scopeName]);
                    }
                  }
                  return lastValue = parentValue;
                }, null, parentGet.literal);
                break;

              case '&':
                parentGet = $parse(attrs[attrName]);
                isolateScope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;

              default:
                throw $compileMinErr('iscp',
                    "Invalid isolate scope definition for directive '{0}'." +
                    " Definition: {... {1}: '{2}' ...}",
                    newIsolateScopeDirective.name, scopeName, definition);
            }
          });
        }
        transcludeFn = boundTranscludeFn && controllersBoundTransclude;
        if (controllerDirectives) {
          forEach(controllerDirectives, function(directive) {
            var locals = {
              $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
              $element: $element,
              $attrs: attrs,
              $transclude: transcludeFn
            }, controllerInstance;

            controller = directive.controller;
            if (controller == '@') {
              controller = attrs[directive.name];
            }

            controllerInstance = $controller(controller, locals);
            // For directives with element transclusion the element is a comment,
            // but jQuery .data doesn't support attaching data to comment nodes as it's hard to
            // clean up (http://bugs.jquery.com/ticket/8335).
            // Instead, we save the controllers for the element in a local hash and attach to .data
            // later, once we have the actual element.
            elementControllers[directive.name] = controllerInstance;
            if (!hasElementTranscludeDirective) {
              $element.data('$' + directive.name + 'Controller', controllerInstance);
            }

            if (directive.controllerAs) {
              locals.$scope[directive.controllerAs] = controllerInstance;
            }
          });
        }

        // PRELINKING
        for(i = 0, ii = preLinkFns.length; i < ii; i++) {
          try {
            linkFn = preLinkFns[i];
            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // RECURSION
        // We only pass the isolate scope, if the isolate directive has a template,
        // otherwise the child elements do not belong to the isolate directive.
        var scopeToChild = scope;
        if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
          scopeToChild = isolateScope;
        }
        childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);

        // POSTLINKING
        for(i = postLinkFns.length - 1; i >= 0; i--) {
          try {
            linkFn = postLinkFns[i];
            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // This is the function that is injected as `$transclude`.
        function controllersBoundTransclude(scope, cloneAttachFn) {
          var transcludeControllers;

          // no scope passed
          if (arguments.length < 2) {
            cloneAttachFn = scope;
            scope = undefined;
          }

          if (hasElementTranscludeDirective) {
            transcludeControllers = elementControllers;
          }

          return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
        }
      }
    }

    function markDirectivesAsIsolate(directives) {
      // mark all directives as needing isolate scope.
      for (var j = 0, jj = directives.length; j < jj; j++) {
        directives[j] = inherit(directives[j], {$$isolateScope: true});
      }
    }

    
    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
                          endAttrName) {
      if (name === ignoreDirective) return null;
      var match = null;
      if (hasDirectives.hasOwnProperty(name)) {
        for(var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i<ii; i++) {
          try {
            directive = directives[i];
            if ( (maxPriority === undefined || maxPriority > directive.priority) &&
                 directive.restrict.indexOf(location) != -1) {
              if (startAttrName) {
                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});
              }
              tDirectives.push(directive);
              match = directive;
            }
          } catch(e) { $exceptionHandler(e); }
        }
      }
      return match;
    }


    
    function mergeTemplateAttributes(dst, src) {
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      // reapply the old attributes to the new element
      forEach(dst, function(value, key) {
        if (key.charAt(0) != '$') {
          if (src[key]) {
            value += (key === 'style' ? ';' : ' ') + src[key];
          }
          dst.$set(key, value, true, srcAttr[key]);
        }
      });

      // copy the new attributes on the old attrs object
      forEach(src, function(value, key) {
        if (key == 'class') {
          safeAddClass($element, value);
          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
        } else if (key == 'style') {
          $element.attr('style', $element.attr('style') + ';' + value);
          dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
          // `dst` will never contain hasOwnProperty as DOM parser won't let it. // You will get an "InvalidCharacterError: DOM Exception 5" error if you // have an attribute like "has-own-property" or "data-has-own-property",etc.}$compileNode,$rootElement,childTranscludeFn,function compileTemplateUrl(directives,postLinkFns,preLinkFns,previousCompileContext),tAttrs{,),tAttrs):origAsyncDirective.templateUrl;$compileNode.empty();$http.get($sce.getTrustedResourceUrl(templateUrl),templateUrl=(isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode{cache:$templateCache}). success(function(content){:var compileNode,tempTemplateAttrs,$template,childBoundTranscludeFn;:content=denormalizeTemplate(content);:if (origAsyncDirective.replace){$template=jqLite('<div>'+trim(content)+'</div>').contents();:compileNode=$template[0];:if ($template.length!=1 || compileNode.nodeType!==1){throw $compileMinErr('tplrt',"Template for directive '{0}' must have exactly one root element. {1}",origAsyncDirective.name,templateUrl)}tempTemplateAttrs={$compileNode,;replaceWith($rootElement,[],compileNode);var templateDirectives=collectDirectives(compileNode,tempTemplateAttrs);if (isObject(origAsyncDirective.scope)){markDirectivesAsIsolate(templateDirectives)}$compileNode,childTranscludeFn,compileNode,directives.unshift(derivedSyncDirective);afterTemplateNodeLinkFn=applyDirectivesToNode(directives,function(node,i),origAsyncDirective,postLinkFns,preLinkFns,previousCompileContext);forEach($rootElement,tAttrs{if (node==compileNode){$rootElement[i]=$compileNode[0]});afterTemplateChildLinkFn=compileNodes($compileNode[0].childNodes,childTranscludeFn);while(linkQueue.length){:var scope=linkQueue.shift(),beforeTemplateLinkNode=linkQueue.shift(),linkRootElement=linkQueue.shift(),boundTranscludeFn=linkQueue.shift(),linkNode=$compileNode[0];:if (beforeTemplateLinkNode!==beforeTemplateCompileNode){// it was cloned therefore we have to clone as well. linkNode=jqLiteClone(compileNode);:replaceWith(linkRootElement,jqLite(beforeTemplateLinkNode),linkNode)}if (afterTemplateNodeLinkFn.transclude){childBoundTranscludeFn=createBoundTranscludeFn(scope,afterTemplateNodeLinkFn.transclude)}). error(function(response,code,config),headers{throw $compileMinErr('tpload','Failed to load template: {0}',config.url)});return function delayedNodeLinkFn(ignoreChildLinkFn,boundTranscludeFn),node,rootElement,scope{:if (linkQueue){linkQueue.push(scope);:linkQueue.push(node);:linkQueue.push(rootElement);:linkQueue.push(boundTranscludeFn)}b),function byPriority(a{if (a.name!==b.name) return (a.name < b.name) ? -1:1;:return a.index - b.index}directive,element),function assertNoDuplicate(what,previousDirective{if (previousDirective){throw $compileMinErr('multidir','Multiple directives [{0}, {1}] asking for {2} on: {3}',previousDirective.name,directive.name,what,startingTag(element))}function addTextInterpolateDirective(directives,text){if (interpolateFn){directives.push({priority:0,compile:valueFn(function textInterpolateLinkFn(scope,node){var parent=node.parent(),bindings=parent.data('$binding') || [];:bindings.push(interpolateFn);:safeAddClass(parent.data('$binding',bindings),'ng-binding');:scope.$watch(interpolateFn,function interpolateFnWatchAction(value){node[0].nodeValue=value}attrNormalizedName),function getTrustedContext(node{if (attrNormalizedName=="srcdoc"){return $sce.HTML}getTrustedContext(node,name));// if attribute was updated so that there is no interpolation going on we don't want to
                // register any observers
                if (!interpolateFn) return;

                // TODO(i): this should likely be attr.$set(name, iterpolateFn(scope) so that we reset the
                // actual attr value
                attr[name] = interpolateFn(scope);
                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                (attr.$$observers && attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                    //special case for class attribute addition + removal
                    //so that class changes can tap into the animation
                    //hooks provided by the $animate service. Be sure to
                    //skip animations when the first digest occurs (when
                    //both the new and the old values are the same) since
                    //the CSS classes are the non-interpolated values
                    if(name === 'class' && newValue != oldValue) {
                      attr.$updateClass(newValue, oldValue);
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
              }
            };
          }
      });
    }


    
    function replaceWith($rootElement, elementsToRemove, newNode) {
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      if ($rootElement) {
        for(i = 0, ii = $rootElement.length; i < ii; i++) {
          if ($rootElement[i] == firstElementToRemove) {
            $rootElement[i++] = newNode;
            for (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) {
              if (j2 < jj) {
                $rootElement[j] = $rootElement[j2];
              } else {
                delete $rootElement[j];
              }
            }
            $rootElement.length -= removeCount - 1;
            break;
          }
        }
      }

      if (parent) {
        parent.replaceChild(newNode, firstElementToRemove);
      }
      var fragment = document.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);
      newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
        var element = elementsToRemove[k];
        jqLite(element).remove(); // must do this way to clean up expando
        fragment.appendChild(element);
        delete elementsToRemove[k];
      }

      elementsToRemove[0] = newNode;
      elementsToRemove.length = 1;
    }


    function cloneAndAnnotateFn(fn, annotation) {
      return extend(function() { return fn.apply(null, arguments); }, fn, annotation);
    }
  }];
}

var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;

function directiveNormalize(name) {
  return camelCase(name.replace(PREFIX_REGEXP, ''));
}

function tokenDifference(str1, str2) {
  var values = '',
      tokens1 = str1.split(/\s+/),
      tokens2 = str2.split(/\s+/);

  outer:
  for(var i = 0; i < tokens1.length; i++) {
    var token = tokens1[i];
    for(var j = 0; j < tokens2.length; j++) {
      if(token == tokens2[j]) continue outer;
    }
    values += (values.length > 0 ? ' ' : '') + token;
  }
  return values;
}


function $ControllerProvider() {,
      CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;


  
  this.register = function(name, constructor) {
    assertNotHasOwnProperty(name, 'controller');
    if (isObject(name)) {
      extend(controllers, name);
    } else {
      controllers[name] = constructor;
    }
  };


  this.$get = ['$injector', '$window', function($injector, $window) {

    
    return function(expression, locals) {
      var instance, match, constructor, identifier;

      if(isString(expression)) {
        match = expression.match(CNTRL_REG),
        constructor = match[1],
        identifier = match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);

        assertArgFn(expression, constructor, true);
      }

      instance = $injector.instantiate(expression, locals);

      if (identifier) {
        if (!(locals && typeof locals.$scope == 'object')) {
          throw minErr('$controller')('noscp',
              "Cannot export controller ',true,var tag=nodeName_(node);// maction[xlink:href] can source SVG. It's not limited to <maction>.
      if (attrNormalizedName == "xlinkHref" ||
          (tag == "FORM" && attrNormalizedName == "action") ||
          (tag != "IMG" && (attrNormalizedName == "src" ||
                            attrNormalizedName == "ngSrc"))) {
        return $sce.RESOURCE_URL;
      }
    }


    function addAttrInterpolateDirective(node, directives, value, name) {
      var interpolateFn = $interpolate(value, true);

      // no interpolation found -> ignore
      if (!interpolateFn) return;


      if (name === "multiple" && nodeName_(node) === "SELECT") {
        throw $compileMinErr("selmulti",
            "Binding to the 'multiple' attribute is not supported. Element: {0}",
            startingTag(node));
      }

      directives.push({
        priority: 100,
        compile: function() {
            return {
              pre: function attrInterpolatePreLinkFn(scope, element, attr) {));

                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                  throw $compileMinErr('nodomevents',
                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
                          "ng- versions (such as ng-click instead of onclick) instead.");
                }

                // we need to interpolate again, in case the attribute value has been updated
                // (e.g. by another directive's compile function) interpolateFn=$interpolate(attr[name]{0}' as '{1}?\n/,CONTENT_TYPE_APPLICATION_JSON=,'! No $scope object provided via `locals`.",
              constructor || expression.name, identifier);
        }

        locals.$scope[identifier] = instance;
      }

      return instance;
    };
  }];
}


function $DocumentProvider(){
  this.$get = ['$window', function(window){
    return jqLite(window.document);
  }];
}


function $ExceptionHandlerProvider() {
  this.$get = ['$log', function($log) {
    return function(exception, cause) {
      $log.error.apply($log, arguments);
    };
  }];
}


function parseHeaders(headers) {, key, val, i;

  if (!headers) return parsed;

  forEach(headers.split('\n'), function(line) {
    i = line.indexOf(':');
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    if (key) {
      if (parsed[key]) {
        parsed[key] += ',' + val;
      } else {
        parsed[key] = val;
      }
    }
  });

  return parsed;
}



function headersGetter(headers) {
  var headersObj = isObject(headers) ? headers : undefined;

  return function(name) {
    if (!headersObj) headersObj =  parseHeaders(headers);

    if (name) {
      return headersObj[lowercase(name)] || null;
    }

    return headersObj;
  };
}



function transformData(data, headers, fns) {
  if (isFunction(fns))
    return fns(data, headers);

  forEach(fns, function(fn) {
    data = fn(data, headers);
  });

  return data;
}


function isSuccess(status) {
  return 200 <= status && status < 300;
}


function $HttpProvider() {
  var JSON_START = /^\s*(\[|\{[^\{])/,
      JSON_END = /[\}\]]\s*$/,
      PROTECTION_PREFIX = /^\)\]\}'{'Content-Type':'application/json;charset=utf-8'};var defaults=this.defaults={// transform incoming response data transformResponse:[function(data){if (isString(data)){// strip json vulnerability protection prefix data=data.replace(PROTECTION_PREFIX,'');:if (JSON_START.test(data) && JSON_END.test(data)) data=fromJson(data)}// transform outgoing request data transformRequest:[function(d),]{return isObject(d) &&!isFile(d) ? toJson(d):d}// default headers headers:,]{common:{'Accept':'application/json, text/plain, *
  var interceptorFactories = this.interceptors = [];

  
  var responseInterceptorFactories = this.responseInterceptors = [];

  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

    var defaultCache = $cacheFactory('$http');

    
    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory)
          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory)
          ? $injector.get(interceptorFactory)
          : $injector.invoke(interceptorFactory);

      
      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });


    
    function $http(requestConfig) {
      var config = {
        transformRequest: defaults.transformRequest,
        transformResponse: defaults.transformResponse
      };
      var headers = mergeHeaders(requestConfig);

      extend(config, requestConfig);
      config.headers = headers;
      config.method = uppercase(config.method);

      var xsrfValue = urlIsSameOrigin(config.url)
          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
          : undefined;
      if (xsrfValue) {
        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
      }


      var serverRequest = function(config) {
        headers = config.headers;
        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

        // strip content-type if data is undefined
        if (isUndefined(config.data)) {
          forEach(headers, function(value, header) {
            if (lowercase(header) === 'content-type') {
                delete headers[header];
            }
          });
        }

        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
          config.withCredentials = defaults.withCredentials;
        }

        // send request
        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
      };

      var chain = [serverRequest, undefined];
      var promise = $q.when(config);

      // apply interceptors
      forEach(reversedInterceptors, function(interceptor) {
        if (interceptor.request || interceptor.requestError) {
          chain.unshift(interceptor.request, interceptor.requestError);
        }
        if (interceptor.response || interceptor.responseError) {
          chain.push(interceptor.response, interceptor.responseError);
        }
      });

      while(chain.length) {
        var thenFn = chain.shift();
        var rejectFn = chain.shift();

        promise = promise.then(thenFn, rejectFn);
      }

      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      return promise;

      function transformResponse(response) {, response, {
          data: transformData(response.data, response.headers, config.transformResponse)
        });
        return (isSuccess(response.status))
          ? resp
          : $q.reject(resp);
      }

      function mergeHeaders(config) {, defHeaders.common, defHeaders[lowercase(config.method)]);

        // execute if header value is function
        execHeaders(defHeaders);
        execHeaders(reqHeaders);

        // using for-in instead of forEach to avoid unecessary iteration after header has been found
        defaultHeadersIteration:
        for (defHeaderName in defHeaders) {
          lowercaseDefHeaderName = lowercase(defHeaderName);

          for (reqHeaderName in reqHeaders) {
            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
              continue defaultHeadersIteration;
            }
          }

          reqHeaders[defHeaderName] = defHeaders[defHeaderName];
        }

        return reqHeaders;

        function execHeaders(headers) {
          var headerContent;

          forEach(headers, function(headerFn, header) {
            if (isFunction(headerFn)) {
              headerContent = headerFn();
              if (headerContent != null) {
                headers[header] = headerContent;
              } else {
                delete headers[header];
              }
            }
          });
        }
      }
    }

    $http.pendingRequests = [];

    

    

    

    
    createShortMethods('get', 'delete', 'head', 'jsonp');

    

    
    createShortMethodsWithData('post', 'put');

        
    $http.defaults = defaults;


    return $http;


    function createShortMethods(names) {
      forEach(arguments, function(name) {
        $http[name] = function(url, config) {, {
            method: name,
            url: url
          }));
        };
      });
    }


    function createShortMethodsWithData(name) {
      forEach(arguments, function(name) {
        $http[name] = function(url, data, config) {, {
            method: name,
            url: url,
            data: data
          }));
        };
      });
    }


    
    function sendReq(config, reqData, reqHeaders) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          cache,
          cachedResp,
          url = buildUrl(config.url, config.params);

      $http.pendingRequests.push(config);
      promise.then(removePendingReq, removePendingReq);


      if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {
        cache = isObject(config.cache) ? config.cache
              : isObject(defaults.cache) ? defaults.cache
              : defaultCache;
      }

      if (cache) {
        cachedResp = cache.get(url);
        if (isDefined(cachedResp)) {
          if (cachedResp.then) {
            // cached request has already been sent, but there is no response yet
            cachedResp.then(removePendingReq, removePendingReq);
            return cachedResp;
          } else {
            // serving from cache
            if (isArray(cachedResp)) {
              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
            } else {);
            }
          }
        } else {
          // put the promise for the non-transformed response into cache as a placeholder
          cache.put(url, promise);
        }
      }

      // if we won't have the response in cache,send the request to the backend if (isUndefined(cachedResp)){$httpBackend(config.method,url,reqData,done,reqHeaders,config.timeout,config.withCredentials,config.responseType)}headersString),response,return promise;function done(status{if (cache){if (isSuccess(status)){cache.put(url,[status,response,parseHeaders(headersString)])}function resolvePromise(response,headers),status{:// normalize internal statuses to 0 status=Math.max(status,0);(isSuccess(status) ? deferred.resolve :deferred.reject)({data:response,status:status,headers:headersGetter(headers),config:config}function removePendingReq(){:var idx=indexOf($http.pendingRequests,config);:if (idx!==-1) $http.pendingRequests.splice(idx,1)}function buildUrl(url,params){:if (!params) return url;:var parts=[];:forEachSorted(params,function(value,key){if (value===null || isUndefined(value)) return;:if (!isArray(value)) value=[value];:forEach(value,function(v){if (isObject(v)){v=toJson(v)}var XHR=window.XMLHttpRequest || function(){try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")};function $HttpBackendProvider(){this.$get=['$browser','$window','$document',function($browser,$window,$document){return createHttpBackend($browser,XHR,$browser.defer,$window.angular.callbacks,$document[0])}$browserDefer,XHR,callbacks,function createHttpBackend($browser,rawDocument){// TODO(vojta):fix the signature return function(method,url,post,callback,headers,timeout,withCredentials,responseType){var status;:$browser.$$incOutstandingRequestCount();:url=url || $browser.url();:if (lowercase(method)=='jsonp'){var callbackId='_'+(callbacks.counter++).toString(36);:callbacks[callbackId]=function(data){callbacks[callbackId].data=data};var jsonpDone=jsonpReq(url.replace('JSON_CALLBACK','angular.callbacks.'+callbackId),function(){if (callbacks[callbackId].data){completeRequest(callback,200,callbacks[callbackId].data)});// In IE6 and 7,this might be called synchronously when xhr.send below is called and the // response is in the cache. the promise api will ensure that to the app code the api is // always async xhr.onreadystatechange=function(){:if (xhr.readyState==4){var responseHeaders=null,response=null;:if(status!==ABORTED){responseHeaders=xhr.getAllResponseHeaders();response=xhr.responseType ? xhr.response:xhr.responseText};if (withCredentials){xhr.withCredentials=true}if (responseType){xhr.responseType=responseType}if (timeout>0){var timeoutId=$browserDefer(timeoutRequest,timeout)}else if (timeout && timeout.then){timeout.then(timeoutRequest)}function timeoutRequest(){:status=ABORTED;:jsonpDone && jsonpDone();:xhr && xhr.abort()}function completeRequest(callback,headersString),response,status{// fix status code for file protocol (it's always 0)
      status = (protocol == 'file' && status === 0) ? (response ? 200 : 404) : status;

      // normalize IE bug (http://bugs.jquery.com/ticket/1450)
      status = status == 1223 ? 204 : status;

      callback(status, response, headersString);
      $browser.$$completeOutstandingRequest(noop);
    }
  };

  function jsonpReq(url, done) {
    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements,e.g.:// - fetches local scripts via XHR and evals them // - adds and immediately removes script elements from the document var script=rawDocument.createElement('script'),doneWrapper=function(){script.onreadystatechange=script.onload=script.onerror=null;:rawDocument.body.removeChild(script);:if (done) done()};script.type='text/javascript';script.src=url;if (msie && msie <=8){script.onreadystatechange=function(){if (/loaded|complete/.test(script.readyState)){doneWrapper()}var $interpolateMinErr=minErr('$interpolate');function $InterpolateProvider(){:var startSymbol='{{';:var endSymbol='}}';:this.startSymbol=function(value){if (value){startSymbol=value;:return this};this.endSymbol=function(value){:if (value){endSymbol=value;:return this}$exceptionHandler,$sce),;this.$get=['$parse','$exceptionHandler','$sce',function($parse{:var startSymbolLength=startSymbol.length,endSymbolLength=endSymbol.length;:function $interpolate(text,mustHaveExpression,trustedContext){var startIndex,endIndex,index=0,parts=[],length=text.length,hasInterpolation=false,fn,exp,concat=[];:while(index < length){if (((startIndex=text.indexOf(startSymbol,index))!=-1) && ((endIndex=text.indexOf(endSymbol,startIndex+startSymbolLength))!=-1)){(index!=startIndex) && parts.push(text.substring(index,startIndex));:parts.push(fn=$parse(exp=text.substring(startIndex+startSymbolLength,endIndex)));:fn.exp=exp;:index=endIndex+endSymbolLength;:hasInterpolation=true}if (!(length=parts.length)){:// we added,nothing,must have been an empty string. parts.push('');:length=1}// Concatenating expressions makes it hard to reason about whether some combination of // concatenated values are unsafe to use and could easily lead to XSS. By requiring that a // single expression be used for iframe[src],etc.,object[src],we ensure that the value // that's used is assigned or constructed by some JS code somewhere that is more testable or
      // make it obvious that you bound the value to some user controlled value.  This helps reduce
      // the load when auditing for XSS issues.
      if (trustedContext && parts.length > 1) {
          throw $interpolateMinErr('noconcat',
              "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
              "interpolations that concatenate multiple expressions when a trusted value is " +
              "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      }

      if (!mustHaveExpression  || hasInterpolation) {
        concat.length = length;
        fn = function(context) {
          try {
            for(var i = 0, ii = length, part; i<ii; i++) {
              if (typeof (part = parts[i]) == 'function') {
                part = part(context);
                if (trustedContext) {
                  part = $sce.getTrusted(trustedContext, part);
                } else {
                  part = $sce.valueOf(part);
                }
                if (part === null || isUndefined(part)) {
                  part = '';
                } else if (typeof part != 'string') {
                  part = toJson(part);
                }
              }
              concat[i] = part;
            }
            return concat.join('');
          }
          catch(err) {
            var newErr = $interpolateMinErr('interr', "Can't interpolate:{0}\n{1}", text,
                err.toString());
            $exceptionHandler(newErr);
          }
        };
        fn.exp = text;
        fn.parts = parts;
        return fn;
      }
    }


    
    $interpolate.startSymbol = function() {
      return startSymbol;
    };


    
    $interpolate.endSymbol = function() {
      return endSymbol;
    };

    return $interpolate;
  }];
}

function $IntervalProvider() {
  this.$get = ['$rootScope', '$window', '$q',
       function($rootScope,   $window,   $q) {;


     
    function interval(fn, delay, count, invokeApply) {
      var setInterval = $window.setInterval,
          clearInterval = $window.clearInterval,
          deferred = $q.defer(),
          promise = deferred.promise,
          iteration = 0,
          skipApply = (isDefined(invokeApply) && !invokeApply);
      
      count = isDefined(count) ? count : 0,

      promise.then(null, null, fn);

      promise.$$intervalId = setInterval(function tick() {
        deferred.notify(iteration++);

        if (count > 0 && iteration >= count) {
          deferred.resolve(iteration);
          clearInterval(promise.$$intervalId);
          delete intervals[promise.$$intervalId];
        }

        if (!skipApply) $rootScope.$apply();

      }, delay);

      intervals[promise.$$intervalId] = deferred;

      return promise;
    }


     
    interval.cancel = function(promise) {
      if (promise && promise.$$intervalId in intervals) {
        intervals[promise.$$intervalId].reject('canceled');
        clearInterval(promise.$$intervalId);
        delete intervals[promise.$$intervalId];
        return true;
      }
      return false;
    };

    return interval;
  }];
}


function $LocaleProvider(){
  this.$get = function() {
    return {
      id: 'en-us',

      NUMBER_FORMATS: {
        DECIMAL_SEP: '.',
        GROUP_SEP: ',',
        PATTERNS: [
          { // Decimal Pattern
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: '',
            posSuf: '',
            negPre: '-',
            negSuf: '',
            gSize: 3,
            lgSize: 3
          },{ //Currency Pattern
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: '\u00A4',
            posSuf: '',
            negPre: '(\u00A4',
            negSuf: ')',
            gSize: 3,
            lgSize: 3
          }
        ],
        CURRENCY_SYM: '$'
      },

      DATETIME_FORMATS: {
        MONTH:
            'January,February,March,April,May,June,July,August,September,October,November,December'
            .split(','),
        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
        AMPMS: ['AM','PM'],
        medium: 'MMM d, y h:mm:ss a',
        short: 'M/d/yy h:mm a',
        fullDate: 'EEEE, MMMM d, y',
        longDate: 'MMMM d, y',
        mediumDate: 'MMM d, y',
        shortDate: 'M/d/yy',
        mediumTime: 'h:mm:ss a',
        shortTime: 'h:mm a'
      },

      pluralCat: function(num) {
        if (num === 1) {
          return 'one';
        }
        return 'other';
      }
    };
  };
}

var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
var $locationMinErr = minErr('$location');



function encodePath(path) {
  var segments = path.split('/'),
      i = segments.length;

  while (i--) {
    segments[i] = encodeUriSegment(segments[i]);
  }

  return segments.join('/');
}

function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
  var parsedUrl = urlResolve(absoluteUrl, appBase);

  locationObj.$$protocol = parsedUrl.protocol;
  locationObj.$$host = parsedUrl.hostname;
  locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
}


function parseAppUrl(relativeUrl, locationObj, appBase) {
  var prefixed = (relativeUrl.charAt(0) !== '/');
  if (prefixed) {
    relativeUrl = '/' + relativeUrl;
  }
  var match = urlResolve(relativeUrl, appBase);
  locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?
      match.pathname.substring(1) : match.pathname);
  locationObj.$$search = parseKeyValue(match.search);
  locationObj.$$hash = decodeURIComponent(match.hash);

  // make sure path starts with '/';
  if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
    locationObj.$$path = '/' + locationObj.$$path;
  }
}



function beginsWith(begin, whole) {
  if (whole.indexOf(begin) === 0) {
    return whole.substr(begin.length);
  }
}


function stripHash(url) {
  var index = url.indexOf('#');
  return index == -1 ? url : url.substr(0, index);
}


function stripFile(url) {
  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
}


function serverBase(url) {
  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
}



function LocationHtml5Url(appBase, basePrefix) {
  this.$$html5 = true;
  basePrefix = basePrefix || '';
  var appBaseNoFile = stripFile(appBase);
  parseAbsoluteUrl(appBase, this, appBase);


  
  this.$$parse = function(url) {
    var pathUrl = beginsWith(appBaseNoFile, url);
    if (!isString(pathUrl)) {
      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
          appBaseNoFile);
    }

    parseAppUrl(pathUrl, this, appBase);

    if (!this.$$path) {
      this.$$path = '/';
    }

    this.$$compose();
  };

  
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
  };

  this.$$rewrite = function(url) {
    var appUrl, prevAppUrl;

    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {
      prevAppUrl = appUrl;
      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {
        return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
      } else {
        return appBase + prevAppUrl;
      }
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {
      return appBaseNoFile + appUrl;
    } else if (appBaseNoFile == url + '/') {
      return appBaseNoFile;
    }
  };
}



function LocationHashbangUrl(appBase, hashPrefix) {
  var appBaseNoFile = stripFile(appBase);

  parseAbsoluteUrl(appBase, this, appBase);


  
  this.$$parse = function(url) {
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'
        ? beginsWith(hashPrefix, withoutBaseUrl)
        : (this.$$html5)
          ? withoutBaseUrl
          : '';

    if (!isString(withoutHashUrl)) {
      throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash prefix "{1}".', url,
          hashPrefix);
    }
    parseAppUrl(withoutHashUrl, this, appBase);

    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);

    this.$$compose();

    
    function removeWindowsDriveName (path, url, base) {
      
      var windowsFilePathExp = /^\/?.*?:(\/.*)/;

      var firstPathSegmentMatch;

      //Get the relative path from the input URL.
      if (url.indexOf(base) === 0) {
        url = url.replace(base, '');
      }

      
      if (windowsFilePathExp.exec(url)) {
        return path;
      }

      firstPathSegmentMatch = windowsFilePathExp.exec(path);
      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
    }
  };

  
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
  };

  this.$$rewrite = function(url) {
    if(stripHash(appBase) == stripHash(url)) {
      return url;
    }
  };
}



function LocationHashbangInHtml5Url(appBase, hashPrefix) {
  this.$$html5 = true;
  LocationHashbangUrl.apply(this, arguments);

  var appBaseNoFile = stripFile(appBase);

  this.$$rewrite = function(url) {
    var appUrl;

    if ( appBase == stripHash(url) ) {
      return url;
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {
      return appBase + hashPrefix + appUrl;
    } else if ( appBaseNoFile === url + '/') {
      return appBaseNoFile;
    }
  };
}


LocationHashbangInHtml5Url.prototype =
  LocationHashbangUrl.prototype =
  LocationHtml5Url.prototype = {

  
  $$html5: false,

  
  $$replace: false,

  
  absUrl: locationGetter('$$absUrl'),

  
  url: function(url, replace) {
    if (isUndefined(url))
      return this.$$url;

    var match = PATH_MATCH.exec(url);
    if (match[1]) this.path(decodeURIComponent(match[1]));
    if (match[2] || match[1]) this.search(match[3] || '');
    this.hash(match[5] || '', replace);

    return this;
  },

  
  protocol: locationGetter('$$protocol'),

  
  host: locationGetter('$$host'),

  
  port: locationGetter('$$port'),

  
  path: locationGetterSetter('$$path', function(path) {
    return path.charAt(0) == '/' ? path : '/' + path;
  }),

  
  search: function(search, paramValue) {
    switch (arguments.length) {
      case 0:
        return this.$$search;
      case 1:
        if (isString(search)) {
          this.$$search = parseKeyValue(search);
        } else if (isObject(search)) {
          this.$$search = search;
        } else {
          throw $locationMinErr('isrcharg',
              'The first argument of the `$location#search()` call must be a string or an object.');
        }
        break;
      default:
        if (isUndefined(paramValue) || paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
    }

    this.$$compose();
    return this;
  },

  
  hash: locationGetterSetter('$$hash', identity),

  
  replace: function() {
    this.$$replace = true;
    return this;
  }
};

function locationGetter(property) {
  return function() {
    return this[property];
  };
}


function locationGetterSetter(property, preprocess) {
  return function(value) {
    if (isUndefined(value))
      return this[property];

    this[property] = preprocess(value);
    this.$$compose();

    return this;
  };
}





function $LocationProvider(){
  var hashPrefix = '',
      html5Mode = false;

  
  this.hashPrefix = function(prefix) {
    if (isDefined(prefix)) {
      hashPrefix = prefix;
      return this;
    } else {
      return hashPrefix;
    }
  };

  
  this.html5Mode = function(mode) {
    if (isDefined(mode)) {
      html5Mode = mode;
      return this;
    } else {
      return html5Mode;
    }
  };

  

  

  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
      function( $rootScope,   $browser,   $sniffer,   $rootElement) {
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
        initialUrl = $browser.url(),
        appBase;

    if (html5Mode) {
      appBase = serverBase(initialUrl) + (baseHref || '/');
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    } else {
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    }
    $location = new LocationMode(appBase, '#' + hashPrefix);
    $location.$$parse($location.$$rewrite(initialUrl));

    $rootElement.on('click', function(event) {
      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
      // currently we open nice url link and redirect then

      if (event.ctrlKey || event.metaKey || event.which == 2) return;

      var elm = jqLite(event.target);

      // traverse the DOM up to find first A tag
      while (lowercase(elm[0].nodeName) !== 'a') {
        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
      }

      var absHref = elm.prop('href');

      if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
        // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
        // an animation.
        absHref = urlResolve(absHref.animVal).href;
      }

      var rewrittenUrl = $location.$$rewrite(absHref);

      if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {
        event.preventDefault();
        if (rewrittenUrl != $browser.url()) {
          // update location manually
          $location.$$parse(rewrittenUrl);
          $rootScope.$apply();
          // hack to work around FF6 bug 684208 when scenario runner clicks on links
          window.angular['ff-684208-preventDefault'] = true;
        }
      }
    });


    // rewrite hashbang url <> html5 url
    if ($location.absUrl() != initialUrl) {
      $browser.url($location.absUrl(), true);
    }

    // update $location when $browser url changes
    $browser.onUrlChange(function(newUrl) {
      if ($location.absUrl() != newUrl) {
        if ($rootScope.$broadcast('$locationChangeStart', newUrl,
                                  $location.absUrl()).defaultPrevented) {
          $browser.url($location.absUrl());
          return;
        }
        $rootScope.$evalAsync(function() {
          var oldUrl = $location.absUrl();

          $location.$$parse(newUrl);
          afterLocationChange(oldUrl);
        });
        if (!$rootScope.$$phase) $rootScope.$digest();
      }
    });

    // update browser
    var changeCounter = 0;
    $rootScope.$watch(function $locationWatch() {
      var oldUrl = $browser.url();
      var currentReplace = $location.$$replace;

      if (!changeCounter || oldUrl != $location.absUrl()) {
        changeCounter++;
        $rootScope.$evalAsync(function() {
          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).
              defaultPrevented) {
            $location.$$parse(oldUrl);
          } else {
            $browser.url($location.absUrl(), currentReplace);
            afterLocationChange(oldUrl);
          }
        });
      }
      $location.$$replace = false;

      return changeCounter;
    });

    return $location;

    function afterLocationChange(oldUrl) {
      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
    }
}];
}




function $LogProvider(){
  var debug = true,
      self = this;
  
  
  this.debugEnabled = function(flag) {
    if (isDefined(flag)) {
      debug = flag;
    return this;
    } else {
      return debug;
    }
  };
  
  this.$get = ['$window', function($window){
    return {
      
      log: consoleLog('log'),

      
      info: consoleLog('info'),

      
      warn: consoleLog('warn'),

      
      error: consoleLog('error'),
      
      
      debug: (function () {
        var fn = consoleLog('debug');

        return function() {
          if (debug) {
            fn.apply(self, arguments);
          }
        };
      }())
    };

    function formatError(arg) {
      if (arg instanceof Error) {
        if (arg.stack) {
          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
              ? 'Error: ' + arg.message + '\n' + arg.stack
              : arg.stack;
        } else if (arg.sourceURL) {
          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
        }
      }
      return arg;
    }

    function consoleLog(type) {,
          logFn = console[type] || console.log || noop,
          hasApply = false;

      // Note: reading logFn.apply throws an error in IE11 in IE8 document mode.
      // The reason behind this is that console.log has type "object" in IE8...
      try {
        hasApply = !! logFn.apply;
      }

      if (hasApply) {
        return function() {
          var args = [];
          forEach(arguments, function(arg) {
            args.push(formatError(arg));
          });
          return logFn.apply(console, args);
        };
      }

      // we are IE which either doesn't have window.console => this is noop and we do nothing,
      // or we are IE where console.log doesn't have apply so we log at least first 2 args
      return function(arg1, arg2) {
        logFn(arg1, arg2 == null ? '' : arg2);
      };
    }
  }];
}.toString.constructor(alert("evil JS code"))
//
// We want to prevent this type of access. For the sake of performance, during the lexing phase we
// disallow any "dotted" access to any member named "constructor".
//
// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor
// while evaluating the expression, which is a stronger but more expensive test. Since reflective
// calls are expensive anyway, this is not such a big deal compared to static dereferencing.
//
// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits
// against the expression language, but not to prevent exploits that were enabled by exposing
// sensitive JavaScript or browser apis on Scope. Exposing such objects on a Scope is never a good
// practice and therefore we are not even trying to protect against interaction with an object
// explicitly exposed in this way.
//
// A developer could foil the name check by aliasing the Function constructor under a different
// name on the scope.
//
// In general, it is not possible to access a Window object from an angular expression unless a
// window or some DOM object that has a reference to window is published onto a Scope.

function ensureSafeMemberName(name, fullExpression) {
  if (name === "constructor") {
    throw $parseMinErr('isecfld',
        'Referencing "constructor" field in Angular expressions is disallowed! Expression: {0}',
        fullExpression);
  }
  return name;
}

function ensureSafeObject(obj, fullExpression) {
  // nifty check if obj is Function that is fast and works across iframes and other contexts
  if (obj) {
    if (obj.constructor === obj) {
      throw $parseMinErr('isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
    } else if (// isWindow(obj)
        obj.document && obj.location && obj.alert && obj.setInterval) {
      throw $parseMinErr('isecwindow',
          'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
    } else if (// isElement(obj)
        obj.children && (obj.nodeName || (obj.on && obj.find))) {
      throw $parseMinErr('isecdom',
          'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
    }
  }
  return obj;
}

var OPERATORS = {
    
    'null':function(){return null;},
    'true':function(){return true;},
    'false':function(){return false;},
    undefined:noop,
    '+':function(self, locals, a,b){
      a=a(self, locals); b=b(self, locals);
      if (isDefined(a)) {
        if (isDefined(b)) {
          return a + b;
        }
        return a;
      }
      return isDefined(b)?b:undefined;},
    '-':function(self, locals, a,b){
          a=a(self, locals); b=b(self, locals);
          return (isDefined(a)?a:0)-(isDefined(b)?b:0);
        },
    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},
    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},
    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},
    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},
    '=':noop,
    '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},
    '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},
    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},
    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},
    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},
    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},
    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},
    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},
    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},
    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},
//    '|':function(self, locals, a,b){return a|b;},
    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
    '!':function(self, locals, a){return !a(self, locals);}
};

var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};


/////////////////////////////////////////



var Lexer = function (options) {
  this.options = options;
};

Lexer.prototype = {
  constructor: Lexer,

  lex: function (text) {
    this.text = text;

    this.index = 0;
    this.ch = undefined;
    this.lastCh = ':'; // can start regexp

    this.tokens = [];

    var token;
    var json = [];

    while (this.index < this.text.length) {
      this.ch = this.text.charAt(this.index);
      if (this.is('"\'')){this.readString(this.ch)}else if (this.isNumber(this.ch) || this.is('.') && this.isNumber(this.peek())){this.readNumber()}else if (this.isIdent(this.ch)){:this.readIdent();:// identifiers can only be if the preceding char was a{or,if (this.was('{,') && json[0]==='{' && (token=this.tokens[this.tokens.length - 1])){token.json=token.text.indexOf('.')===-1}[].,;:?')){this.tokens.push({index:this.index,text:this.ch,json:(this.was(':[,') && this.is('{[')) || this.is('}]:,')}else if (this.isWhitespace(this.ch)){:this.index++;:continue}else if (fn2){this.tokens.push({index:this.index,text:ch2,fn:fn2}else if (fn){this.tokens.push({index:this.index,text:this.ch,fn:fn,json:(this.was('[,:') && this.is('+-'))},is:function(chars){return chars.indexOf(this.ch)!==-1},was:function(chars){return chars.indexOf(this.lastCh)!==-1},peek:function(i){:var num=i || 1;return (this.index+num < this.text.length) ? this.text.charAt(this.index+num):false},isNumber:function(ch){return ('0' <=ch && ch <='9')},isWhitespace:function(ch){// IE treats non-breaking space as \u00A0 return (ch===' ' || ch==='\r' || ch==='\t' || ch==='\n' || ch==='\v' || ch==='\u00A0')},isIdent:function(ch){return ('a' <=ch && ch <='z' || 'A' <=ch && ch <='Z' || '_'===ch || ch==='$')},isExpOperator:function(ch){return (ch==='-' || ch==='+' || this.isNumber(ch))},end),start,throwError:function(error{var colStr=(isDefined(start) ? 's '+start+'-'+this.index+' ['+this.text.substring(start,end)+']':' '+end);:throw $parseMinErr('lexerr','Lexer Error: {0} at column{1} in expression [{2}].',error,colStr,this.text)},readNumber:function(){:var number='';:var start=this.index;:while (this.index < this.text.length){var ch=lowercase(this.text.charAt(this.index));:if (ch=='.' || this.isNumber(ch)){number +=ch}else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1)=='e'){number +=ch}else if (this.isExpOperator(ch) && (!peekCh ||!this.isNumber(peekCh)) && number.charAt(number.length - 1)=='e'){this.throwError('Invalid exponent')}number=1 * number;this.tokens.push({index:start,text:number,json:true,fn:function(){return number},readIdent:function(){:var parser=this;:var ident='';:var start=this.index;:var lastDot,peekIndex,methodName,ch;:while (this.index < this.text.length){ch=this.text.charAt(this.index);:if (ch==='.' || this.isIdent(ch) || this.isNumber(ch)){if (ch==='.') lastDot=this.index;:ident +=ch}//check if this is not a method invocation and if it is back out to last dot if (lastDot){:peekIndex=this.index;:while (peekIndex < this.text.length){ch=this.text.charAt(peekIndex);:if (ch==='('){methodName=ident.substr(lastDot - start+1);:ident=ident.substr(0,lastDot - start);:this.index=peekIndex;:break}if (this.isWhitespace(ch)){peekIndex++}var token={index:start,text:ident};// OPERATORS is our own object so we don't need to use special hasOwnPropertyFn
    if (OPERATORS.hasOwnProperty(ident)) {
      token.fn = OPERATORS[ident];
      token.json = OPERATORS[ident];
    } else {
      var getter = getterFn(ident, this.options, this.text);
      token.fn = extend(function(self, locals) {
        return (getter(self, locals));
      }, {
        assign: function(self, value) {
          return setter(self, ident, value, parser.text, parser.options);
        }
      });
    }

    this.tokens.push(token);

    if (methodName) {
      this.tokens.push({
        index:lastDot,
        text: '.',
        json: false
      });
      this.tokens.push({
        index: lastDot + 1,
        text: methodName,
        json: false
      });
    }
  },

  readString: function(quote) {
    var start = this.index;
    this.index++;
    var string = '';
    var rawString = quote;
    var escape = false;
    while (this.index < this.text.length) {
      var ch = this.text.charAt(this.index);
      rawString += ch;
      if (escape) {
        if (ch === 'u') {
          var hex = this.text.substring(this.index + 1, this.index + 5);
          if (!hex.match(/[\da-f]{4}/i))
            this.throwError('Invalid unicode escape [\\u' + hex + ']');
          this.index += 4;
          string += String.fromCharCode(parseInt(hex, 16));
        } else {
          var rep = ESCAPE[ch];
          if (rep) {
            string += rep;
          } else {
            string += ch;
          }
        }
        escape = false;
      } else if (ch === '\\') {
        escape = true;
      } else if (ch === quote) {
        this.index++;
        this.tokens.push({
          index: start,
          text: rawString,
          string: string,
          json: true,
          fn: function() { return string; }
        });
        return;
      } else {
        string += ch;
      }
      this.index++;
    }
    this.throwError('Unterminated quote', start);
  }
};



var Parser = function (lexer, $filter, options) {
  this.lexer = lexer;
  this.$filter = $filter;
  this.options = options;
};

Parser.ZERO = function () { return 0; };

Parser.prototype = {
  constructor: Parser,

  parse: function (text, json) {
    this.text = text;

    //TODO(i): strip all the obsolte json stuff from this file
    this.json = json;

    this.tokens = this.lexer.lex(text);

    if (json) {
      // The extra level of aliasing is here, just in case the lexer misses something, so that
      // we prevent any accidental execution in JSON.
      this.assignment = this.logicalOR;

      this.functionCall =
      this.fieldAccess =
      this.objectIndex =
      this.filterChain = function() {
        this.throwError('is not valid json', {text: text, index: 0});
      };
    }

    var value = json ? this.primary() : this.statements();

    if (this.tokens.length !== 0) {
      this.throwError('is an unexpected token', this.tokens[0]);
    }

    value.literal = !!value.literal;
    value.constant = !!value.constant;

    return value;
  },

  primary: function () {
    var primary;
    if (this.expect('(')) {
      primary = this.filterChain();
      this.consume(')');
    } else if (this.expect('[')) {
      primary = this.arrayDeclaration();
    } else if (this.expect('{')) {
      primary = this.object();
    } else {
      var token = this.expect();
      primary = token.fn;
      if (!primary) {
        this.throwError('not a primary expression', token);
      }
      if (token.json) {
        primary.constant = true;
        primary.literal = true;
      }
    }

    var next, context;
    while ((next = this.expect('(', '[', '.'))) {
      if (next.text === '(') {
        primary = this.functionCall(primary, context);
        context = null;
      } else if (next.text === '[') {
        context = primary;
        primary = this.objectIndex(primary);
      } else if (next.text === '.') {
        context = primary;
        primary = this.fieldAccess(primary);
      } else {
        this.throwError('IMPOSSIBLE');
      }
    }
    return primary;
  },

  throwError: function(msg, token) {
    throw $parseMinErr('syntax',
        'Syntax Error:Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',token.text,msg,(token.index+1),this.text,this.text.substring(token.index))},peekToken:function(){:if (this.tokens.length===0) throw $parseMinErr('ueoe','Unexpected end of expression: {0}',this.text);:return this.tokens[0]},e2,e3,e4),peek:function(e1{:if (this.tokens.length>0){var token=this.tokens[0];:var t=token.text;:if (t===e1 || t===e2 || t===e3 || t===e4 || (!e1 &&!e2 &&!e3 &&!e4)){return token},e2,e3,e4),expect:function(e1{:var token=this.peek(e1,e2,e3,e4);:if (token){if (this.json &&!token.json){this.throwError('is not valid json',token)},consume:function(e1){if (!this.expect(e1)){this.throwError('is unexpected, expecting ['+e1+']',this.peek())},right),unaryFn:function(fn{return extend(function(self,locals){return fn(self,locals,right)},middle,right),ternaryFn:function(left{return extend(function(self,locals){return left(self,locals) ? middle(self,locals):right(self,locals)},binaryFn:function(left,fn,right){return extend(function(self,locals){return fn(self,locals,left,right)},statements:function(){if (!this.expect(';')){// optimize for the common case where there is only one statement. // TODO(size):maybe we should not support multiple statements? return (statements.length===1) ? statements[0] :function(self,locals){var value;:for (var i=0;:i < statements.length;:i++){var statement=statements[i];:if (statement){value=statement(self,locals)},filterChain:function(){:var left=this.expression();:var token;:while (true){if ((token=this.expect('|'))){left=this.binaryFn(left,token.fn,this.filter())},filter:function(){:var token=this.expect();:var fn=this.$filter(token.text);:var argsFn=[];:while (true){if ((token=this.expect(':'))){argsFn.push(this.expression())};return function(){return fnInvoke},expression:function(){return this.assignment()},assignment:function(){:var left=this.ternary();:var right;:var token;:if ((token=this.expect('='))){if (!left.assign){this.throwError('implies assignment but ['+this.text.substring(0,token.index)+'] can not be assigned to',token)}locals),right=this.ternary();return function(scope{return left.assign(scope,right(scope,locals),locals)},ternary:function(){:var left=this.logicalOR();:var middle;:var token;:if ((token=this.expect('?'))){middle=this.ternary();:if ((token=this.expect(':'))){return this.ternaryFn(left,middle,this.ternary())},logicalOR:function(){:var left=this.logicalAND();:var token;:while (true){if ((token=this.expect('||'))){left=this.binaryFn(left,token.fn,this.logicalAND())},logicalAND:function(){:var left=this.equality();:var token;:if ((token=this.expect('&&'))){left=this.binaryFn(left,token.fn,this.logicalAND())},equality:function(){:var left=this.relational();:var token;:if ((token=this.expect('==','!=','===','!=='))){left=this.binaryFn(left,token.fn,this.equality())},relational:function(){:var left=this.additive();:var token;:if ((token=this.expect('<','>','<=','>='))){left=this.binaryFn(left,token.fn,this.relational())},additive:function(){:var left=this.multiplicative();:var token;:while ((token=this.expect('+','-'))){left=this.binaryFn(left,token.fn,this.multiplicative())},multiplicative:function(){:var left=this.unary();:var token;:while ((token=this.expect('*','/','%'))){left=this.binaryFn(left,token.fn,this.unary())},unary:function(){:var token;:if (this.expect('+')){return this.primary()}else if ((token=this.expect('-'))){return this.binaryFn(Parser.ZERO,token.fn,this.unary())}else if ((token=this.expect('!'))){return this.unaryFn(token.fn,this.unary())},fieldAccess:function(object){:var parser=this;:var field=this.expect().text;:var getter=getterFn(field,this.options,this.text);:return extend(function(scope,locals,self){return getter(self || object(scope,locals),locals)},objectIndex:function(obj){:var parser=this;:var indexFn=this.expression();:this.consume(']');:return extend(function(self,locals){var o=obj(self,locals),i=indexFn(self,locals),v,p;:if (!o) return undefined;:v=ensureSafeObject(o[i],parser.text);:if (v && v.then && parser.options.unwrapPromises){p=v;:if (!('$$v' in v)){p.$$v=undefined;:p.then(function(val){p.$$v=val},contextGetter),functionCall:function(fn{:var argsFn=[];:if (this.peekToken().text!==')'){do{argsFn.push(this.expression())}locals),this.consume(')');var parser=this;return function(scope{var context=contextGetter ? contextGetter(scope,locals):scope;:for (var i=0;:i < argsFn.length;:i++){args.push(argsFn[i](scope,locals))}');

    return extend(function(self, locals) {;
      for (var i = 0; i < keyValues.length; i++) {
        var keyValue = keyValues[i];
        object[keyValue.key] = keyValue.value(self, locals);
      }
      return object;
    }, {
      literal: true,
      constant: allConstant
    });
  }
};


//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

function setter(obj, path, setValue, fullExp, options) {;

  var element = path.split('.'), key;
  for (var i = 0; element.length > 1; i++) {
    key = ensureSafeMemberName(element.shift(), fullExp);
    var propertyObj = obj[key];
    if (!propertyObj) {;
      obj[key] = propertyObj;
    }
    obj = propertyObj;
    if (obj.then && options.unwrapPromises) {
      promiseWarning(fullExp);
      if (!("$$v" in obj)) {
        (function(promise) {
          promise.then(function(val) { promise.$$v = val; }); }
        )(obj);
      }
      if (obj.$$v === undefined) {;
      }
      obj = obj.$$v;
    }
  }
  key = ensureSafeMemberName(element.shift(), fullExp);
  obj[key] = setValue;
  return setValue;
};


function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);
  ensureSafeMemberName(key2, fullExp);
  ensureSafeMemberName(key3, fullExp);
  ensureSafeMemberName(key4, fullExp);

  return !options.unwrapPromises
      ? function cspSafeGetter(scope, locals) {
          var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope;

          if (pathVal == null) return pathVal;
          pathVal = pathVal[key0];

          if (pathVal == null) return key1 ? undefined : pathVal;
          pathVal = pathVal[key1];

          if (pathVal == null) return key2 ? undefined : pathVal;
          pathVal = pathVal[key2];

          if (pathVal == null) return key3 ? undefined : pathVal;
          pathVal = pathVal[key3];

          if (pathVal == null) return key4 ? undefined : pathVal;
          pathVal = pathVal[key4];

          return pathVal;
        }
      : function cspSafePromiseEnabledGetter(scope, locals) {
          var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
              promise;

          if (pathVal == null) return pathVal;

          pathVal = pathVal[key0];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key1 ? undefined : pathVal;

          pathVal = pathVal[key1];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key2 ? undefined : pathVal;

          pathVal = pathVal[key2];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key3 ? undefined : pathVal;

          pathVal = pathVal[key3];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key4 ? undefined : pathVal;

          pathVal = pathVal[key4];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          return pathVal;
        };
}

function simpleGetterFn1(key0, fullExp) {
  ensureSafeMemberName(key0, fullExp);

  return function simpleGetterFn1(scope, locals) {
    if (scope == null) return undefined;
    return ((locals && locals.hasOwnProperty(key0)) ? locals : scope)[key0];
  };
}

function simpleGetterFn2(key0, key1, fullExp) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);

  return function simpleGetterFn2(scope, locals) {
    if (scope == null) return undefined;
    scope = ((locals && locals.hasOwnProperty(key0)) ? locals : scope)[key0];
    return scope == null ? undefined : scope[key1];
  };
}

function getterFn(path, options, fullExp) {
  // Check whether the cache has this getter already.
  // We can use hasOwnProperty directly on the cache because we ensure,
  // see below, that the cache never stores a path called 'hasOwnProperty'
  if (getterFnCache.hasOwnProperty(path)) {
    return getterFnCache[path];
  }

  var pathKeys = path.split('.'),
      pathKeysLength = pathKeys.length,
      fn;

  // When we have only 1 or 2 tokens, use optimized special case closures.
  // http://jsperf.com/angularjs-parse-getter/6
  if (!options.unwrapPromises && pathKeysLength === 1) {
    fn = simpleGetterFn1(pathKeys[0], fullExp);
  } else if (!options.unwrapPromises && pathKeysLength === 2) {
    fn = simpleGetterFn2(pathKeys[0], pathKeys[1], fullExp);
  } else if (options.csp) {
    if (pathKeysLength < 6) {
      fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp,
                          options);
    } else {
      fn = function(scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++],
                                pathKeys[i++], fullExp, options)(scope, locals);

          locals = undefined; // clear after first iteration
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    }
  } else {
    var code = 'var p;\n';
    forEach(pathKeys, function(key, index) {
      ensureSafeMemberName(key, fullExp);
      code += 'if(s==null) return undefined;\n' +
              's='+ (index
                      // we simply dereference 's' on any .dot notation
                      ? 's'
                      // but if we are first then we check locals first, and if so read it first
                      : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +
              (options.unwrapPromises
                ? 'if (s && s.then){\n' +
                  ' pw("' + fullExp.replace(/(["\r\n])/g,'\\$1')+'");\n'+' if (!("$$v" in s)) {\n'+' p=s;\n'+' p.$$v = undefined;\n'+' p.then(function(v) {p.$$v=v;});\n'+'}\n'+' s=s.$$v\n'+'}\n':'')});code +='return s;';var evaledFnGetter=new Function('s','k','pw',code);// s=scope,k=locals,locals),pw=promiseWarning evaledFnGetter.toString=valueFn(code);fn=options.unwrapPromises ? function(scope{return evaledFnGetter(scope,locals,promiseWarning)}function $QProvider(){this.$get=['$rootScope','$exceptionHandler',function($rootScope,$exceptionHandler){return qFactory(function(callback){$rootScope.$evalAsync(callback)}exceptionHandler),function qFactory(nextTick{deferred={resolve:function(val){if (pending){var callbacks=pending;:pending=undefined;:value=ref(val);:if (callbacks.length){nextTick(function(){var callback;:for (var i=0,ii=callbacks.length;:i < ii;:i++){callback=callbacks[i];:value.then(callback[0],callback[1],callback[2])},reject:function(reason){deferred.resolve(reject(reason))},notify:function(progress){:if (pending){var callbacks=pending;:if (pending.length){nextTick(function(){var callback;:for (var i=0,ii=callbacks.length;:i < ii;:i++){callback=callbacks[i];:callback[2](progress)},promise:{then:function(callback,errback,progressback){var result=defer();var wrappedCallback=function(value){try{result.resolve((isFunction(callback) ? callback:defaultCallback)(value))};var wrappedErrback=function(reason){try{result.resolve((isFunction(errback) ? errback:defaultErrback)(reason))};var wrappedProgressback=function(progress){try{result.notify((isFunction(progressback) ? progressback:defaultCallback)(progress))};if (pending){pending.push([wrappedCallback,wrappedErrback,wrappedProgressback])},"catch":function(callback){return this.then(null,callback)},"finally":function(callback){:function makePromise(value,resolved){var result=defer();:if (resolved){result.resolve(value)}function handleCallback(value,isResolved){:var callbackOutput=null;:try{callbackOutput=(callback ||defaultCallback)()}if (callbackOutput && isFunction(callbackOutput.then)){return callbackOutput.then(function(){return makePromise(value,isResolved)}return this.then(function(value){return handleCallback(value,true)};var ref=function(value){return{then:function(callback){var result=defer();:nextTick(function(){result.resolve(callback(value))};var reject=function(reason){return{then:function(callback,errback){var result=defer();nextTick(function(){try{result.resolve((isFunction(errback) ? errback:defaultErrback)(reason))};var when=function(value,callback,errback,progressback){:var result=defer(),done;var wrappedCallback=function(value){try{return (isFunction(callback) ? callback:defaultCallback)(value)};var wrappedErrback=function(reason){try{return (isFunction(errback) ? errback:defaultErrback)(reason)};var wrappedProgressback=function(progress){try{return (isFunction(progressback) ? progressback:defaultCallback)(progress)};nextTick(function(){:ref(value).then(function(value){if (done) return;:done=true;:result.resolve(ref(value).then(wrappedCallback,wrappedErrback,wrappedProgressback))},function(progress){:if (done) return;:result.notify(wrappedProgressback(progress))};function defaultCallback(value){return value}function defaultErrback(reason){return reject(reason)}function all(promises){;forEach(promises,function(promise,key){:counter++;:ref(promise).then(function(value){if (results.hasOwnProperty(key)) return;:results[key]=value;:if (!(--counter)) deferred.resolve(results)},function(reason){:if (results.hasOwnProperty(key)) return;:deferred.reject(reason)});if (counter===0){deferred.resolve(results)}return{defer:defer,reject:reject,when:when,all:all}function $RootScopeProvider(){:var TTL=10;:var $rootScopeMinErr=minErr('$rootScope');:var lastDirtyWatch=null;:this.digestTtl=function(value){if (arguments.length){TTL=value}$browser),$exceptionHandler,$parse,;this.$get=['$injector','$browser','$parse','$exceptionHandler',function($injector{:function Scope(){Scope.prototype={constructor:Scope,$new:function(isolate){var ChildScope,child;:if (isolate){child=new Scope();:child.$root=this.$root;:// ensure that there is just one async queue per $rootScope and its children child.$$asyncQueue=this.$$asyncQueue;:child.$$postDigestQueue=this.$$postDigestQueue};child.$parent=this;child.$$watchers=child.$$nextSibling=child.$$childHead=child.$$childTail=null;child.$$prevSibling=this.$$childTail;if (this.$$childHead){:this.$$childTail.$$nextSibling=child;:this.$$childTail=child},$watch:function(watchExp,listener,objectEquality){var scope=this,get=compileToFn(watchExp,'watch'),array=scope.$$watchers,watcher={fn:listener,last:initWatchVal,get:get,exp:watchExp,eq:!!objectEquality};lastDirtyWatch=null;// in the case user pass string,do we really need this ? if (!isFunction(listener)),we need to compile it{:var listenFn=compileToFn(listener || noop,'listener');:watcher.fn=function(newVal,oldVal,scope){listenFn(scope)}if (typeof watchExp=='string' && get.constant){:var originalFn=watcher.fn;:watcher.fn=function(newVal,oldVal,scope){originalFn.call(this,newVal,oldVal,scope);:arrayRemove(array,watcher)}if (!array){array=scope.$$watchers=[]}// we use unshift since we use a while loop in $digest for speed. // the while loop reads in reverse order. array.unshift(watcher);return function(){arrayRemove(array,watcher)},$watchCollection:function(obj,listener){;var oldLength=0;function $watchCollectionWatch(){:newValue=objGetter(self);:var newLength,key;:if (!isObject(newValue)){if (oldValue!==newValue){oldValue=newValue;:changeDetected++}else if (isArrayLike(newValue)){:if (oldValue!==internalArray){// we are transitioning from something which was not an array into array. oldValue=internalArray;:oldLength=oldValue.length=0;:changeDetected++}newLength=newValue.length;if (oldLength!==newLength){:// if lengths do not match we need to trigger change notification changeDetected++;:oldValue.length=oldLength=newLength}// copy the items to oldValue and look for changes. for (var i=0;i < newLength;i++){:if (oldValue[i]!==newValue[i]){changeDetected++;:oldValue[i]=newValue[i]}// copy the items to oldValue and look for changes. newLength=0;for (key in newValue){:if (newValue.hasOwnProperty(key)){newLength++;:if (oldValue.hasOwnProperty(key)){if (oldValue[key]!==newValue[key]){changeDetected++;:oldValue[key]=newValue[key]}if (oldLength>newLength){:// we used to have more keys,need to find them and destroy them. changeDetected++;:for(key in oldValue){if (oldValue.hasOwnProperty(key) &&!newValue.hasOwnProperty(key)){oldLength--;:delete oldValue[key]}function $watchCollectionAction(){listener(newValue,oldValue,self)},$digest:function(){:var watch,value,last,watchers,asyncQueue=this.$$asyncQueue,postDigestQueue=this.$$postDigestQueue,length,dirty,ttl=TTL,next,current,target=this,watchLog=[],logIdx,logMsg,asyncTask;:beginPhase('$digest');:lastDirtyWatch=null;:do{// "while dirty" loop dirty=false;:current=target;:while(asyncQueue.length){try{asyncTask=asyncQueue.shift();:asyncTask.scope.$eval(asyncTask.expression)}traverseScopesLoop:do{// Most common watches are on primitives,in which case we can short // circuit it with===operator,only when===fails do we use .equals if (watch){if ((value=watch.get(current))!==(last=watch.last) &&!(watch.eq ? equals(value,last) :(typeof value=='number' && typeof last=='number' && isNaN(value) && isNaN(last)))){dirty=true;watch.last=watch.eq ? copy(value):value;watch.fn(value,((last===initWatchVal) ? value:last),current);logMsg=(isFunction(watch.exp)) ? 'fn: '+(watch.exp.name || watch.exp.toString()):watch.exp;:logMsg +='; newVal: '+toJson(value)+'; oldVal: '+toJson(last);:watchLog[logIdx].push(logMsg)}else if (watch===lastDirtyWatch){:// If the most recently dirty watcher is now clean,short circuit since the remaining watchers // have already been tested. dirty=false;:break traverseScopesLoop}// Insanity Warning:scope depth-first traversal // yes,but it works and we have tests to prove it!// this piece should be kept in sync with the traversal in $broadcast if (!(next=(current.$$childHead || (current!==target && current.$$nextSibling)))),this code is a bit crazy{while(current!==target &&!(next=current.$$nextSibling)){current=current.$parent}while ((current=next));// `break traverseScopesLoop;` takes us to here if(dirty &&!(ttl--)){:clearPhase();:throw $rootScopeMinErr('infdig','{0} $digest() iterations reached. Aborting!\n'+'Watchers fired in the last 5 iterations: {1}',TTL,toJson(watchLog))}while (dirty || asyncQueue.length);clearPhase();while(postDigestQueue.length){try{postDigestQueue.shift()()},$destroy:function(){// we can't destroy the root scope or a scope that has been already destroyed
        if (this.$$destroyed) return;
        var parent = this.$parent;

        this.$broadcast('$destroy');
        this.$$destroyed = true;
        if (this === $rootScope) return;

        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        // This is bogus code that works around Chrome's GC leak // see:https://github.com/angular/angular.js/issues/1313#issuecomment-10378451 this.$parent=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null},$eval:function(expr,locals){return $parse(expr)(this,locals)},$evalAsync:function(expr){// if we are outside of an $digest loop and this is the first time we are scheduling async // task also schedule async auto-flush if (!$rootScope.$$phase &&!$rootScope.$$asyncQueue.length){$browser.defer(function(){if ($rootScope.$$asyncQueue.length){$rootScope.$digest()}this.$$asyncQueue.push({scope:this,expression:expr},$$postDigest :function(fn){this.$$postDigestQueue.push(fn)},$apply:function(expr){:try{beginPhase('$apply');:return this.$eval(expr)}finally{:clearPhase();:try{$rootScope.$digest()}catch (e){:$exceptionHandler(e)},$on:function(name,listener){:var namedListeners=this.$$listeners[name];:if (!namedListeners){this.$$listeners[name]=namedListeners=[]}namedListeners.push(listener);return function(){namedListeners[indexOf(namedListeners,listener)]=null},$emit:function(name,args){var empty=[],namedListeners,scope=this,stopPropagation=false,event={name:name,targetScope:scope,stopPropagation:function(){stopPropagation=true},preventDefault:function(){event.defaultPrevented=true},1),arguments,i,length;do,listenerArgs=concat([event]{:namedListeners=scope.$$listeners[name] || empty;:event.currentScope=scope;:for (i=0,length=namedListeners.length;:i<length;:i++){// if listeners were deregistered,defragment the array if (!namedListeners[i]){namedListeners.splice(i,1);:i--;:length--;:continue},$broadcast:function(name,args){var target=this,current=target,next=target,event={name:name,targetScope:target,preventDefault:function(){event.defaultPrevented=true},1),arguments,i,length;//down while you can,listenerArgs=concat([event],listeners,then up and next sibling or up and next sibling until back at root do{:current=next;:event.currentScope=current;:listeners=current.$$listeners[name] || [];:for (i=0,length=listeners.length;:i<length;:i++){// if listeners were deregistered,defragment the array if (!listeners[i]){listeners.splice(i,1);:i--;:length--;:continue}// Insanity Warning:scope depth-first traversal // yes,but it works and we have tests to prove it!// this piece should be kept in sync with the traversal in $digest if (!(next=(current.$$childHead || (current!==target && current.$$nextSibling)))),this code is a bit crazy{while(current!==target &&!(next=current.$$nextSibling)){current=current.$parent};var $rootScope=new Scope();return $rootScope;function beginPhase(phase){if ($rootScope.$$phase){throw $rootScopeMinErr('inprog','{0} already in progress',$rootScope.$$phase)}function clearPhase(){$rootScope.$$phase=null}function compileToFn(exp,name){:var fn=$parse(exp);:assertArgFn(fn,name);:return fn}function $$SanitizeUriProvider(){var aHrefSanitizationWhitelist=/^\s*(https?|ftp|mailto|tel|file):/,imgSrcSanitizationWhitelist=/^\s*(https?|ftp|file):|data:image\//;:this.aHrefSanitizationWhitelist=function(regexp){if (isDefined(regexp)){aHrefSanitizationWhitelist=regexp;:return this};this.imgSrcSanitizationWhitelist=function(regexp){:if (isDefined(regexp)){imgSrcSanitizationWhitelist=regexp;:return this};this.$get=function(){return function sanitizeUri(uri,isImage){var regex=isImage ? imgSrcSanitizationWhitelist:aHrefSanitizationWhitelist;// NOTE:urlResolve() doesn't support IE < 8 so we don't sanitize for that case. if (!msie || msie >=8){normalizedVal=urlResolve(uri).href;:if (normalizedVal!=='' &&!normalizedVal.match(regex)){return 'unsafe:'+normalizedVal}var $sceMinErr=minErr('$sce');var SCE_CONTEXTS={HTML:'html',CSS:'css',URL:'url',// RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a // url. (e.g. ng-include,script src,templateUrl) RESOURCE_URL:'resourceUrl',JS:'js'};// Helper functions follow. // Copied from:// http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962 // Prereq:s is a string. function escapeForRegexp(s){function adjustMatcher(matcher){if (matcher==='self'){return matcher}else if (isString(matcher)){// Strings match exactly except for 2 wildcards - '*' and '**'. // '*' matches any character except those from the set ':/.?&'. // '**' matches any character (like .* in a RegExp). // More than 2 *'s raises an error as it's ill defined. if (matcher.indexOf('***')>-1){throw $sceMinErr('iwcard','Illegal sequence *** in string matcher.  String: {0}',matcher)}else if (isRegExp(matcher)){// The only other type of matcher allowed is a Regexp. // Match entire URL / disallow partial matches. // Flags are reset (i.e. no global,ignoreCase or multiline) return new RegExp('^'+matcher.source+'$')}function adjustMatchers(matchers){:var adjustedMatchers=[];:if (isDefined(matchers)){forEach(matchers,function(matcher){adjustedMatchers.push(adjustMatcher(matcher))}function $SceDelegateProvider(){:this.SCE_CONTEXTS=SCE_CONTEXTS;:// Resource URLs can also be trusted by policy. var resourceUrlWhitelist=['self'],resourceUrlBlacklist=[];:this.resourceUrlWhitelist=function (value){if (arguments.length){resourceUrlWhitelist=adjustMatchers(value)};this.resourceUrlBlacklist=function (value){if (arguments.length){resourceUrlBlacklist=adjustMatchers(value)};if ($injector.has('$sanitize')){htmlSanitizer=$injector.get('$sanitize')}function matchUrl(matcher,parsedUrl){if (matcher==='self'){return urlIsSameOrigin(parsedUrl)}function isResourceUrlAllowedByPolicy(url){:var parsedUrl=urlResolve(url.toString());:var i,n,allowed=false;:// Ensure that at least one item from the whitelist allows this url. for (i=0,n=resourceUrlWhitelist.length;:i < n;:i++){if (matchUrl(resourceUrlWhitelist[i],parsedUrl)){allowed=true;:break}if (allowed){:// Ensure that no item from the blacklist blocked this url. for (i=0,n=resourceUrlBlacklist.length;:i < n;:i++){if (matchUrl(resourceUrlBlacklist[i],parsedUrl)){allowed=false;:break}function generateHolderType(Base){var holderType=function TrustedValueHolderType(trustedValue){this.$$unwrapTrustedValue=function(){return trustedValue};if (Base){holderType.prototype=new Base()}holderType.prototype.valueOf=function sceValueOf(){return this.$$unwrapTrustedValue()};holderType.prototype.toString=function sceToString(){return this.$$unwrapTrustedValue().toString()};byType[SCE_CONTEXTS.HTML]=generateHolderType(trustedValueHolderBase);byType[SCE_CONTEXTS.CSS]=generateHolderType(trustedValueHolderBase);byType[SCE_CONTEXTS.URL]=generateHolderType(trustedValueHolderBase);byType[SCE_CONTEXTS.JS]=generateHolderType(trustedValueHolderBase);byType[SCE_CONTEXTS.RESOURCE_URL]=generateHolderType(byType[SCE_CONTEXTS.URL]);function trustAs(type,trustedValue){var Constructor=(byType.hasOwnProperty(type) ? byType[type]:null);:if (!Constructor){throw $sceMinErr('icontext','Attempted to trust a value in invalid context. Context: {0}; Value: {1}',type,trustedValue)}if (trustedValue===null || trustedValue===undefined || trustedValue===''){return trustedValue}// All the current contexts in SCE_CONTEXTS happen to be strings. In order to avoid trusting // mutable objects,we ensure here that the value passed in is actually a string. if (typeof trustedValue!=='string'){throw $sceMinErr('itype','Attempted to trust a non-string value in a content requiring a string: Context: {0}',type)}function valueOf(maybeTrusted){if (maybeTrusted instanceof trustedValueHolderBase){return maybeTrusted.$$unwrapTrustedValue()}function getTrusted(type,maybeTrusted){if (maybeTrusted===null || maybeTrusted===undefined || maybeTrusted===''){return maybeTrusted}var constructor=(byType.hasOwnProperty(type) ? byType[type]:null);if (constructor && maybeTrusted instanceof constructor){return maybeTrusted.$$unwrapTrustedValue()}// If we get here,or // 2. throw an exception. if (type===SCE_CONTEXTS.RESOURCE_URL),then we may only take one of two actions. // 1. sanitize the value for the requested type{if (isResourceUrlAllowedByPolicy(maybeTrusted)){return maybeTrusted}else if (type===SCE_CONTEXTS.HTML){return htmlSanitizer(maybeTrusted)}return{trustAs:trustAs,getTrusted:getTrusted,valueOf:valueOf}function $SceProvider(){:var enabled=true;:this.enabled=function (value){if (arguments.length){enabled=!!value}$sceDelegate),$sniffer,;this.$get=['$parse','$sniffer','$sceDelegate',function($parse{// Prereq:Ensure that we're not running in IE8 quirks mode.  In that mode, IE allows
    // the "expression(javascript expression)" syntax which is insecure.
    if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) {
      throw $sceMinErr('iequirks',
        'Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks ' +
        'mode. You can fix this by adding the text <!doctype html> to the top of your HTML ' +
        'document. See http://docs.angularjs.org/api/ng.$sce for more information.');
    }

    var sce = copy(SCE_CONTEXTS);

    
    sce.isEnabled = function () {
      return enabled;
    };
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    if (!enabled) {
      sce.trustAs = sce.getTrusted = function(type, value) { return value; };
      sce.valueOf = identity;
    }

    
    sce.parseAs = function sceParseAs(type, expr) {
      var parsed = $parse(expr);
      if (parsed.literal && parsed.constant) {
        return parsed;
      } else {
        return function sceParseAsTrusted(self, locals) {
          return sce.getTrusted(type, parsed(self, locals));
        };
      }
    };

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    // Shorthand delegations.
    var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    forEach(SCE_CONTEXTS, function (enumValue, name) {
      var lName = lowercase(name);
      sce[camelCase("parse_as_" + lName)] = function (expr) {
        return parse(enumValue, expr);
      };
      sce[camelCase("get_trusted_" + lName)] = function (value) {
        return getTrusted(enumValue, value);
      };
      sce[camelCase("trust_as_" + lName)] = function (value) {
        return trustAs(enumValue, value);
      };
    });

    return sce;
  }];
}


function $SnifferProvider() {
  this.$get = ['$window', '$document', function($window, $document) {,
        documentMode = document.documentMode,
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = false,
        animations = false,
        match;

    if (bodyStyle) {
      for(var prop in bodyStyle) {
        if(match = vendorRegex.exec(prop)) {
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          break;
        }
      }

      if(!vendorPrefix) {
        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
      }

      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));

      if (android && (!transitions||!animations)) {
        transitions = isString(document.body.style.webkitTransition);
        animations = isString(document.body.style.webkitAnimation);
      }
    }


    return {
      // Android has history.pushState, but it does not update location correctly
      // so let's not use the history API at all. // http://code.google.com/p/android/issues/detail?id=17471 // https://github.com/angular/angular.js/issues/904 // older webit browser (533.9) on Boxee box has exactly the same problem as Android has // so let's not use the history API also
      // We are purposefully using `!(android < 4)` to cover the case when `android` is undefined
      // jshint -W018
      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
      // jshint +W018
      hashchange: 'onhashchange' in $window &&
                  // IE8 compatible mode lies
                  (!documentMode || documentMode > 7),
      hasEvent: function(event) {
        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
        // it. In particular the event is not fired when backspace or delete key are pressed or
        // when cut operation is performed.
        if (event == 'input' && msie == 9) return false;

        if (isUndefined(eventSupport[event])) {
          var divElm = document.createElement('div');
          eventSupport[event] = 'on' + event in divElm;
        }

        return eventSupport[event];
      },
      csp: csp(),
      vendorPrefix: vendorPrefix,
      transitions : transitions,
      animations : animations,
      android: android,
      msie : msie,
      msieDocumentMode: documentMode
    };
  }];
}

function $TimeoutProvider() {
  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',
       function($rootScope,   $browser,   $q,   $exceptionHandler) {;


     
    function timeout(fn, delay, invokeApply) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          skipApply = (isDefined(invokeApply) && !invokeApply),
          timeoutId;

      timeoutId = $browser.defer(function() {
        try {
          deferred.resolve(fn());
        } catch(e) {
          deferred.reject(e);
          $exceptionHandler(e);
        }
        finally {
          delete deferreds[promise.$$timeoutId];
        }

        if (!skipApply) $rootScope.$apply();
      }, delay);

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;

      return promise;
    }


     
    timeout.cancel = function(promise) {
      if (promise && promise.$$timeoutId in deferreds) {
        deferreds[promise.$$timeoutId].reject('canceled');
        delete deferreds[promise.$$timeoutId];
        return $browser.defer.cancel(promise.$$timeoutId);
      }
      return false;
    };

    return timeout;
  }];
}

// NOTE:  The usage of window and document instead of $window and $document here is
// deliberate.  This service depends on the specific behavior of anchor nodes created by the
// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and
// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it
// doesn't know about mocked locations and resolves URLs to the real document - which is // exactly the behavior needed here. There is little value is mocking these out for this // service. var urlParsingNode=document.createElement("a");:var originUrl=urlResolve(window.location.href,true);:function urlResolve(url,base){var href=url;:if (msie){// Normalize before parse. Refer Implementation Notes on why this is // done in two steps on IE. urlParsingNode.setAttribute("href",href);:href=urlParsingNode.href}href);// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils return,urlParsingNode.setAttribute('href'{href:urlParsingNode.href,protocol:urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/,''):'',host:urlParsingNode.host,search:urlParsingNode.search ? urlParsingNode.search.replace(/^\?/,'') :'',hash:urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/,'') :'',hostname:urlParsingNode.hostname,port:urlParsingNode.port,pathname:(urlParsingNode.pathname.charAt(0)==='/') ? urlParsingNode.pathname :'/'+urlParsingNode.pathname}function urlIsSameOrigin(requestUrl){var parsed=(isString(requestUrl)) ? urlResolve(requestUrl):requestUrl;:return (parsed.protocol===originUrl.protocol && parsed.host===originUrl.host)}function $WindowProvider(){this.$get=valueFn(window)}$FilterProvider.$inject=['$provide'];function $FilterProvider($provide){:var suffix='Filter';:function register(name,factory){if(isObject(name)){;forEach(name,function(filter,key){filters[key]=register(key,filter)}function($injector),this.register=register;this.$get=['$injector'{return function(name){return $injector.get(name+suffix)}function filterFilter(){:return function(array,expression,comparator){if (!isArray(array)) return array;:var comparatorType=typeof(comparator),predicates=[];:predicates.check=function(value){for (var j=0;:j < predicates.length;:j++){if(!predicates[j](value)){return false};if (comparatorType!=='function'){if (comparatorType==='boolean' && comparator){comparator=function(obj,text){return angular.equals(obj,text)}text),var search=function(obj{if (typeof text=='string' && text.charAt(0)==='!'){return!search(obj,text.substr(1))}switch (typeof obj){case "boolean":case "number":case "string":return comparator(obj,text);case "object":switch (typeof text){case "object":return comparator(obj,text);default:for (var objKey in obj){if (objKey.charAt(0)!=='$' && search(obj[objKey],text)){return true}return false;case "array":for (var i=0;i < obj.length;i++){if (search(obj[i],text)){return true};switch (typeof expression){case "boolean":case "number":case "string":// Set up expression object and fall through expression={$:expression};// jshint -W086 case "object":// jshint +W086 for (var key in expression){:if (key=='$'){(function(){if (!expression[key]) return;:var path=key;:predicates.push(function(value){return search(value,expression[path])}var path=key;predicates.push(function(value){return search(getter(value,path),expression[path])}var filtered=[];for (var j=0;j < array.length;j++){:var value=array[j];:if (predicates.check(value)){filtered.push(value)}currencyFilter.$inject=['$locale'];function currencyFilter($locale){:var formats=$locale.NUMBER_FORMATS;:return function(amount,currencySymbol){if (isUndefined(currencySymbol)) currencySymbol=formats.CURRENCY_SYM;:return formatNumber(amount,formats.PATTERNS[1],formats.GROUP_SEP,formats.DECIMAL_SEP,2). replace(/\u00A4/g,currencySymbol)}numberFilter.$inject=['$locale'];function numberFilter($locale){:var formats=$locale.NUMBER_FORMATS;:return function(number,fractionSize){return formatNumber(number,formats.PATTERNS[0],formats.GROUP_SEP,formats.DECIMAL_SEP,fractionSize)}decimalSep,fractionSize),groupSep,pattern,var DECIMAL_SEP='.';function formatNumber(number{:if (isNaN(number) ||!isFinite(number)) return '';:var isNegative=number < 0;:number=Math.abs(number);:var numStr=number+'',formatedText='',parts=[];:var hasExponent=false;:if (numStr.indexOf('e')!==-1){var match=numStr.match(/([\d\.]+)e(-?)(\d+)/);:if (match && match[2]=='-' && match[3]>fractionSize+1){numStr='0'}if (!hasExponent){:var fractionLen=(numStr.split(DECIMAL_SEP)[1] || '').length;:// determine fractionSize if it is not specified if (isUndefined(fractionSize)){fractionSize=Math.min(Math.max(pattern.minFrac,fractionLen),pattern.maxFrac)}fractionSize);number=Math.round(number * pow) / pow;var fraction=(''+number).split(DECIMAL_SEP);var whole=fraction[0];fraction=fraction[1] || '';var i,group=pattern.gSize;if (whole.length >=(lgroup+group)),lgroup=pattern.lgSize,pos=0,var pow=Math.pow(10{:pos=whole.length - lgroup;:for (i=0;:i < pos;:i++){if ((pos - i)%group===0 && i!==0){formatedText +=groupSep}for (i=pos;i < whole.length;i++){if ((whole.length - i)%lgroup===0 && i!==0){formatedText +=groupSep}// format fraction part. while(fraction.length < fractionSize){fraction +='0'}digits,function padNumber(num,trim){:var neg='';:if (num < 0){neg='-';:num=-num}function dateGetter(name,offset,size,trim){:offset=offset || 0;:return function(date){var value=date['get'+name]();:if (offset>0 || value>-offset) value +=offset;:if (value===0 && offset==-12) value=12;:return padNumber(value,size,trim)}function dateStrGetter(name,shortForm){var get=uppercase(shortForm ? ('SHORT'+name):name);:return formats[get][value]}function timeZoneGetter(date){var paddedZone=(zone >=0) ? "+":"";paddedZone +=padNumber(Math[zone>0 ? 'floor':'ceil'](zone / 60),2)+padNumber(Math.abs(zone % 60),2);:return paddedZone}formats),function ampmGetter(date{return date.getHours() < 12 ? formats.AMPMS[0]:formats.AMPMS[1]}var DATE_FORMATS={yyyy:dateGetter('FullYear',4),yy:dateGetter('FullYear',2,0,true),y:dateGetter('FullYear',1),MMMM:dateStrGetter('Month'),MMM:dateStrGetter('Month',true),MM:dateGetter('Month',2,1),M:dateGetter('Month',1,1),dd:dateGetter('Date',2),d:dateGetter('Date',1),HH:dateGetter('Hours',2),H:dateGetter('Hours',1),hh:dateGetter('Hours',2,-12),h:dateGetter('Hours',1,-12),mm:dateGetter('Minutes',2),m:dateGetter('Minutes',1),ss:dateGetter('Seconds',2),s:dateGetter('Seconds',1),// while ISO 8601 requires fractions to be prefixed with `.` or `,` // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
   sss: dateGetter('Milliseconds', 3),
  EEEE: dateStrGetter('Day'),
   EEE: dateStrGetter('Day', true),
     a: ampmGetter,
     Z: timeZoneGetter
};

var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
    NUMBER_STRING = /^\-?\d+$/;


dateFilter.$inject = ['$locale'];
function dateFilter($locale) {


  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                     // 1        2       3         4          5          6          7          8  9     10      11
  function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
      var date = new Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = int(match[9] + match[10]);
        tzMin = int(match[9] + match[11]);
      }
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
      var h = int(match[4]||0) - tzHour;
      var m = int(match[5]||0) - tzMin;
      var s = int(match[6]||0);
      var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return string;
  }


  return function(date, format) {
    var text = '',
        parts = [],
        fn, match;

    format = format || 'mediumDate';
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
      if (NUMBER_STRING.test(date)) {
        date = int(date);
      } else {
        date = jsonStringToDate(date);
      }
    }

    if (isNumber(date)) {
      date = new Date(date);
    }

    if (!isDate(date)) {
      return date;
    }

    while(format) {
      match = DATE_FORMATS_SPLIT.exec(format);
      if (match) {
        parts = concat(parts, match, 1);
        format = parts.pop();
      } else {
        parts.push(format);
        format = null;
      }
    }

    forEach(parts, function(value){
      fn = DATE_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
    });

    return text;
  };
}



function jsonFilter() {
  return function(object) {
    return toJson(object, true);
  };
}



var lowercaseFilter = valueFn(lowercase);



var uppercaseFilter = valueFn(uppercase);


function limitToFilter(){
  return function(input, limit) {
    if (!isArray(input) && !isString(input)) return input;
    
    limit = int(limit);

    if (isString(input)) {
      //NaN check on limit
      if (limit) {
        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
      } else {
        return "";
      }
    }

    var out = [],
      i, n;

    // if abs(limit) exceeds maximum length, trim it
    if (limit > input.length)
      limit = input.length;
    else if (limit < -input.length)
      limit = -input.length;

    if (limit > 0) {
      i = 0;
      n = limit;
    } else {
      i = input.length + limit;
      n = input.length;
    }

    for (; i<n; i++) {
      out.push(input[i]);
    }

    return out;
  };
}


orderByFilter.$inject = ['$parse'];
function orderByFilter($parse){
  return function(array, sortPredicate, reverseOrder) {
    if (!isArray(array)) return array;
    if (!sortPredicate) return array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
    sortPredicate = map(sortPredicate, function(predicate){
      var descending = false, get = predicate || identity;
      if (isString(predicate)) {
        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
          descending = predicate.charAt(0) == '-';
          predicate = predicate.substring(1);
        }
        get = $parse(predicate);
      }
      return reverseComparator(function(a,b){
        return compare(get(a),get(b));
      }, descending);
    });
    var arrayCopy = [];
    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

    function comparator(o1, o2){
      for ( var i = 0; i < sortPredicate.length; i++) {
        var comp = sortPredicate[i](o1, o2);
        if (comp !== 0) return comp;
      }
      return 0;
    }
    function reverseComparator(comp, descending) {
      return toBoolean(descending)
          ? function(a,b){return comp(b,a);}
          : comp;
    }
    function compare(v1, v2){
      var t1 = typeof v1;
      var t2 = typeof v2;
      if (t1 == t2) {
        if (t1 == "string") {
           v1 = v1.toLowerCase();
           v2 = v2.toLowerCase();
        }
        if (v1 === v2) return 0;
        return v1 < v2 ? -1 : 1;
      } else {
        return t1 < t2 ? -1 : 1;
      }
    }
  };
}

function ngDirective(directive) {
  if (isFunction(directive)) {
    directive = {
      link: directive
    };
  }
  directive.restrict = directive.restrict || 'AC';
  return valueFn(directive);
}


var htmlAnchorDirective = valueFn({
  restrict: 'E',
  compile: function(element, attr) {

    if (msie <= 8) {

      // turn <a href ng-click="..">link</a> into a stylable link in IE
      // but only if it doesn't have name attribute, in which case it's an anchor
      if (!attr.href && !attr.name) {
        attr.$set('href', '');
      }

      // add a comment node to anchors to workaround IE bug that causes element content to be reset
      // to new attribute content if attribute is updated with value containing @ and element also
      // contains value with @
      // see issue #1949
      element.append(document.createComment('IE fix'));
    }

    if (!attr.href && !attr.name) {
      return function(scope, element) {
        element.on('click', function(event){
          // if we have no href url, then don't navigate anywhere.
          if (!element.attr('href')) {
            event.preventDefault();
          }
        });
      };
    }
  }
};


// boolean attrs are evaluated
forEach(BOOLEAN_ATTR, function(propName, attrName) {
  // binding to multiple is not supported
  if (propName == "multiple") return;

  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 100,
      compile: function() {
        return function(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        };
      }
    };
  };
});


// ng-src, ng-srcset, ng-href are interpolated
forEach(['src', 'srcset', 'href'], function(attrName) {
  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 99, // it needs to run after the attributes are interpolated
      link: function(scope, element, attr) {
        attr.$observe(normalized, function(value) {
          if (!value)
             return;

          attr.$set(attrName, value);

          // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
          // to set the property as well to achieve the desired effect.
          // we use attr[attrName] value since $set can sanitize the url.
          if (msie) element.prop(attrName, attr[attrName]);
        });
      }
    };
  };
});


var nullFormCtrl = {
  $addControl: noop,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop
};


//asks for $scope to fool the BC controller module
FormController.$inject = ['$element', '$attrs', '$scope'];
function FormController(element, attrs) {,
      controls = [];

  // init state
  form.$name = attrs.name || attrs.ngForm;
  form.$dirty = false;
  form.$pristine = true;
  form.$valid = true;
  form.$invalid = false;

  parentForm.$addControl(form);

  // Setup initial state of the control
  element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  
  form.$addControl = function(control) {
    // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
    // and not added to the scope.  Now we throw an error.
    assertNotHasOwnProperty(control.$name, 'input');
    controls.push(control);

    if (control.$name) {
      form[control.$name] = control;
    }
  };

  
  form.$removeControl = function(control) {
    if (control.$name && form[control.$name] === control) {
      delete form[control.$name];
    }
    forEach(errors, function(queue, validationToken) {
      form.$setValidity(validationToken, true, control);
    });

    arrayRemove(controls, control);
  };

  
  form.$setValidity = function(validationToken, isValid, control) {
    var queue = errors[validationToken];

    if (isValid) {
      if (queue) {
        arrayRemove(queue, control);
        if (!queue.length) {
          invalidCount--;
          if (!invalidCount) {
            toggleValidCss(isValid);
            form.$valid = true;
            form.$invalid = false;
          }
          errors[validationToken] = false;
          toggleValidCss(true, validationToken);
          parentForm.$setValidity(validationToken, true, form);
        }
      }

    } else {
      if (!invalidCount) {
        toggleValidCss(isValid);
      }
      if (queue) {
        if (includes(queue, control)) return;
      } else {
        errors[validationToken] = queue = [];
        invalidCount++;
        toggleValidCss(false, validationToken);
        parentForm.$setValidity(validationToken, false, form);
      }
      queue.push(control);

      form.$valid = false;
      form.$invalid = true;
    }
  };

  
  form.$setDirty = function() {
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
    form.$dirty = true;
    form.$pristine = false;
    parentForm.$setDirty();
  };

  
  form.$setPristine = function () {
    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
    form.$dirty = false;
    form.$pristine = true;
    forEach(controls, function(control) {
      control.$setPristine();
    });
  };
}




 
var formDirectiveFactory = function(isNgForm) {
  return ['$timeout', function($timeout) {
    var formDirective = {
      name: 'form',
      restrict: isNgForm ? 'EAC' : 'E',
      controller: FormController,
      compile: function() {
        return {
          pre: function(scope, formElement, attr, controller) {
            if (!attr.action) {
              // we can't use jq events because if a form is destroyed during submission the default
              // action is not prevented. see #1238
              //
              // IE 9 is not affected because it doesn't fire a submit event and try to do a full
              // page reload if the form was destroyed by submission of the form via a click handler
              // on a button in the form. Looks like an IE9 specific bug.
              var preventDefaultListener = function(event) {
                event.preventDefault
                  ? event.preventDefault()
                  : event.returnValue = false; // IE
              };

              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);

              // unregister the preventDefault listener so that we don't not leak memory but in a
              // way that will achieve the prevention of the default action.
              formElement.on('$destroy', function() {
                $timeout(function() {
                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                }, 0, false);
              });
            }

            var parentFormCtrl = formElement.parent().controller('form'),
                alias = attr.name || attr.ngForm;

            if (alias) {
              setter(scope, alias, controller, alias);
            }
            if (parentFormCtrl) {
              formElement.on('$destroy', function() {
                parentFormCtrl.$removeControl(controller);
                if (alias) {
                  setter(scope, alias, undefined, alias);
                }
                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
              });
            }
          }
        };
      }
    };

    return formDirective;
  }];
};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(true);



var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

var inputType = {

  
  'text': textInputType,


  
  'number': numberInputType,


  
  'url': urlInputType,


  
  'email': emailInputType,


  
  'radio': radioInputType,


  
  'checkbox': checkboxInputType,

  'hidden': noop,
  'button': noop,
  'submit': noop,
  'reset': noop
};


function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  // In composition mode, users are still inputing intermediate text buffer,
  // hold the listener until composition is done.
  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
  if (!$sniffer.android) {
    var composing = false;

    element.on('compositionstart', function(data) {
      composing = true;
    });

    element.on('compositionend', function() {
      composing = false;
    });
  }

  var listener = function() {
    if (composing) return;
    var value = element.val();

    // By default we will trim the value
    // If the attribute ng-trim exists we will avoid trimming
    // e.g. <input ng-model="foo" ng-trim="false">
    if (toBoolean(attr.ngTrim || 'T')) {
      value = trim(value);
    }

    if (ctrl.$viewValue !== value) {
      scope.$apply(function() {
        ctrl.$setViewValue(value);
      });
    }
  };

  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
  // input event on backspace, delete or cut
  if ($sniffer.hasEvent('input')) {
    element.on('input', listener);
  } else {
    var timeout;

    var deferListener = function() {
      if (!timeout) {
        timeout = $browser.defer(function() {
          listener();
          timeout = null;
        });
      }
    };

    element.on('keydown', function(event) {
      var key = event.keyCode;

      // ignore
      //    command            modifiers                   arrows
      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

      deferListener();
    });

    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
    if ($sniffer.hasEvent('paste')) {
      element.on('paste cut', deferListener);
    }
  }

  // if user paste into input using mouse on older browser
  // or form autocomplete on newer browser, we need "change" event to catch it
  element.on('change', listener);

  ctrl.$render = function() {
    element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
  };

  // pattern validator
  var pattern = attr.ngPattern,
      patternValidator,
      match;

  var validate = function(regexp, value) {
    if (ctrl.$isEmpty(value) || regexp.test(value)) {
      ctrl.$setValidity('pattern', true);
      return value;
    } else {
      ctrl.$setValidity('pattern', false);
      return undefined;
    }
  };

  if (pattern) {
    match = pattern.match(/^\/(.*)\/([gim]*)$/);
    if (match) {
      pattern = new RegExp(match[1], match[2]);
      patternValidator = function(value) {
        return validate(pattern, value);
      };
    } else {
      patternValidator = function(value) {
        var patternObj = scope.$eval(pattern);

        if (!patternObj || !patternObj.test) {
          throw minErr('ngPattern')('noregexp',
            'Expected {0} to be a RegExp but was {1}. Element: {2}', pattern,
            patternObj, startingTag(element));
        }
        return validate(patternObj, value);
      };
    }

    ctrl.$formatters.push(patternValidator);
    ctrl.$parsers.push(patternValidator);
  }

  // min length validator
  if (attr.ngMinlength) {
    var minlength = int(attr.ngMinlength);
    var minLengthValidator = function(value) {
      if (!ctrl.$isEmpty(value) && value.length < minlength) {
        ctrl.$setValidity('minlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('minlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(minLengthValidator);
    ctrl.$formatters.push(minLengthValidator);
  }

  // max length validator
  if (attr.ngMaxlength) {
    var maxlength = int(attr.ngMaxlength);
    var maxLengthValidator = function(value) {
      if (!ctrl.$isEmpty(value) && value.length > maxlength) {
        ctrl.$setValidity('maxlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('maxlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxLengthValidator);
    ctrl.$formatters.push(maxLengthValidator);
  }
}

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$parsers.push(function(value) {
    var empty = ctrl.$isEmpty(value);
    if (empty || NUMBER_REGEXP.test(value)) {
      ctrl.$setValidity('number', true);
      return value === '' ? null : (empty ? value : parseFloat(value));
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });

  ctrl.$formatters.push(function(value) {
    return ctrl.$isEmpty(value) ? '' : '' + value;
  });

  if (attr.min) {
    var minValidator = function(value) {
      var min = parseFloat(attr.min);
      if (!ctrl.$isEmpty(value) && value < min) {
        ctrl.$setValidity('min', false);
        return undefined;
      } else {
        ctrl.$setValidity('min', true);
        return value;
      }
    };

    ctrl.$parsers.push(minValidator);
    ctrl.$formatters.push(minValidator);
  }

  if (attr.max) {
    var maxValidator = function(value) {
      var max = parseFloat(attr.max);
      if (!ctrl.$isEmpty(value) && value > max) {
        ctrl.$setValidity('max', false);
        return undefined;
      } else {
        ctrl.$setValidity('max', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxValidator);
    ctrl.$formatters.push(maxValidator);
  }

  ctrl.$formatters.push(function(value) {

    if (ctrl.$isEmpty(value) || isNumber(value)) {
      ctrl.$setValidity('number', true);
      return value;
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });
}

function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var urlValidator = function(value) {
    if (ctrl.$isEmpty(value) || URL_REGEXP.test(value)) {
      ctrl.$setValidity('url', true);
      return value;
    } else {
      ctrl.$setValidity('url', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
}

function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var emailValidator = function(value) {
    if (ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)) {
      ctrl.$setValidity('email', true);
      return value;
    } else {
      ctrl.$setValidity('email', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(emailValidator);
  ctrl.$parsers.push(emailValidator);
}

function radioInputType(scope, element, attr, ctrl) {
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.attr('name', nextUid());
  }

  element.on('click', function() {
    if (element[0].checked) {
      scope.$apply(function() {
        ctrl.$setViewValue(attr.value);
      });
    }
  });

  ctrl.$render = function() {
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  };

  attr.$observe('value', ctrl.$render);
}

function checkboxInputType(scope, element, attr, ctrl) {
  var trueValue = attr.ngTrueValue,
      falseValue = attr.ngFalseValue;

  if (!isString(trueValue)) trueValue = true;
  if (!isString(falseValue)) falseValue = false;

  element.on('click', function() {
    scope.$apply(function() {
      ctrl.$setViewValue(element[0].checked);
    });
  });

  ctrl.$render = function() {
    element[0].checked = ctrl.$viewValue;
  };

  // Override the standard `$isEmpty` because a value of `false` means empty in a checkbox.
  ctrl.$isEmpty = function(value) {
    return value !== trueValue;
  };

  ctrl.$formatters.push(function(value) {
    return value === trueValue;
  });

  ctrl.$parsers.push(function(value) {
    return value ? trueValue : falseValue;
  });
}






var inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {
  return {
    restrict: 'E',
    require: '?ngModel',
    link: function(scope, element, attr, ctrl) {
      if (ctrl) {
        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                            $browser);
      }
    }
  };
}];

var VALID_CLASS = 'ng-valid',
    INVALID_CLASS = 'ng-invalid',
    PRISTINE_CLASS = 'ng-pristine',
    DIRTY_CLASS = 'ng-dirty';


var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
    function($scope, $exceptionHandler, $attr, $element, $parse) {
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$pristine = true;
  this.$dirty = false;
  this.$valid = true;
  this.$invalid = false;
  this.$name = $attr.name;

  var ngModelGet = $parse($attr.ngModel),
      ngModelSet = ngModelGet.assign;

  if (!ngModelSet) {
    throw minErr('ngModel')('nonassign', "Expression '{0}' is non-assignable. Element:{1}",
        $attr.ngModel, startingTag($element));
  }

  
  this.$render = noop;

  
  this.$isEmpty = function(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  }; // keep invalid keys here


  // Setup initial state of the control
  $element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    $element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  
  this.$setValidity = function(validationErrorKey, isValid) {
    // Purposeful use of ! here to cast isValid to boolean in case it is undefined
    // jshint -W018
    if ($error[validationErrorKey] === !isValid) return;
    // jshint +W018

    if (isValid) {
      if ($error[validationErrorKey]) invalidCount--;
      if (!invalidCount) {
        toggleValidCss(true);
        this.$valid = true;
        this.$invalid = false;
      }
    } else {
      toggleValidCss(false);
      this.$invalid = true;
      this.$valid = false;
      invalidCount++;
    }

    $error[validationErrorKey] = !isValid;
    toggleValidCss(isValid, validationErrorKey);

    parentForm.$setValidity(validationErrorKey, isValid, this);
  };

  
  this.$setPristine = function () {
    this.$dirty = false;
    this.$pristine = true;
    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
  };

  
  this.$setViewValue = function(value) {
    this.$viewValue = value;

    // change to dirty
    if (this.$pristine) {
      this.$dirty = true;
      this.$pristine = false;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      parentForm.$setDirty();
    }

    forEach(this.$parsers, function(fn) {
      value = fn(value);
    });

    if (this.$modelValue !== value) {
      this.$modelValue = value;
      ngModelSet($scope, value);
      forEach(this.$viewChangeListeners, function(listener) {
        try {
          listener();
        } catch(e) {
          $exceptionHandler(e);
        }
      });
    }
  };

  // model -> value
  var ctrl = this;

  $scope.$watch(function ngModelWatch() {
    var value = ngModelGet($scope);

    // if scope model value and ngModel value are out of sync
    if (ctrl.$modelValue !== value) {

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      ctrl.$modelValue = value;
      while(idx--) {
        value = formatters[idx](value);
      }

      if (ctrl.$viewValue !== value) {
        ctrl.$viewValue = value;
        ctrl.$render();
      }
    }

    return value;
  });
}];



var ngModelDirective = function() {
  return {
    require: ['ngModel', '^?form'],
    controller: NgModelController,
    link: function(scope, element, attr, ctrls) {
      // notify others, especially parent forms

      var modelCtrl = ctrls[0],
          formCtrl = ctrls[1] || nullFormCtrl;

      formCtrl.$addControl(modelCtrl);

      scope.$on('$destroy', function() {
        formCtrl.$removeControl(modelCtrl);
      });
    }
  };
};



var ngChangeDirective = valueFn({
  require: 'ngModel',
  link: function(scope, element, attr, ctrl) {
    ctrl.$viewChangeListeners.push(function() {
      scope.$eval(attr.ngChange);
    });
  }
});


var requiredDirective = function() {
  return {
    require: '?ngModel',
    link: function(scope, elm, attr, ctrl) {
      if (!ctrl) return;
      attr.required = true; // force truthy in case we are on non input element

      var validator = function(value) {
        if (attr.required && ctrl.$isEmpty(value)) {
          ctrl.$setValidity('required', false);
          return;
        } else {
          ctrl.$setValidity('required', true);
          return value;
        }
      };

      ctrl.$formatters.push(validator);
      ctrl.$parsers.unshift(validator);

      attr.$observe('required', function() {
        validator(ctrl.$viewValue);
      });
    }
  };
};



var ngListDirective = function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      var match = /\/(.*)\//.exec(attr.ngList),
          separator = match && new RegExp(match[1]) || attr.ngList || ',';

      var parse = function(viewValue) {
        // If the viewValue is invalid (say required but empty) it will be `undefined`
        if (isUndefined(viewValue)) return;

        var list = [];

        if (viewValue) {
          forEach(viewValue.split(separator), function(value) {
            if (value) list.push(trim(value));
          });
        }

        return list;
      };

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(function(value) {
        if (isArray(value)) {
          return value.join(', ');
        }

        return undefined;
      });

      // Override the standard $isEmpty because an empty array means the input is empty.
      ctrl.$isEmpty = function(value) {
        return !value || !value.length;
      };
    }
  };
};


var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

var ngValueDirective = function() {
  return {
    priority: 100,
    compile: function(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function ngValueConstantLink(scope, elm, attr) {
          attr.$set('value', scope.$eval(attr.ngValue));
        };
      } else {
        return function ngValueLink(scope, elm, attr) {
          scope.$watch(attr.ngValue, function valueWatchAction(value) {
            attr.$set('value', value);
          });
        };
      }
    }
  };
};


var ngBindDirective = ngDirective(function(scope, element, attr) {
  element.addClass('ng-binding').data('$binding', attr.ngBind);
  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
    // We are purposefully using == here rather than === because we want to
    // catch when value is "null or undefined"
    // jshint -W041
    element.text(value == undefined ? '' : value);
  });
});



var ngBindTemplateDirective = ['$interpolate', function($interpolate) {
  return function(scope, element, attr) {
    // TODO: move this to scenario runner
    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
    element.addClass('ng-binding').data('$binding', interpolateFn);
    attr.$observe('ngBindTemplate', function(value) {
      element.text(value);
    });
  };
}];



var ngBindHtmlDirective = ['$sce', '$parse', function($sce, $parse) {
  return function(scope, element, attr) {
    element.addClass('ng-binding').data('$binding', attr.ngBindHtml);

    var parsed = $parse(attr.ngBindHtml);
    function getStringValue() { return (parsed(scope) || '').toString(); }

    scope.$watch(getStringValue, function ngBindHtmlWatchAction(value) {
      element.html($sce.getTrustedHtml(parsed(scope)) || '');
    });
  };
}];

function classDirective(name, selector) {
  name = 'ngClass' + name;
  return function() {
    return {
      restrict: 'AC',
      link: function(scope, element, attr) {
        var oldVal;

        scope.$watch(attr[name], ngClassWatchAction, true);

        attr.$observe('class', function(value) {
          ngClassWatchAction(scope.$eval(attr[name]));
        });


        if (name !== 'ngClass') {
          scope.$watch('$index', function($index, old$index) {
            // jshint bitwise: false
            var mod = $index & 1;
            if (mod !== old$index & 1) {
              var classes = flattenClasses(scope.$eval(attr[name]));
              mod === selector ?
                attr.$addClass(classes) :
                attr.$removeClass(classes);
            }
          });
        }


        function ngClassWatchAction(newVal) {
          if (selector === true || scope.$index % 2 === selector) {
            var newClasses = flattenClasses(newVal || '');
            if(!oldVal) {
              attr.$addClass(newClasses);
            } else if(!equals(newVal,oldVal)) {
              attr.$updateClass(newClasses, flattenClasses(oldVal));
            }
          }
          oldVal = copy(newVal);
        }


        function flattenClasses(classVal) {
          if(isArray(classVal)) {
            return classVal.join(' ');
          } else if (isObject(classVal)) {
            var classes = [], i = 0;
            forEach(classVal, function(v, k) {
              if (v) {
                classes.push(k);
              }
            });
            return classes.join(' ');
          }

          return classVal;
        }
      }
    };
  };
}


var ngClassDirective = classDirective('', true);


var ngClassOddDirective = classDirective('Odd', 0);


var ngClassEvenDirective = classDirective('Even', 1);


var ngCloakDirective = ngDirective({
  compile: function(element, attr) {
    attr.$set('ngCloak', undefined);
    element.removeClass('ng-cloak');
  }
});


var ngControllerDirective = [function() {
  return {
    scope: true,
    controller: '@',
    priority: 500
  };
};
forEach(
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
  function(name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = ['$parse', function($parse) {
      return {
        compile: function($element, attr) {
          var fn = $parse(attr[directiveName]);
          return function(scope, element, attr) {
            element.on(lowercase(name), function(event) {
              scope.$apply(function() {
                fn(scope, {$event:event});
              });
            });
          };
        }
      };
    }];
  }
);











































var ngIfDirective = ['$animate', function($animate) {
  return {
    transclude: 'element',
    priority: 600,
    terminal: true,
    restrict: 'A',
    $$tlb: true,
    link: function ($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {

          if (toBoolean(value)) {
            if (!childScope) {
              childScope = $scope.$new();
              $transclude(childScope, function (clone) {
                clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                // by a directive with templateUrl when it's template arrives.
                block = {
                  clone: clone
                };
                $animate.enter(clone, $element.parent(), $element);
              });
            }
          } else {

            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }

            if (block) {
              $animate.leave(getBlockElements(block.clone));
              block = null;
            }
          }
        });
    }
  };
}];








var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$animate', '$sce',
                  function($http,   $templateCache,   $anchorScroll,   $animate,   $sce) {
  return {
    restrict: 'ECA',
    priority: 400,
    terminal: true,
    transclude: 'element',
    controller: angular.noop,
    compile: function(element, attr) {
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || '',
          autoScrollExp = attr.autoscroll;

      return function(scope, $element, $attr, ctrl, $transclude) {
        var changeCounter = 0,
            currentScope,
            currentElement;

        var cleanupLastIncludeContent = function() {
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if(currentElement) {
            $animate.leave(currentElement);
            currentElement = null;
          }
        };

        scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
          var afterAnimation = function() {
            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
              $anchorScroll();
            }
          };
          var thisChangeId = ++changeCounter;

          if (src) {
            $http.get(src, {cache: $templateCache}).success(function(response) {
              if (thisChangeId !== changeCounter) return;
              var newScope = scope.$new();
              ctrl.template = response;

              // Note: This will also link all children of ng-include that were contained in the original
              // html. If that content contains controllers, ... they could pollute/change the scope.
              // However, using ng-include on an element with additional content does not make sense...
              // Note: We can't remove them in the cloneAttchFn of $transclude as that
              // function is called before linking the content, which would apply child
              // directives to non existing elements.
              var clone = $transclude(newScope, function(clone) {
                cleanupLastIncludeContent();
                $animate.enter(clone, null, $element, afterAnimation);
              });

              currentScope = newScope;
              currentElement = clone;

              currentScope.$emit('$includeContentLoaded');
              scope.$eval(onloadExp);
            }).error(function() {
              if (thisChangeId === changeCounter) cleanupLastIncludeContent();
            });
            scope.$emit('$includeContentRequested');
          } else {
            cleanupLastIncludeContent();
            ctrl.template = null;
          }
        });
      };
    }
  };
}];

// This directive is called during the $transclude call of the first `ngInclude` directive.
// It will replace and compile the content of the element with the loaded template.
// We need this directive so that the element content is already filled when
// the link function of another directive on the same element as ngInclude
// is called.
var ngIncludeFillContentDirective = ['$compile',
  function($compile) {
    return {
      restrict: 'ECA',
      priority: -400,
      require: 'ngInclude',
      link: function(scope, $element, $attr, ctrl) {
        $element.html(ctrl.template);
        $compile($element.contents())(scope);
      }
    };
  }];


var ngInitDirective = ngDirective({
  priority: 450,
  compile: function() {
    return {
      pre: function(scope, element, attrs) {
        scope.$eval(attrs.ngInit);
      }
    };
  }
});


var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });


var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {/g;
  return {
    restrict: 'EA',
    link: function(scope, element, attr) {,
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          isWhen = /^when(Minus)?(.+)$/;

      forEach(attr, function(expression, attributeName) {
        if (isWhen.test(attributeName)) {
          whens[lowercase(attributeName.replace('when', '').replace('Minus', '-'))] =
            element.attr(attr.$attr[attributeName]);
        }
      });
      forEach(whens, function(expression, key) {
        whensExpFns[key] =
          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +
            offset + endSymbol));
      });

      scope.$watch(function ngPluralizeWatch() {
        var value = parseFloat(scope.$eval(numberExp));

        if (!isNaN(value)) {
          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
          //check it against pluralization rules in $locale service
          if (!(value in whens)) value = $locale.pluralCat(value - offset);
           return whensExpFns[value](scope, element, true);
        } else {
          return '';
        }
      }, function ngPluralizeWatchAction(newVal) {
        element.text(newVal);
      });
    }
  };
}];


var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
  var NG_REMOVED = '$$NG_REMOVED';
  var ngRepeatMinErr = minErr('ngRepeat');
  return {
    transclude: 'element',
    priority: 1000,
    terminal: true,
    $$tlb: true,
    link: function($scope, $element, $attr, ctrl, $transclude){
        var expression = $attr.ngRepeat;
        var match = expression.match(/^\s*(.+)\s+in\s+([\r\n\s\S]*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
          trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn,
          lhs, rhs, valueIdentifier, keyIdentifier,
          hashFnLocals = {$id: hashKey};

        if (!match) {
          throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
        }

        lhs = match[1];
        rhs = match[2];
        trackByExp = match[4];

        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
          trackByIdExpFn = function(key, value, index) {
            // assign key, value, and $index to the locals so that they can be used in hash functions
            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          };
          trackByIdObjFn = function(key) {
            return key;
          };
        }

        match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
        if (!match) {
          throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression,but got '{0}'.",
                                                                    lhs);
        };

        //watch props
        $scope.$watchCollection(rhs, function ngRepeatAction(collection){,
              arrayLength,
              childScope,
              key, value, // key/value of iteration
              trackById,
              trackByIdFn,
              collectionKeys,
              block,       // last object information {scope, element, id}
              nextBlockOrder = [],
              elementsToRemove;


          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (key in collection) {
              if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                collectionKeys.push(key);
              }
            }
            collectionKeys.sort();
          }

          arrayLength = collectionKeys.length;

          // locate existing items
          length = nextBlockOrder.length = collectionKeys.length;
          for(index = 0; index < length; index++) {
           key = (collection === collectionKeys) ? index : collectionKeys[index];
           value = collection[key];
           trackById = trackByIdFn(key, value, index);
           assertNotHasOwnProperty(trackById, '`track by` id');
           if(lastBlockMap.hasOwnProperty(trackById)) {
             block = lastBlockMap[trackById];
             delete lastBlockMap[trackById];
             nextBlockMap[trackById] = block;
             nextBlockOrder[index] = block;
           } else if (nextBlockMap.hasOwnProperty(trackById)) {
             // restore lastBlockMap
             forEach(nextBlockOrder, function(block) {
               if (block && block.scope) lastBlockMap[block.id] = block;
             });
             // This is a duplicate and we need to throw an error
             throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater:{0},Duplicate key:,",
                                                                                                                                                    expression,       trackById);
           } else {
             // new never before seen block
             nextBlockOrder[index] = { id: trackById };
             nextBlockMap[trackById] = false;
           }
         }

          // remove existing items
          for (key in lastBlockMap) {
            // lastBlockMap is our own object so we don't need to use special hasOwnPropertyFn
            if (lastBlockMap.hasOwnProperty(key)) {
              block = lastBlockMap[key];
              elementsToRemove = getBlockElements(block.clone);
              $animate.leave(elementsToRemove);
              forEach(elementsToRemove, function(element) { element[NG_REMOVED] = true; });
              block.scope.$destroy();
            }
          }

          // we are not using forEach for perf reasons (trying to avoid #call)
          for (index = 0, length = collectionKeys.length; index < length; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];
            if (nextBlockOrder[index - 1]) previousNode = getBlockEnd(nextBlockOrder[index - 1]);

            if (block.scope) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element
              childScope = block.scope;

              nextNode = previousNode;
              do {
                nextNode = nextNode.nextSibling;
              } while(nextNode && nextNode[NG_REMOVED]);

              if (getBlockStart(block) != nextNode) {
                // existing item which got moved
                $animate.move(getBlockElements(block.clone), null, jqLite(previousNode));
              }
              previousNode = getBlockEnd(block);
            } else {
              // new item which we don't know about
              childScope = $scope.$new();
            }

            childScope[valueIdentifier] = value;
            if (keyIdentifier) childScope[keyIdentifier] = key;
            childScope.$index = index;
            childScope.$first = (index === 0);
            childScope.$last = (index === (arrayLength - 1));
            childScope.$middle = !(childScope.$first || childScope.$last);
            // jshint bitwise: false
            childScope.$odd = !(childScope.$even = (index&1) === 0);
            // jshint bitwise: true

            if (!block.scope) {
              $transclude(childScope, function(clone) {
                clone[clone.length++] = document.createComment(' end ngRepeat: ' + expression + ' ');
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = clone;
                block.scope = childScope;
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                // by a directive with templateUrl when it's template arrives.
                block.clone = clone;
                nextBlockMap[block.id] = block;
              });
            }
          }
          lastBlockMap = nextBlockMap;
        });
    }
  };

  function getBlockStart(block) {
    return block.clone[0];
  }

  function getBlockEnd(block) {
    return block.clone[block.clone.length - 1];
  }
}];


var ngShowDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngShow, function ngShowWatchAction(value){
      $animate[toBoolean(value) ? 'removeClass' : 'addClass'](element, 'ng-hide');
    });
  };
}];



var ngHideDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngHide, function ngHideWatchAction(value){
      $animate[toBoolean(value) ? 'addClass' : 'removeClass'](element, 'ng-hide');
    });
  };
}];


var ngStyleDirective = ngDirective(function(scope, element, attr) {
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
    if (oldStyles && (newStyles !== oldStyles)) {
      forEach(oldStyles, function(val, style) { element.css(style, '');});
    }
    if (newStyles) element.css(newStyles);
  }, true);
});


var ngSwitchDirective = ['$animate', function($animate) {
  return {
    restrict: 'EA',
    require: 'ngSwitch',

    // asks for $scope to fool the BC controller module
    controller: ['$scope', function ngSwitchController() {;
    }],
    link: function(scope, element, attr, ngSwitchController) {
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes,
          selectedElements,
          selectedScopes = [];

      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
        for (var i= 0, ii=selectedScopes.length; i<ii; i++) {
          selectedScopes[i].$destroy();
          $animate.leave(selectedElements[i]);
        }

        selectedElements = [];
        selectedScopes = [];

        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
          scope.$eval(attr.change);
          forEach(selectedTranscludes, function(selectedTransclude) {
            var selectedScope = scope.$new();
            selectedScopes.push(selectedScope);
            selectedTransclude.transclude(selectedScope, function(caseElement) {
              var anchor = selectedTransclude.element;

              selectedElements.push(caseElement);
              $animate.enter(caseElement, anchor.parent(), anchor);
            });
          });
        }
      });
    }
  };
}];

var ngSwitchWhenDirective = ngDirective({
  transclude: 'element',
  priority: 800,
  require: '^ngSwitch',
  compile: function(element, attrs) {
    return function(scope, element, attr, ctrl, $transclude) {
      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
      ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: $transclude, element: element });
    };
  }
});

var ngSwitchDefaultDirective = ngDirective({
  transclude: 'element',
  priority: 800,
  require: '^ngSwitch',
  link: function(scope, element, attr, ctrl, $transclude) {
    ctrl.cases['?'] = (ctrl.cases['?'] || []);
    ctrl.cases['?'].push({ transclude: $transclude, element: element });
   }
});


var ngTranscludeDirective = ngDirective({
  controller: ['$element', '$transclude', function($element, $transclude) {
    if (!$transclude) {
      throw minErr('ngTransclude')('orphan',
          'Illegal use of ngTransclude directive in the template! ' +
          'No parent directive that requires a transclusion found. ' +
          'Element: {0}',
          startingTag($element));
    }

    // remember the transclusion fn but call it during linking so that we don't process transclusion before directives on
    // the parent element even when the transclusion replaces the current element. (we can't use priority here because
    // that applies only to compile fns and not controllers
    this.$transclude = $transclude;
  }],

  link: function($scope, $element, $attrs, controller) {
    controller.$transclude(function(clone) {
      $element.empty();
      $element.append(clone);
    });
  }
});


var scriptDirective = ['$templateCache', function($templateCache) {
  return {
    restrict: 'E',
    terminal: true,
    compile: function(element, attr) {
      if (attr.type == 'text/ng-template') {
        var templateUrl = attr.id,
            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      }
    }
  };
}];

var ngOptionsMinErr = minErr('ngOptions');


var ngOptionsDirective = valueFn({ terminal: true });
// jshint maxlen: false
var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444000000000555555555555555000000066666666666666600000000000000007777000000000000000000088888
  var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
      nullModelCtrl = {$setViewValue: noop};
// jshint maxlen: 100

  return {
    restrict: 'E',
    require: ['select', '?ngModel'],
    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {,
          ngModelCtrl = nullModelCtrl,
          nullOption,
          unknownOption;


      self.databound = $attrs.ngModel;


      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
        ngModelCtrl = ngModelCtrl_;
        nullOption = nullOption_;
        unknownOption = unknownOption_;
      };


      self.addOption = function(value) {
        assertNotHasOwnProperty(value, '"option value"');
        optionsMap[value] = true;

        if (ngModelCtrl.$viewValue == value) {
          $element.val(value);
          if (unknownOption.parent()) unknownOption.remove();
        }
      };


      self.removeOption = function(value) {
        if (this.hasOption(value)) {
          delete optionsMap[value];
          if (ngModelCtrl.$viewValue == value) {
            this.renderUnknownOption(value);
          }
        }
      };


      self.renderUnknownOption = function(val) {
        var unknownVal = '? ' + hashKey(val) + ' ?';
        unknownOption.val(unknownVal);
        $element.prepend(unknownOption);
        $element.val(unknownVal);
        unknownOption.prop('selected', true); // needed for IE
      };


      self.hasOption = function(value) {
        return optionsMap.hasOwnProperty(value);
      };

      $scope.$on('$destroy', function() {
        // disable unknown option so that we don't do work when the whole select is being destroyed
        self.renderUnknownOption = noop;
      });
    }],

    link: function(scope, element, attr, ctrls) {
      // if ngModel is not defined, we don't need to do anything
      if (!ctrls[1]) return;

      var selectCtrl = ctrls[0],
          ngModelCtrl = ctrls[1],
          multiple = attr.multiple,
          optionsExp = attr.ngOptions,
          nullOption = false, // if false, user will not be able to select it (used by ngOptions)
          emptyOption,
          // we can't just jqLite('<option>') since jqLite is not smart enough
          // to create it in <select> and IE barfs otherwise.
          optionTemplate = jqLite(document.createElement('option')),
          optGroupTemplate =jqLite(document.createElement('optgroup')),
          unknownOption = optionTemplate.clone();

      // find "null" option
      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
        if (children[i].value === '') {
          emptyOption = nullOption = children.eq(i);
          break;
        }
      }

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      // required validator
      if (multiple) {
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      }

      if (optionsExp) setupAsOptions(scope, element, ngModelCtrl);
      else if (multiple) setupAsMultiple(scope, element, ngModelCtrl);
      else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);


      ////////////////////////////



      function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
        ngModelCtrl.$render = function() {
          var viewValue = ngModelCtrl.$viewValue;

          if (selectCtrl.hasOption(viewValue)) {
            if (unknownOption.parent()) unknownOption.remove();
            selectElement.val(viewValue);
            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
          } else {
            if (isUndefined(viewValue) && emptyOption) {
              selectElement.val('');
            } else {
              selectCtrl.renderUnknownOption(viewValue);
            }
          }
        };

        selectElement.on('change', function() {
          scope.$apply(function() {
            if (unknownOption.parent()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          });
        });
      }

      function setupAsMultiple(scope, selectElement, ctrl) {
        var lastView;
        ctrl.$render = function() {
          var items = new HashMap(ctrl.$viewValue);
          forEach(selectElement.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        scope.$watch(function selectMultipleWatch() {
          if (!equals(lastView, ctrl.$viewValue)) {
            lastView = copy(ctrl.$viewValue);
            ctrl.$render();
          }
        });

        selectElement.on('change', function() {
          scope.$apply(function() {
            var array = [];
            forEach(selectElement.find('option'), function(option) {
              if (option.selected) {
                array.push(option.value);
              }
            });
            ctrl.$setViewValue(array);
          });
        });
      }

      function setupAsOptions(scope, selectElement, ctrl) {
        var match;

        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw ngOptionsMinErr('iexp',
            "Expected expression in form of " +
            "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
            " but got '{0}'. Element:{1}",
            optionsExp, startingTag(selectElement));
        }

        var displayFn = $parse(match[2] || match[1]),
            valueName = match[4] || match[6],
            keyName = match[5],
            groupByFn = $parse(match[3] || ''),
            valueFn = $parse(match[2] ? match[1] : valueName),
            valuesFn = $parse(match[7]),
            track = match[8],
            trackFn = track ? $parse(match[8]) : null,
            // This is an array of array of existing option groups in DOM.
            // We try to reuse these if possible
            // - optionGroupsCache[0] is the options with no option group
            // - optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
            optionGroupsCache = [[{element: selectElement, label:''}]];

        if (nullOption) {
          // compile the element since there might be bindings in it
          $compile(nullOption)(scope);

          // remove the class, which is added automatically because we recompile the element and it
          // becomes the compilation root
          nullOption.removeClass('ng-scope');

          // we need to remove it before calling selectElement.empty() because otherwise IE will
          // remove the label from the element. wtf?
          nullOption.remove();
        }

        // clear contents, we'll add what's needed based on the model
        selectElement.empty();

        selectElement.on('change', function() {
          scope.$apply(function() {,
                key, value, optionElement, index, groupIndex, length, groupLength, trackIndex;

            if (multiple) {
              value = [];
              for (groupIndex = 0, groupLength = optionGroupsCache.length;
                   groupIndex < groupLength;
                   groupIndex++) {
                // list of options for that group. (first item has the parent)
                optionGroup = optionGroupsCache[groupIndex];

                for(index = 1, length = optionGroup.length; index < length; index++) {
                  if ((optionElement = optionGroup[index].element)[0].selected) {
                    key = optionElement.val();
                    if (keyName) locals[keyName] = key;
                    if (trackFn) {
                      for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                        locals[valueName] = collection[trackIndex];
                        if (trackFn(scope, locals) == key) break;
                      }
                    } else {
                      locals[valueName] = collection[key];
                    }
                    value.push(valueFn(scope, locals));
                  }
                }
              }
            } else {
              key = selectElement.val();
              if (key == '?') {
                value = undefined;
              } else if (key === ''){
                value = null;
              } else {
                if (trackFn) {
                  for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                    locals[valueName] = collection[trackIndex];
                    if (trackFn(scope, locals) == key) {
                      value = valueFn(scope, locals);
                      break;
                    }
                  }
                } else {
                  locals[valueName] = collection[key];
                  if (keyName) locals[keyName] = key;
                  value = valueFn(scope, locals);
                }
              }
            }
            ctrl.$setViewValue(value);
          });
        });

        ctrl.$render = render;

        // TODO(vojta): can't we optimize this ?
        scope.$watch(render);

        function render() {
              // Temporary location for the option groups before we render them
          var optionGroups = {'':[]},
              selected,
              selectedSet = false, // nothing is selected yet
              lastElement,
              element,
              label;

          if (multiple) {
            if (trackFn && isArray(modelValue)) {
              selectedSet = new HashMap([]);
              for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                locals[valueName] = modelValue[trackIndex];
                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
              }
            } else {
              selectedSet = new HashMap(modelValue);
            }
          }

          // We now build up the list of options we need (we merge later)
          for (index = 0; length = keys.length, index < length; index++) {
            
            key = index;
            if (keyName) {
              key = keys[index];
              if ( key.charAt(0) === '$' ) continue;
              locals[keyName] = key;
            }

            locals[valueName] = values[key];

            optionGroupName = groupByFn(scope, locals) || '';
            if (!(optionGroup = optionGroups[optionGroupName])) {
              optionGroup = optionGroups[optionGroupName] = [];
              optionGroupNames.push(optionGroupName);
            }
            if (multiple) {
              selected = isDefined(
                selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals))
              );
            } else {
              if (trackFn) {;
                modelCast[valueName] = modelValue;
                selected = trackFn(scope, modelCast) === trackFn(scope, locals);
              } else {
                selected = modelValue === valueFn(scope, locals);
              }
              selectedSet = selectedSet || selected; // see if at least one item is selected
            }
            label = displayFn(scope, locals); // what will be seen by the user

            // doing displayFn(scope, locals) || '' overwrites zero values
            label = isDefined(label) ? label : '';
            optionGroup.push({
              // either the index into array or key from object
              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),
              label: label,
              selected: selected                   // determine if we should be selected
            });
          }
          if (!multiple) {
            if (nullOption || modelValue === null) {
              // insert null option if we have a placeholder, or the model is null
              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});
            } else if (!selectedSet) {
              // option could not be found, we have to insert the undefined item
              optionGroups[''].unshift({id:'?', label:'', selected:true});
            }
          }

          // Now we need to update the list of DOM nodes to match the optionGroups we computed above
          for (groupIndex = 0, groupLength = optionGroupNames.length;
               groupIndex < groupLength;
               groupIndex++) {
            // current option group name or '' if no group
            optionGroupName = optionGroupNames[groupIndex];

            // list of options for that group. (first item has the parent)
            optionGroup = optionGroups[optionGroupName];

            if (optionGroupsCache.length <= groupIndex) {
              // we need to grow the optionGroups
              existingParent = {
                element: optGroupTemplate.clone().attr('label', optionGroupName),
                label: optionGroup.label
              };
              existingOptions = [existingParent];
              optionGroupsCache.push(existingOptions);
              selectElement.append(existingParent.element);
            } else {
              existingOptions = optionGroupsCache[groupIndex];
              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

              // update the OPTGROUP label if not the same.
              if (existingParent.label != optionGroupName) {
                existingParent.element.attr('label', existingParent.label = optionGroupName);
              }
            }

            lastElement = null;  // start at the beginning
            for(index = 0, length = optionGroup.length; index < length; index++) {
              option = optionGroup[index];
              if ((existingOption = existingOptions[index+1])) {
                // reuse elements
                lastElement = existingOption.element;
                if (existingOption.label !== option.label) {
                  lastElement.text(existingOption.label = option.label);
                }
                if (existingOption.id !== option.id) {
                  lastElement.val(existingOption.id = option.id);
                }
                // lastElement.prop('selected') provided by jQuery has side-effects
                if (lastElement[0].selected !== option.selected) {
                  lastElement.prop('selected', (existingOption.selected = option.selected));
                }
              } else {
                // grow elements

                // if it's a null option
                if (option.id === '' && nullOption) {
                  // put back the pre-compiled element
                  element = nullOption;
                } else {
                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                  // in this version of jQuery on some browser the .text() returns a string
                  // rather then the element.
                  (element = optionTemplate.clone())
                      .val(option.id)
                      .attr('selected', option.selected)
                      .text(option.label);
                }

                existingOptions.push(existingOption = {
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                });
                if (lastElement) {
                  lastElement.after(element);
                } else {
                  existingParent.element.append(element);
                }
                lastElement = element;
              }
            }
            // remove any excessive OPTIONs in a group
            index++; // increment since the existingOptions[0] is parent element not OPTION
            while(existingOptions.length > index) {
              existingOptions.pop().element.remove();
            }
          }
          // remove any excessive OPTGROUPs from select
          while(optionGroupsCache.length > groupIndex) {
            optionGroupsCache.pop()[0].element.remove();
          }
        }
      }
    }
  };
}];

var optionDirective = ['$interpolate', function($interpolate) {
  var nullSelectCtrl = {
    addOption: noop,
    removeOption: noop
  };

  return {
    restrict: 'E',
    priority: 100,
    compile: function(element, attr) {
      if (isUndefined(attr.value)) {
        var interpolateFn = $interpolate(element.text(), true);
        if (!interpolateFn) {
          attr.$set('value', element.text());
        }
      }

      return function (scope, element, attr) {
        var selectCtrlName = '$selectController',
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); // in case we are in optgroup

        if (selectCtrl && selectCtrl.databound) {
          // For some reason Opera defaults to true and if not overridden this messes up the repeater.
          // We don't want the view to drive the initialization of the model anyway.
          element.prop('selected', false);
        } else {
          selectCtrl = nullSelectCtrl;
        }

        if (interpolateFn) {
          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
            attr.$set('value', newVal);
            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
            selectCtrl.addOption(newVal);
          });
        } else {
          selectCtrl.addOption(attr.value);
        }

        element.on('$destroy', function() {
          selectCtrl.removeOption(attr.value);
        });
      };
    }
  };
}];

var styleDirective = valueFn({
  restrict: 'E',
  terminal: true
});

  //try to bind to jquery now so that one can write angular.element().read()
  //but we will rebind on bootstrap again.
  bindJQuery();

  publishExternalAPI(angular);

  jqLite(document).ready(function() {
    angularInit(document, bootstrap);
  });

})(window, document);

!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}</style>');
/*!
 * Bootstrap v3.0.3 (http://getbootstrap.com)
 * Copyright 2013 Twitter, Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0
 */
if (typeof jQuery === "undefined") { throw new Error("Bootstrap requires jQuery") }




+function ($) { "use strict";

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      'WebkitTransition' : 'webkitTransitionEnd'
    , 'MozTransition'    : 'transitionend'
    , 'OTransition'      : 'oTransitionEnd otransitionend'
    , 'transition'       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false, $el = this
    $(this).one($.support.transition.end, function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()
  })

}(jQuery);




+function ($) { "use strict";

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss=alert]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.hasClass('alert') ? $this : $this.parent()
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      $parent.trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one($.support.transition.end, removeElement)
        .emulateTransitionEnd(150) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  var old = $.fn.alert

  $.fn.alert = function (option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);




+function ($) { "use strict";

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {, Button.DEFAULTS, options)
  }

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (!data.resetText) $el.data('resetText', $el[val]())

    $el[val](data[state] || this.options[state])

    // push to event loop to allow forms to submit
    setTimeout(function () {
      state == 'loadingText' ?
        $el.addClass(d).attr(d, d) :
        $el.removeClass(d).removeAttr(d);
    }, 0)
  }

  Button.prototype.toggle = function () {
    var $parent = this.$element.closest('[data-toggle=buttons]')
    var changed = true

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') === 'radio') {
        // see if clicking on current one
        if ($input.prop('checked') && this.$element.hasClass('active'))
          changed = false
        else
          $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  var old = $.fn.button

  $.fn.button = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document).on('click.bs.button.data-api', '[data-toggle^=button]', function (e) {
    var $btn = $(e.target)
    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
    $btn.button('toggle')
    e.preventDefault()
  })

}(jQuery);




+function ($) { "use strict";

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.pause == 'hover' && this.$element
      .on('mouseenter', $.proxy(this.pause, this))
      .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.DEFAULTS = {
    interval: 5000
  , pause: 'hover'
  , wrap: true
  }

  Carousel.prototype.cycle =  function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getActiveIndex = function () {
    this.$active = this.$element.find('.item.active')
    this.$items  = this.$active.parent().children()

    return this.$items.index(this.$active)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getActiveIndex()

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) })
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition.end) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || $active[type]()
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    this.sliding = true

    isCycling && this.pause()

    var e = $.Event('slide.bs.carousel', { relatedTarget: $next[0], direction: direction })

    if ($next.hasClass('active')) return

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      this.$element.one('slid.bs.carousel', function () {
        var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
        $nextIndicator && $nextIndicator.addClass('active')
      })
    }

    if ($.support.transition && this.$element.hasClass('slide')) {
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one($.support.transition.end, function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () { that.$element.trigger('slid.bs.carousel') }, 0)
        })
        .emulateTransitionEnd(600)
    } else {
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger('slid.bs.carousel')
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  var old = $.fn.carousel

  $.fn.carousel = function (option) {
    return this.each(function () {, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  $(document).on('click.bs.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    $target.carousel(options)

    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  })

  $(window).on('load', function () {
    $('[data-ride=carousel]').each(function () {
      var $carousel = $(this)
      $carousel.carousel($carousel.data())
    })
  })

}(jQuery);




+function ($) { "use strict";

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {, Collapse.DEFAULTS, options)
    this.transitioning = null

    if (this.options.parent) this.$parent = $(this.options.parent)
    if (this.options.toggle) this.toggle()
  }

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var actives = this.$parent && this.$parent.find('> .panel > .in')

    if (actives && actives.length) {
      var hasData = actives.data('bs.collapse')
      if (hasData && hasData.transitioning) return
      actives.collapse('hide')
      hasData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')
      [dimension](0)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('in')
        [dimension]('auto')
      this.transitioning = 0
      this.$element.trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one($.support.transition.end, $.proxy(complete, this))
      .emulateTransitionEnd(350)
      [dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element
      [dimension](this.$element[dimension]())
      [0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse')
      .removeClass('in')

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .trigger('hidden.bs.collapse')
        .removeClass('collapsing')
        .addClass('collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one($.support.transition.end, $.proxy(complete, this))
      .emulateTransitionEnd(350)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  var old = $.fn.collapse

  $.fn.collapse = function (option) {
    return this.each(function () {, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this   = $(this), href
    var target  = $this.attr('data-target')
        || e.preventDefault()
        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
    var $target = $(target)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()
    var parent  = $this.attr('data-parent')
    var $parent = parent && $(parent)

    if (!data || !data.transitioning) {
      if ($parent) $parent.find('[data-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass('collapsed')
      $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
    }

    $target.collapse(option)
  })

}(jQuery);




+function ($) { "use strict";

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle=dropdown]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      $parent.trigger(e = $.Event('show.bs.dropdown'))

      if (e.isDefaultPrevented()) return

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown')

      $this.focus()
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27)/.test(e.keyCode)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive || (isActive && e.keyCode == 27)) {
      if (e.which == 27) $parent.find(toggle).focus()
      return $this.click()
    }

    var $items = $('[role=menu] li:not(.divider):visible a', $parent)

    if (!$items.length) return

    var index = $items.index($items.filter(':focus'))

    if (e.keyCode == 38 && index > 0)                 index--                        // up
    if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index=0

    $items.eq(index).focus()
  }

  function clearMenus() {
    $(backdrop).remove()
    $(toggle).each(function (e) {
      var $parent = getParent($(this))
      if (!$parent.hasClass('open')) return
      $parent.trigger(e = $.Event('hide.bs.dropdown'))
      if (e.isDefaultPrevented()) return
      $parent.removeClass('open').trigger('hidden.bs.dropdown')
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  var old = $.fn.dropdown

  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)

}(jQuery);




+function ($) { "use strict";

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options   = options
    this.$element  = $(element)
    this.$backdrop =
    this.isShown   = null

    if (this.options.remote) this.$element.load(this.options.remote)
  }

  Modal.DEFAULTS = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this[!this.isShown ? 'show' : 'hide'](_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.escape()

    this.$element.on('click.dismiss.modal', '[data-dismiss=modal]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(document.body) // don't move modals dom position
      }

      that.$element.show()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one($.support.transition.end, function () {
            that.$element.focus().trigger(e)
          })
          .emulateTransitionEnd(300) :
        that.$element.focus().trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one($.support.transition.end, $.proxy(this.hideModal, this))
        .emulateTransitionEnd(300) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.focus()
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keyup.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.removeBackdrop()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that    = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(document.body)

      this.$element.on('click.dismiss.modal', $.proxy(function (e) {
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus.call(this.$element[0])
          : this.hide.call(this)
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one($.support.transition.end, callback)
          .emulateTransitionEnd(150) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      $.support.transition && this.$element.hasClass('fade')?
        this.$backdrop
          .one($.support.transition.end, callback)
          .emulateTransitionEnd(150) :
        callback()

    } else if (callback) {
      callback()
    }
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  var old = $.fn.modal

  $.fn.modal = function (option, _relatedTarget) {
    return this.each(function () {, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle=modal]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
    var option  = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    e.preventDefault()

    $target
      .modal(option, this)
      .one('hide', function () {
        $this.is(':visible') && $this.focus()
      })
  })

  $(document)
    .on('show.bs.modal',  '.modal', function () { $(document.body).addClass('modal-open') })
    .on('hidden.bs.modal', '.modal', function () { $(document.body).removeClass('modal-open') })

}(jQuery);




+function ($) { "use strict";

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.DEFAULTS = {
    animation: true
  , placement: top
  , selector: false
  , template: '<div class=tooltip><div class=tooltip-arrow></div><div class=tooltip-inner></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled  = true
    this.type     = type
    this.$element = $(element)
    this.options  = this.getOptions(options)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focus'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay
      , hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.'+ this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      var $tip = this.tip()

      this.setContent()

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var $parent = this.$element.parent()

        var orgPlacement = placement
        var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
        var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
        var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
        var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

        placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
                    placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
                    placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
                    placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)
      this.$element.trigger('shown.bs.' + this.type)
    }
  }

  Tooltip.prototype.applyPlacement = function(offset, placement) {
    var replace
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    $tip
      .offset(offset)
      .addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      replace = true
      offset.top = offset.top + height - actualHeight
    }

    if (/bottom|top/.test(placement)) {
      var delta = 0

      if (offset.left < 0) {
        delta       = offset.left * -2
        offset.left = 0

        $tip.offset(offset)

        actualWidth  = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight
      }

      this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
    } else {
      this.replaceArrow(actualHeight - height, actualHeight, 'top')
    }

    if (replace) $tip.offset(offset)
  }

  Tooltip.prototype.replaceArrow = function(delta, dimension, position) {
    this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function () {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one($.support.transition.end, complete)
        .emulateTransitionEnd(150) :
      complete()

    this.$element.trigger('hidden.bs.' + this.type)

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function () {, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
      width: el.offsetWidth
    , height: el.offsetHeight
    }, this.$element.offset())
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
         { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.tip = function () {
    return this.$tip = this.$tip || $(this.options.template)
  }

  Tooltip.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
  }

  Tooltip.prototype.validate = function () {
    if (!this.$element[0].parentNode) {
      this.hide()
      this.$element = null
      this.options  = null
    }
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  var old = $.fn.tooltip

  $.fn.tooltip = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);




+function ($) { "use strict";

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  } , $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  }, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.arrow')
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  var old = $.fn.popover

  $.fn.popover = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);




+function ($) { "use strict";

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target
      || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
      || '') + ' .nav li > a'
    this.offsets        = $([])
    this.targets        = $([])
    this.activeTarget   = null

    this.refresh()
    this.process()
  }

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = this.$element[0] == window ? 'offset' : 'position'

    this.offsets = $([])
    this.targets = $([])

    var self     = this
    var $targets = this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#\w/.test(href) && $(href)

        return ($href
          && $href.length
          && [[ $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
    var maxScroll    = scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets.last()[0]) && this.activate(i)
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate( targets[i] )
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    $(this.selector)
      .parents('.active')
      .removeClass('active')

    var selector = this.selector
      + '[data-target="' + target + '"],'
      + this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length)  {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  var old = $.fn.scrollspy

  $.fn.scrollspy = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load', function () {
    $('[data-spy=scroll]').each(function () {
      var $spy = $(this)
      $spy.scrollspy($spy.data())
    })
  })

}(jQuery);




+function ($) { "use strict";

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var previous = $ul.find('.active:last a')[0]
    var e        = $.Event('show.bs.tab', {
      relatedTarget: previous
    })

    $this.trigger(e)

    if (e.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.parent('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $this.trigger({
        type: 'shown.bs.tab'
      , relatedTarget: previous
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && $active.hasClass('fade')

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
        .removeClass('active')

      element.addClass('active')

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element.closest('li.dropdown').addClass('active')
      }

      callback && callback()
    }

    transition ?
      $active
        .one($.support.transition.end, next)
        .emulateTransitionEnd(150) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  var old = $.fn.tab

  $.fn.tab = function ( option ) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  $(document).on('click.bs.tab.data-api', '[data-toggle=tab], [data-toggle=pill]', function (e) {
    e.preventDefault()
    $(this).tab('show')
  })

}(jQuery);




+function ($) { "use strict";

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {, Affix.DEFAULTS, options)
    this.$window = $(window)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element = $(element)
    this.affixed  =
    this.unpin    = null

    this.checkPosition()
  }

  Affix.RESET = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var scrollHeight = $(document).height()
    var scrollTop    = this.$window.scrollTop()
    var position     = this.$element.offset()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top()
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

    var affix = this.unpin   != null && (scrollTop + this.unpin <= position.top) ? false :
                offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' :
                offsetTop    != null && (scrollTop <= offsetTop) ? 'top' : false

    if (this.affixed === affix) return
    if (this.unpin) this.$element.css('top', '')

    this.affixed = affix
    this.unpin   = affix == 'bottom' ? position.top - scrollTop : null

    this.$element.removeClass(Affix.RESET).addClass('affix' + (affix ? '-' + affix : ''))

    if (affix == 'bottom') {
      this.$element.offset({ top: document.body.offsetHeight - offsetBottom - this.$element.height() })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  var old = $.fn.affix

  $.fn.affix = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy=affix]').each(function () {

      if (data.offsetBottom) data.offset.bottom = data.offsetBottom
      if (data.offsetTop)    data.offset.top    = data.offsetTop

      $spy.affix(data)
    })
  })

}(jQuery);


(function(window, angular, undefined) {'use strict';

var $resourceMinErr = angular.$$minErr('$resource');

// Helper functions and regex to lookup a dotted path on an object
// stopping at undefined/null.  The path must be composed of ASCII
// identifiers (just like $parse)
var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$][0-9a-zA-Z_$]*)+$/;

function isValidDottedPath(path) {
  return (path != null && path !== '' && path !== 'hasOwnProperty' &&
      MEMBER_NAME_REGEX.test('.' + path));
}

function lookupDottedPath(obj, path) {
  if (!isValidDottedPath(path)) {// Match everything outside of normal chars and " (quote character)
  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var voidElements = makeMap("area,BEGING_END_TAGE_REGEXP=/^<\s*\//,BEGIN_TAG_REGEXP=/^</,CDATA_REGEXP=/<!\[CDATA\[(.*?)]]>/g,COMMENT_REGEXP=/<!--(.*?)-->/g,DOCTYPE_REGEXP=/<!DOCTYPE([^>]*?)>/i," is invalid.', path);
  }
  var keys = path.split('.');
  for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {
    var key = keys[i];
    obj = (obj !== null) ? obj[key] : undefined;
  }
  return obj;
}


function shallowClearAndCopy(src, dst) {;

  angular.forEach(dst, function(value, key){
    delete dst[key];
  });

  for (var key in src) {
    if (src.hasOwnProperty(key) && key.charAt(0) !== '$' && key.charAt(1) !== '$') {
      dst[key] = src[key];
    }
  }

  return dst;
}




angular.module('ngResource', ['ng']).
  factory('$resource', ['$http', '$q', function($http, $q) {

    var DEFAULT_ACTIONS = {
      'get':    {method:'GET'},
      'save':   {method:'POST'},
      'query':  {method:'GET', isArray:true},
      'remove': {method:'DELETE'},
      'delete': {method:'DELETE'}
    };
    var noop = angular.noop,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy,
        isFunction = angular.isFunction;

    
    function encodeUriSegment(val) {
      return encodeUriQuery(val, true).
        replace(/%26/gi, '&').
        replace(/%3D/gi, '=').
        replace(/%2B/gi, '+');
    }


    
    function encodeUriQuery(val, pctEncodeSpaces) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
    }

    function Route(template, defaults) {;
    }

    Route.prototype = {
      setUrlParams: function(config, params, actionUrl) {;
        forEach(url.split(/\W/), function(param){
          if (param === 'hasOwnProperty') {
            throw $resourceMinErr('badname', "hasOwnProperty is not a valid parameter name.");
          }
          if (!(new RegExp("^\\d+$").test(param)) && param &&
               (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
            urlParams[param] = true;
          }
        };
        forEach(self.urlParams, function(_, urlParam){
          val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
          if (angular.isDefined(val) && val !== null) {
            encodedVal = encodeUriSegment(val);
            url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), encodedVal + "$1");
          } else {
            url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match,
                leadingSlashes, tail) {
              if (tail.charAt(0) == '/') {
                return tail;
              } else {
                return leadingSlashes + tail;
              }
            });
          }
        });

        // strip trailing slashes and set the url
        url = url.replace(/\/+$/, '');
        // then replace collapse `/.` if found in the last URL path segment before the query
        // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`
        url = url.replace(/\/\.(?=\w+($|\?))/, '.');
        // replace escaped `/\.` with `/.`
        config.url = url.replace(/\/\\\./, '/.');


        // set params - delegate param encoding to $http
        forEach(params, function(value, key){
          if (!self.urlParams[key]) {;
            config.params[key] = value;
          }
        });
      }
    };


    function resourceFactory(url, paramDefaults, actions) {, DEFAULT_ACTIONS, actions);

      function extractParams(data, actionParams){, paramDefaults, actionParams);
        forEach(actionParams, function(value, key){
          if (isFunction(value)) { value = value(); }
          ids[key] = value && value.charAt && value.charAt(0) == '@' ?
            lookupDottedPath(data, value.substr(1)) : value;
        });
        return ids;
      }

      function defaultResponseInterceptor(response) {
        return response.resource;
      }

      function Resource(value){, this);
      }

      forEach(actions, function(action, name) {
        var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);

        Resource[name] = function(a1, a2, a3, a4) {, data, success, error;

           
          switch(arguments.length) {
          case 4:
            error = a4;
            success = a3;
            //fallthrough
          case 3:
          case 2:
            if (isFunction(a2)) {
              if (isFunction(a1)) {
                success = a1;
                error = a2;
                break;
              }

              success = a2;
              error = a3;
              //fallthrough
            } else {
              params = a1;
              data = a2;
              success = a3;
              break;
            }
          case 1:
            if (isFunction(a1)) success = a1;
            else if (hasBody) data = a1;
            else params = a1;
            break;
          case 0: break;
          default:
            throw $resourceMinErr('badargs',
              "Expected up to 4 arguments [params," +
        "aside," +
        "bdi," +
        "h6," +
        "samp,abbr,acronym,arguments",
              arguments.length);
          };
          var responseInterceptor = action.interceptor && action.interceptor.response ||
                                    defaultResponseInterceptor;
          var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||
                                    undefined;

          forEach(action, function(value, key) {
            if (key != 'params' && key != 'isArray' && key != 'interceptor') {
              httpConfig[key] = copy(value);
            }
          }), params),
                             action.url);

          var promise = $http(httpConfig).then(function(response) {
            var data = response.data,
                promise = value.$promise;

            if (data) {
              // Need to convert action.isArray to boolean in case it is undefined
              // jshint -W018
              if (angular.isArray(data) !== (!!action.isArray)) {
                throw $resourceMinErr('badcfg', 'Error in resource configuration. Expected ' +
                  'response to contain an {0} but got an {1}',
                  action.isArray?'array':'object', angular.isArray(data)?'array':'object');
              }
              // jshint +W018
              if (action.isArray) {
                value.length = 0;
                forEach(data, function(item) {
                  value.push(new Resource(item));
                });
              } else {
                shallowClearAndCopy(data, value);
                value.$promise = promise;
              }
            }

            value.$resolved = true;

            response.resource = value;

            return response;
          }, function(response) {
            value.$resolved = true;

            (error||noop)(response);

            return $q.reject(response);
          });

          promise = promise.then(
              function(response) {
                var value = responseInterceptor(response);
                (success||noop)(value, response.headers);
                return value;
              },
              responseErrorInterceptor);

          if (!isInstanceCall) {
            // we are creating instance / collection
            // - set the initial promise
            // - return the instance / collection
            value.$promise = promise;
            value.$resolved = false;

            return value;
          }

          // instance call
          return promise;
        };


        Resource.prototype['$' + name] = function(params, success, error) {
          if (isFunction(params)) {;
          }
          var result = Resource[name].call(this, params, this, success, error);
          return result.$promise || result;
        };
      });

      Resource.bind = function(additionalParamDefaults){, paramDefaults, additionalParamDefaults), actions);
      };

      return Resource;
    }

    return resourceFactory;
  }]);


})(window, window.angular);


(function(window, angular, undefined) {'use strict';




angular.module('ngCookies', ['ng']).
  
   factory('$cookies', ['$rootScope', '$browser', function ($rootScope, $browser) {,
          lastBrowserCookies,
          runEval = false,
          copy = angular.copy,
          isUndefined = angular.isUndefined;

      //creates a poller fn that copies all cookies from the $browser to service & inits the service
      $browser.addPollFn(function() {
        var currentCookies = $browser.cookies();
        if (lastBrowserCookies != currentCookies) { //relies on browser.cookies() impl
          lastBrowserCookies = currentCookies;
          copy(currentCookies, lastCookies);
          copy(currentCookies, cookies);
          if (runEval) $rootScope.$apply();
        }
      })();

      runEval = true;

      //at the end of each eval, push cookies
      //TODO: this should happen before the "delayed" watches fire, because if some cookies are not
      //      strings or browser refuses to store some cookies, we update the model in the push fn.
      $rootScope.$watch(push);

      return cookies;


      
      function push() {
        var name,
            value,
            browserCookies,
            updated;

        //delete any cookies deleted in $cookies
        for (name in lastCookies) {
          if (isUndefined(cookies[name])) {
            $browser.cookies(name, undefined);
          }
        }

        //update all cookies updated in $cookies
        for(name in cookies) {
          value = cookies[name];
          if (!angular.isString(value)) {
            if (angular.isDefined(lastCookies[name])) {
              cookies[name] = lastCookies[name];
            } else {
              delete cookies[name];
            }
          } else if (value !== lastCookies[name]) {
            $browser.cookies(name, value);
            updated = true;
          }
        }

        //verify what was actually stored
        if (updated){
          updated = false;
          browserCookies = $browser.cookies();

          for (name in cookies) {
            if (cookies[name] !== browserCookies[name]) {
              //delete or reset all cookies that the browser dropped from $cookies
              if (isUndefined(browserCookies[name])) {
                delete cookies[name];
              } else {
                cookies[name] = browserCookies[name];
              }
              updated = true;
            }
          }
        }
      }
    }]).


  
   factory('$cookieStore', ['$cookies', function($cookies) {

      return {
        
        get: function(key) {
          var value = $cookies[key];
          return value ? angular.fromJson(value) : value;
        },

        
        put: function(key, value) {
          $cookies[key] = angular.toJson(value);
        },

        
        remove: function(key) {
          delete $cookies[key];
        }
      };

    }]);


})(window, window.angular);


(function(window, angular, undefined) {'use strict';

var $sanitizeMinErr = angular.$$minErr('$sanitize');







function $SanitizeProvider() {
  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, angular.noop);
  writer.chars(chars);
  return buf.join('');
}, uriAttrs, makeMap(
    'abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,'+
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,'+
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,'+
    'scope,scrolling,shape,span,start,summary,target,title,type,'+
    'valign,value,vspace,width'));

function makeMap(str) {, items = str.split(','), i;
  for (i = 0; i < items.length; i++) obj[items[i]] = true;
  return obj;
}



function htmlParser( html, handler ) {
  var index, chars, match, stack = [], last = html;
  stack.last = function() { return stack[ stack.length - 1 ]; };

  while ( html ) {
    chars = true;

    // Make sure we're not in a script or style element
    if ( !stack.last() || !specialElements[ stack.last() ] ) {

      // Comment
      if ( html.indexOf("<!--") === 0 ) {
        // comments containing -- are not allowed unless they terminate the comment
        index = html.indexOf("--", 4);

        if ( index >= 0 && html.lastIndexOf("-->", index) === index) {
          if (handler.comment) handler.comment( html.substring( 4, index ) );
          html = html.substring( index + 3 );
          chars = false;
        }
      // DOCTYPE
      } else if ( DOCTYPE_REGEXP.test(html) ) {
        match = html.match( DOCTYPE_REGEXP );

        if ( match ) {
          html = html.replace( match[0] , '');
          chars = false;
        }
      // end tag
      } else if ( BEGING_END_TAGE_REGEXP.test(html) ) {
        match = html.match( END_TAG_REGEXP );

        if ( match ) {
          html = html.substring( match[0].length );
          match[0].replace( END_TAG_REGEXP, parseEndTag );
          chars = false;
        }

      // start tag
      } else if ( BEGIN_TAG_REGEXP.test(html) ) {
        match = html.match( START_TAG_REGEXP );

        if ( match ) {
          html = html.substring( match[0].length );
          match[0].replace( START_TAG_REGEXP, parseStartTag );
          chars = false;
        }
      }

      if ( chars ) {
        index = html.indexOf("<");

        var text = index < 0 ? html : html.substring( 0, index );
        html = index < 0 ? "" : html.substring( index );

        if (handler.chars) handler.chars( decodeEntities(text) );
      }

    } else {
      html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
        function(all, text){
          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");

          if (handler.chars) handler.chars( decodeEntities(text) );

          return "";
      });

      parseEndTag( "", stack.last() );
    }

    if ( html == last ) {
      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
                                        "of html:,var"));


// Special Elements (can contain anything)
var specialElements = makeMap("script,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var optionalEndTagBlockElements = makeMap("colgroup{0},", html);
    }
    last = html;
  }

  // Clean up any remaining tags
  parseEndTag();

  function parseStartTag( tag, tagName, rest, unary ) {
    tagName = angular.lowercase(tagName);
    if ( blockElements[ tagName ] ) {
      while ( stack.last() && inlineElements[ stack.last() ] ) {
        parseEndTag( "", stack.last() );
      }
    }

    if ( optionalEndTagElements[ tagName ] && stack.last() == tagName ) {
      parseEndTag( "", tagName );
    };

    rest.replace(ATTR_REGEXP,
      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
        var value = doubleQuotedValue
          || singleQuotedValue
          || unquotedValue
          || '';

        attrs[name] = decodeEntities(value);
    });
    if (handler.start) handler.start( tagName, attrs, unary );
  }

  function parseEndTag( tag, tagName ) {
    var pos = 0, i;
    tagName = angular.lowercase(tagName);
    if ( tagName )
      // Find the closest opened tag of the same type
      for ( pos = stack.length - 1; pos >= 0; pos-- )
        if ( stack[ pos ] == tagName )
          break;

    if ( pos >= 0 ) {
      // Close all the open elements, up the stack
      for ( i = stack.length - 1; i >= pos; i-- )
        if (handler.end) handler.end( stack[ i ] );

      // Remove the open elements from the stack
      stack.length = pos;
    }
  }
}

var hiddenPre=document.createElement("pre");
var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;

function decodeEntities(value) {
  if (!value) { return ''; }

  // Note: IE8 does not preserve spaces at the start/end of innerHTML
  // so we must capture them and reattach them afterward
  var parts = spaceRe.exec(value);
  var spaceBefore = parts[1];
  var spaceAfter = parts[3];
  var content = parts[2];
  if (content) {
    hiddenPre.innerHTML=content.replace(/</g,"&lt;");
    // innerText depends on styling as it doesn't display hidden elements.
    // Therefore, it's better to use textContent not to cause unnecessary
    // reflows. However, IE<9 don't support textContent so the innerText
    // fallback is necessary.
    content = 'textContent' in hiddenPre ?
      hiddenPre.textContent : hiddenPre.innerText;
  }
  return spaceBefore + content + spaceAfter;
}


function encodeEntities(value) {
  return value.
    replace(/&/g, '&amp;').
    replace(NON_ALPHANUMERIC_REGEXP, function(value){
      return '&#' + value.charCodeAt(0) + ';';
    }).
    replace(/</g, '&lt;').
    replace(/>/g, '&gt;');
}


function htmlSanitizeWriter(buf, uriValidator){
  var ignore = false;
  var out = angular.bind(buf, buf.push);
  return {
    start: function(tag, attrs, unary){
      tag = angular.lowercase(tag);
      if (!ignore && specialElements[tag]) {
        ignore = tag;
      }
      if (!ignore && validElements[tag] === true) {
        out('<');
        out(tag);
        angular.forEach(attrs, function(value, key){
          var lkey=angular.lowercase(key);
          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
          if (validAttrs[lkey] === true &&
            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
            out(' ');
            out(key);
            out('="');
            out(encodeEntities(value));
            out('"');
          }
        });
        out(unary ? '/>' : '>');
      }
    },
    end: function(tag){
        tag = angular.lowercase(tag);
        if (!ignore && validElements[tag] === true) {
          out('</');
          out(tag);
          out('>');
        }
        if (tag == ignore) {
          ignore = false;
        }
      },
    chars: function(chars){
        if (!ignore) {
          out(encodeEntities(chars));
        }
      }
  };
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);




angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {<>]/,
      MAILTO_REGEXP = /^mailto:/;

  return function(text, target) {
    if (!text) return text;
    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/mailto then assume mailto
      if (match[2] == match[3]) url = 'mailto:' + url;
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      html.push('<a ');
      if (angular.isDefined(target)) {
        html.push('target="');
        html.push(target);
        html.push('" ');
      }
      html.push('href="');
      html.push(url);
      html.push('">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);


(function(window, angular, undefined) {'use strict';


 
var ngRouteModule = angular.module('ngRoute', ['ng']).
                        provider('$route', $RouteProvider);


function $RouteProvider(){
  function inherit(parent, extra) {, {prototype:parent}))(), extra);
  };

  
  this.when = function(path, route) {
    routes[path] = angular.extend(
      {reloadOnSearch: true},
      route,
      path && pathRegExp(path, route)
    );

    // create redirection for trailing slashes
    if (path) {
      var redirectPath = (path[path.length-1] == '/')
            ? path.substr(0, path.length-1)
            : path +'/';

      routes[redirectPath] = angular.extend(
        {redirectTo: path},
        pathRegExp(redirectPath, route)
      );
    }

    return this;
  };

   
  function pathRegExp(path, opts) {
    var insensitive = opts.caseInsensitiveMatch,
        ret = {
          originalPath: path,
          regexp: path
        },
        keys = ret.keys = [];

    path = path
      .replace(/([().])/g, '\\$1')
      .replace(/(\/)?:(\w+)([\?|\*])?/g, function(_, slash, key, option){
        var optional = option === '?' ? option : null;
        var star = option === '*' ? option : null;
        keys.push({ name: key, optional: !!optional });
        slash = slash || '';
        return ''
          + (optional ? '' : slash)
          + '(?:'
          + (optional ? slash : '')
          + (star && '(.+?)' || '([^/]+)')
          + (optional || '')
          + ')'
          + (optional || '');
      })
      .replace(/([\/$\*])/g, '\\$1');

    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
    return ret;
  }

  
  this.otherwise = function(params) {
    this.when(null, params);
    return this;
  };


  this.$get = ['$rootScope',
               '$location',
               '$routeParams',
               '$q',
               '$injector',
               '$http',
               '$templateCache',
               '$sce',
      function($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache, $sce) {

    

    

    

    

    

    var forceReload = false,
        $route = {
          routes: routes,

          
          reload: function() {
            forceReload = true;
            $rootScope.$evalAsync(updateRoute);
          }
        };

    $rootScope.$on('$locationChangeSuccess', updateRoute);

    return $route;

    /////////////////////////////////////////////////////

    
    function switchRouteMatcher(on, route) {;

      if (!route.regexp) return null;

      var m = route.regexp.exec(on);
      if (!m) return null;

      for (var i = 1, len = m.length; i < len; ++i) {
        var key = keys[i - 1];

        var val = 'string' == typeof m[i]
              ? decodeURIComponent(m[i])
              : m[i];

        if (key && val) {
          params[key.name] = val;
        }
      }
      return params;
    }

    function updateRoute() {
      var next = parseRoute(),
          last = $route.current;

      if (next && last && next.$$route === last.$$route
          && angular.equals(next.pathParams, last.pathParams)
          && !next.reloadOnSearch && !forceReload) {
        last.params = next.params;
        angular.copy(last.params, $routeParams);
        $rootScope.$broadcast('$routeUpdate', last);
      } else if (next || last) {
        forceReload = false;
        $rootScope.$broadcast('$routeChangeStart', next, last);
        $route.current = next;
        if (next) {
          if (next.redirectTo) {
            if (angular.isString(next.redirectTo)) {
              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)
                       .replace();
            } else {
              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))
                       .replace();
            }
          }
        }

        $q.when(next).
          then(function() {
            if (next) {, next.resolve),
                  template, templateUrl;

              angular.forEach(locals, function(value, key) {
                locals[key] = angular.isString(value) ?
                    $injector.get(value) : $injector.invoke(value);
              });

              if (angular.isDefined(template = next.template)) {
                if (angular.isFunction(template)) {
                  template = template(next.params);
                }
              } else if (angular.isDefined(templateUrl = next.templateUrl)) {
                if (angular.isFunction(templateUrl)) {
                  templateUrl = templateUrl(next.params);
                }
                templateUrl = $sce.getTrustedResourceUrl(templateUrl);
                if (angular.isDefined(templateUrl)) {
                  next.loadedTemplateUrl = templateUrl;
                  template = $http.get(templateUrl, {cache: $templateCache}).
                      then(function(response) { return response.data; });
                }
              }
              if (angular.isDefined(template)) {
                locals['$template'] = template;
              }
              return $q.all(locals);
            }
          }).
          // after route change
          then(function(locals) {
            if (next == $route.current) {
              if (next) {
                next.locals = locals;
                angular.copy(next.params, $routeParams);
              }
              $rootScope.$broadcast('$routeChangeSuccess', next, last);
            }
          }, function(error) {
            if (next == $route.current) {
              $rootScope.$broadcast('$routeChangeError', next, last, error);
            }
          });
      }
    }


    
    function parseRoute() {
      // Match a route
      var params, match;
      angular.forEach(routes, function(route, path) {
        if (!match && (params = switchRouteMatcher($location.path(), route))) {
          match = inherit(route, {, $location.search(), params),
            pathParams: params});
          match.$$route = route;
        }
      });
      // No route matched; fallback to "otherwise" route return match || routes[null] && inherit(routes[null]{function interpolate(string,params){:var result=[];angular.forEach((string||'').split(':'),function(segment,i){if (i===0){result.push(segment)}$RouteParamsProvider);function $RouteParamsProvider(),ngRouteModule.provider('$routeParams'{this.$get=function(){$anchorScroll,$animate),'$anchorScroll','$animate'];function ngViewFactory($route,ngRouteModule.directive('ngView',ngViewFactory);ngRouteModule.directive('ngView',ngViewFillContentFactory);ngViewFactory.$inject=['$route'{return{restrict:'ECA',terminal:true,priority:400,transclude:'element',link:function(scope,$element,attr,ctrl,$transclude){var currentScope,currentElement,autoScrollExp=attr.autoscroll,onloadExp=attr.onload || '';:scope.$on('$routeChangeSuccess',update);:update();:function cleanupLastView(){if (currentScope){currentScope.$destroy();:currentScope=null}if(currentElement){:$animate.leave(currentElement);:currentElement=null}function update(){:var locals=$route.current && $route.current.locals,template=locals && locals.$template;:if (template){var newScope=scope.$new();:var current=$route.current;// Note:This will also link all children of ng-view that were contained in the original // html. If that content contains controllers,... they could pollute/change the scope. // However,using ng-view on an element with additional content does not make sense... // Note:We can't remove them in the cloneAttchFn of $transclude as that // function is called before linking the content,which would apply child // directives to non existing elements. var clone=$transclude(newScope,function(clone){$animate.enter(clone,null,currentElement || $element,function onNgViewEnter (){if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))){$anchorScroll()}$controller,$route),'$controller','$route'];function ngViewFillContentFactory($compile,// This directive is called during the $transclude call of the first `ngView` directive. // It will replace and compile the content of the element with the loaded template. // We need this directive so that the element content is already filled when // the link function of another directive on the same element as ngView // is called. ngViewFillContentFactory.$inject=['$compile'{return{restrict:'ECA',priority:-400,link:function(scope,$element){var current=$route.current,locals=current.locals;:$element.html(locals.$template);:var link=$compile($element.contents());:if (current.controller){locals.$scope=scope;:var controller=$controller(current.controller,locals);:if (current.controllerAs){scope[current.controllerAs]=controller})(window,window.angular);